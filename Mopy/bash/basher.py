# -*- coding: utf-8 -*-
#
# GPL License and Copyright Notice ============================================
#  This file is part of Wrye Bash.
#
#  Wrye Bash is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  Wrye Bash is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with Wrye Bash; if not, write to the Free Software Foundation,
#  Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#  Wrye Bash copyright (C) 2005, 2006, 2007, 2008, 2009 Wrye
#
# =============================================================================

"""This module provides the GUI interface for Wrye Bash. (However, the Wrye
Bash application is actually launched by the bash module.)

The module is generally organized starting with lower level elements, working
up to higher level elements (up the BashApp). This is followed by definition
of menus and buttons classes, and finally by a several initialization functions.

Non-GUI objects and functions are provided by the bosh module. Of those, the
primary objects used are the plugins, modInfos and saveInfos singletons -- each
representing external data structures (the plugins.txt file and the Data and
Saves directories respectively). Persistent storage for the app is primarily
provided through the settings singleton (however the modInfos singleton also
has its own data store)."""

# Imports ---------------------------------------------------------------------
#--Localization
#..Handled by bosh, so import that.
import bush
import bosh
import bolt
import bapi
import barb
import bass
import bweb

from bosh import formatInteger,formatDate
from bolt import BoltError, AbstractError, ArgumentError, StateError, UncodedError, CancelError
from bolt import LString, GPath, SubProgress, deprint, delist, sio
from cint import *
startupinfo = bolt.startupinfo

#--Python
import ConfigParser
import StringIO
import copy
import datetime
import os
import re
import shutil
import string
import struct
import sys
import textwrap
import time
import subprocess
import locale
import multiprocessing
from types import *
from operator import attrgetter,itemgetter

#--wxPython
import wx
import wx.gizmos
from wx.lib.mixins.listctrl import ListCtrlAutoWidthMixin

import wx.stc as stc
import keywordWIZBAIN  # Keywords for BAIN Wizard stc
import keywordWIZBAIN2 # Keywords2 for BAIN Wizard stc
from wx.lib.gestures import MouseGestures
import wx.lib.dialogs
# Font Stuff - defaults, etc
if wx.Platform == '__WXMSW__':
    # For Windows OS
    faces = {
            'times': 'Times New Roman',
            'mono' : 'Courier New',
            'helv' : 'Arial',
            'other': 'Comic Sans MS',
            'size' : 10,
            'size2': 8,
            }
elif wx.Platform == '__WXMAC__':
    # For Macintosh Apple OS
    faces = {
            'times': 'Times New Roman',
            'mono' : 'Monaco',
            'helv' : 'Arial',
            'other': 'Comic Sans MS',
            'size' : 10,
            'size2': 8,
            }
else:
    # For Whatever else OS
    faces = {
            'times': 'serif',       # 'times': 'Times',
            'mono' : 'monospace',   # 'mono' : 'Courier',
            'helv' : 'monospace',   # 'helv' : 'Helvetica',
            'other': 'sans',        # 'other': 'new century schoolbook',
            'size' : 10,
            'size2': 8,
             }

#--Balt
import balt
from balt import tooltip, fill, bell
from balt import bitmapButton, button, toggleButton, checkBox, staticText, spinCtrl, textCtrl
from balt import leftSash, topSash
from balt import spacer, hSizer, vSizer, hsbSizer, vsbSizer
from balt import colors, images, Image
from balt import Links, Link, SeparatorLink, MenuLink
from balt import ListCtrl

# BAIN wizard support, requires PyWin32, so import will fail if it's not installed
try:
    import belt
    bEnableWizard = True
except ImportError:
    bEnableWizard = False
    deprint(_(u"Error initializing installer wizards:"),traceback=True)

#  - Make sure that python root directory is in PATH, so can access dll's.
if sys.prefix not in set(os.environ['PATH'].split(';')):
    os.environ['PATH'] += ';'+sys.prefix

appRestart = False # restart Bash if true

# Singletons ------------------------------------------------------------------
statusBar = None
modList = None
iniList = None
modDetails = None
saveList = None
saveDetails = None
screensList = None
gInstallers = None
gMessageList = None
bashFrame = None
docBrowser = None
modChecker = None
SettingsMenu = None
obseButton = None
laaButton = None

# Settings --------------------------------------------------------------------
settings = None

# Color Descriptions ----------------------------------------------------------
colorInfo = {
    'default.text': (_(u'Default Text'),
                     _(u'This is the text color used for list items when no other is specified.  For example, an ESP that is not mergeable or ghosted, and has no other problems.'),
                     ),
    'default.bkgd': (_(u'Default Background'),
                     _(u'This is the text background color used for list items when no other is specified.  For example, an ESM that is not ghosted.'),
                     ),
    'mods.text.esm': (_(u'ESM'),
                      _(u'Tabs: Mods, Saves')
                      + u'\n\n' +
                      _(u'This is the text color used for ESMs in the Mods Tab, and in the Masters info on both the Mods Tab and Saves Tab.'),
                      ),
    'mods.text.mergeable': (_(u'Mergeable Plugin'),
                            _(u'Tabs: Mods')
                            + u'\n\n' +
                            _(u'This is the text color used for mergeable plugins.'),
                            ),
    'mods.text.noMerge': (_(u"'NoMerge' Plugin"),
                          _(u'Tabs: Mods')
                          + u'\n\n' +
                          _(u"This is the text color used for a mergeable plugin that is tagged 'NoMerge'."),
                          ),
    'mods.bkgd.doubleTime.exists': (_(u'Inactive Time Conflict'),
                                    _(u'Tabs: Mods')
                                    + u'\n\n' +
                                    _(u'This is the background color used for a plugin with an inactive time conflict.  This means that two or more plugins have the same timestamp, but only one (or none) of them is active.'),
                                    ),
    'mods.bkgd.doubleTime.load': (_(u'Active Time Conflict'),
                                  _(u'Tabs: Mods')
                                  + u'\n\n' +
                                  _(u'This is the background color used for a plugin with an active time conflict.  This means that two or more plugins with the same timestamp are active.'),
                                  ),
    'mods.bkgd.deactivate': (_(u"'Deactivate' Plugin"),
                             _(u'Tabs: Mods')
                             + u'\n\n' +
                             _(u"This is the background color used for an active plugin that is tagged 'Deactivate'."),
                             ),
    'mods.bkgd.exOverload': (_(u'Exclusion Group Overloaded'),
                             _(u'Tabs: Mods')
                             + u'\n\n' +
                             _(u'This is the background color used for an active plugin in an overloaded Exclusion Group.  This means that two or more plugins in an Exclusion Group are active, where an Exclusion Group is any group of mods that start with the same name, followed by a comma.')
                             + u'\n\n' +
                             _(u'An example exclusion group:')
                             + u'\n' +
                             _(u'Bashed Patch, 0.esp')
                             + u'\n' +
                             _(u'Bashed Patch, 1.esp')
                             + u'\n\n' +
                             _(u'Both of the above plugins belong to the "Bashed Patch," Exclusion Group.'),
                             ),
    'mods.bkgd.ghosted': (_(u'Ghosted Plugin'),
                          _(u'Tabs: Mods')
                          + u'\n\n' +
                          _(u'This is the background color used for a ghosted plugin.'),
                          ),
    'mods.bkgd.groupHeader': (_(u'Group Header'),
                              _(u'Tabs: Mods')
                              + u'\n\n' +
                              _(u'This is the background color used for a Group marker.'),
                              ),
    'ini.bkgd.invalid': (_(u'Invalid INI Tweak'),
                         _(u'Tabs: INI Edits')
                         + u'\n\n' +
                         _(u'This is the background color used for a tweak file that is invalid for the currently selected target INI.'),
                         ),
    'tweak.bkgd.invalid': (_(u'Invalid Tweak Line'),
                           _(u'Tabs: INI Edits')
                           + u'\n\n' +
                           _(u'This is the background color used for a line in a tweak file that is invalid for the currently selected target INI.'),
                           ),
    'tweak.bkgd.mismatched': (_(u'Mismatched Tweak Line'),
                              _(u'Tabs: INI Edits')
                              + u'\n\n' +
                              _(u'This is the background color used for a line in a tweak file that does not match what is set in the target INI.'),
                              ),
    'tweak.bkgd.matched': (_(u'Matched Tweak Line'),
                           _(u'Tabs: INI Edits')
                           + u'\n\n' +
                           _(u'This is the background color used for a line in a tweak file that matches what is set in the target INI.'),
                           ),
    'installers.text.complex': (_(u'Complex Installer'),
                                _(u'Tabs: Installers')
                                + u'\n\n' +
                                _(u'This is the text color used for a complex BAIN package.'),
                                ),
    'installers.text.invalid': (_(u'Marker'),
                                _(u'Tabs: Installers')
                                + u'\n\n' +
                                _(u'This is the text color used for Markers.'),
                                ),
    'installers.bkgd.skipped': (_(u'Skipped Files'),
                                _(u'Tabs: Installers')
                                + u'\n\n' +
                                _(u'This is the background color used for a package with files that will not be installed by BAIN.  This means some files are selected to be installed, but due to your current Skip settings (for example, Skip DistantLOD), will not be installed.'),
                                ),
    'installers.bkgd.outOfOrder': (_(u'Installer Out of Order'),
                                   _(u'Tabs: Installers')
                                   + u'\n\n' +
                                   _(u'This is the background color used for an installer with files installed, that should be overridden by a package with a higher install order.  It can be repaired with an Anneal or Anneal All.'),
                                   ),
    'installers.bkgd.dirty': (_(u'Dirty Installer'),
                              _(u'Tabs: Installers')
                              + u'\n\n' +
                              _(u'This is the background color used for an installer that is configured in a "dirty" manner.  This means changes have been made to its configuration, and an Anneal or Install needs to be performed to make the install match what is configured.'),
                              ),
    'screens.bkgd.image': (_(u'Screenshot Background'),
                           _(u'Tabs: Saves, Screens')
                           + u'\n\n' +
                           _(u'This is the background color used for images.'),
                           ),
    }

#--Information about the various Tabs
tabInfo = {
    # InternalName: [className, title, instance]
    'Installers': ['InstallersPanel', _(u"Installers"), None],
    'Mods': ['ModPanel', _(u"Mods"), None],
    'Saves': ['SavePanel', _(u"Saves"), None],
    'INI Edits': ['INIPanel', _(u"INI Edits"), None],
    'Screenshots': ['ScreensPanel', _(u"Screenshots"), None],
    'PM Archive':['MessagePanel', _(u"PM Archive"), None],
    'People':['PeoplePanel', _(u"People"), None],
    }

#--Load config/defaults
settingDefaults = {
    #--Basics
    'bash.version': 0,
    'bash.readme': (0,u'0'),
    'bash.CBashEnabled': True,
    'bash.backupPath': None,
    'bash.framePos': (-1,-1),
    'bash.frameSize': (1024,600),
    'bash.frameSize.min': (400,600),
    'bash.frameMax': False, # True if maximized
    'bash.page':1,
    'bash.useAltName':True,
    'bash.pluginEncoding': 'cp1252',    # Western European
    #--Auto-Update information
    'bash.update.frequency': False, # Don't check for updates
    'bash.update.last': 0,
    'bash.update.defs': set(),      # List of Game Definitions installed
    'bash.update.lang': set(),      # List of Language updates installed
    'bash.update.dontAsk': False,   # If True, Wrye Bash won't ask to download updates, just to install
    'bash.update.backupSFX': True,  # Make the backup file an SFX archive
    #--Colors
    'bash.colors': {
        #--Common Colors
        'default.text':                 'BLACK',
        'default.bkgd':                 'WHITE',
        #--Mods Tab
        'mods.text.esm':                'BLUE',
        'mods.text.mergeable':          (0x00, 0x99, 0x00),
        'mods.text.noMerge':            (0x99, 0x00, 0x99),
        'mods.bkgd.doubleTime.exists':  (0xFF, 0xDC, 0xDC),
        'mods.bkgd.doubleTime.load':    (0xFF, 0x64, 0x64),
        'mods.bkgd.deactivate':         (0xFF, 0x64, 0x64),
        'mods.bkgd.exOverload':         (0xFF, 0x99, 0x00),
        'mods.bkgd.ghosted':            (0xE8, 0xE8, 0xE8),
        'mods.bkgd.groupHeader':        (0xD8, 0xD8, 0xD8),
        #--INI Edits Tab
        'ini.bkgd.invalid':             (0xDF, 0xDF, 0xDF),
        'tweak.bkgd.invalid':           (0xFF, 0xD5, 0xAA),
        'tweak.bkgd.mismatched':        (0xFF, 0xFF, 0xBF),
        'tweak.bkgd.matched':           (0xC1, 0xFF, 0xC1),
        #--Installers Tab
        'installers.text.complex':      'NAVY',
        'installers.text.invalid':      'GREY',
        'installers.bkgd.skipped':      (0xE0, 0xE0, 0xE0),
        'installers.bkgd.outOfOrder':   (0xFF, 0xFF, 0x00),
        'installers.bkgd.dirty':        (0xFF, 0xBB, 0x33),
        #--Screens Tab
        'screens.bkgd.image':           (0x64, 0x64, 0x64),
        },
    #--BSA Redirection
    'bash.bsaRedirection':True,
    #--Wrye Bash: Load Lists
    'bash.loadLists.data': {},
    #--Wrye Bash: Tabs
    'bash.tabs': {
        'Installers': True,
        'Mods': True,
        'Saves': True,
        'INI Edits': True,
        'Screenshots': True,
        'PM Archive': False,
        'People': False,
        },
    'bash.tabs.order': [
        'Installers',
        'Mods',
        'Saves',
        'INI Edits',
        'Screenshots',
        'PM Archive',
        'People',
        ],
    #--Wrye Bash: StatusBar
    'bash.statusbar.iconSize': 16,
    'bash.statusbar.hide': set(),
    'bash.statusbar.order': [],
    'bash.statusbar.showversion': False,
    #--Wrye Bash: Statistics
    'bash.fileStats.cols': ['Type','Count','Size'],
    'bash.fileStats.sort': 'Type',
    'bash.fileStats.colReverse': {
        'Count':1,
        'Size':1,
        },
    'bash.fileStats.colWidths': {
        'Type':50,
        'Count':50,
        'Size':75,
        },
    'bash.fileStats.colAligns': {
        'Count':1,
        'Size':1,
        },
    #--Wrye Bash: Group and Rating
    'bash.mods.autoGhost':False,
    'bash.mods.groups': [x[0] for x in bush.baloGroups],
    'bash.mods.ratings': ['+','1','2','3','4','5','=','~'],
    'bash.balo.autoGroup': True,
    'bash.balo.full': False,
    #--Wrye Bash: Col (Sort) Names
    'bash.colNames': {
        'Mod Status': _(u'Mod Status'),
        'Author': _(u'Author'),
        'Cell': _(u'Cell'),
        'CRC':_(u'CRC'),
        'Current Order': _(u'Current LO'),
        'Date': _(u'Date'),
        'Day': _(u'Day'),
        'File': _(u'File'),
        'Files': _(u'Files'),
        'Group': _(u'Group'),
        'Header': _(u'Header'),
        'Installer':_(u'Installer'),
        'Karma': _(u'Karma'),
        'Load Order': _(u'Load Order'),
        'Modified': _(u'Modified'),
        'Name': _(u'Name'),
        'Num': _(u'MI'),
        'Order': _(u'Order'),
        'Package': _(u'Package'),
        'PlayTime':_(u'Hours'),
        'Player': _(u'Player'),
        'Rating': _(u'Rating'),
        'Save Order': _(u'Save Order'),
        'Size': _(u'Size'),
        'Status': _(u'Status'),
        'Subject': _(u'Subject'),
        },
    #--Wrye Bash: Masters
    'bash.masters.cols': ['File','Num', 'Current Order'],
    'bash.masters.esmsFirst': 1,
    'bash.masters.selectedFirst': 0,
    'bash.masters.sort': 'Num',
    'bash.masters.colReverse': {},
    'bash.masters.colWidths': {
        'File':80,
        'Num':30,
        'Current Order':60,
        },
    'bash.masters.colAligns': {
        'Save Order':1,
        },
    #--Wrye Bash: Mod Docs
    'bash.modDocs.show': False,
    'bash.modDocs.size': (300,400),
    'bash.modDocs.pos': wx.DefaultPosition,
    'bash.modDocs.dir': None,
    #--Installers
    'bash.installers.cols': ['Package','Order','Modified','Size','Files'],
    'bash.installers.colReverse': {},
    'bash.installers.sort': 'Order',
    'bash.installers.colWidths': {
        'Package':230,
        'Order':25,
        'Modified':135,
        'Size':75,
        'Files':55,
        },
    'bash.installers.colAligns': {
        'Order': 1,
        'Modified': 1,
        'Size': 1,
        'Files': 1,
        },
    'bash.installers.page':0,
    'bash.installers.enabled': True,
    'bash.installers.autoAnneal': True,
    'bash.installers.autoWizard':True,
    'bash.installers.wizardOverlay':True,
    'bash.installers.fastStart': True,
    'bash.installers.autoRefreshBethsoft': False,
    'bash.installers.autoRefreshProjects': True,
    'bash.installers.autoApplyEmbeddedBCFs': True,
    'bash.installers.removeEmptyDirs':True,
    'bash.installers.skipScreenshots':False,
    'bash.installers.skipImages':False,
    'bash.installers.skipDocs':False,
    'bash.installers.skipDistantLOD':False,
    'bash.installers.skipLandscapeLODMeshes':False,
    'bash.installers.skipLandscapeLODTextures':False,
    'bash.installers.skipLandscapeLODNormals':False,
    'bash.installers.allowOBSEPlugins':True,
    'bash.installers.renameStrings':True,
    'bash.installers.sortProjects':False,
    'bash.installers.sortActive':False,
    'bash.installers.sortStructure':False,
    'bash.installers.conflictsReport.showLower':True,
    'bash.installers.conflictsReport.showInactive':False,
    'bash.installers.goodDlls':{},
    'bash.installers.badDlls':{},
    'bash.installers.onDropFiles.action':None,
    'bash.installers.commentsSplitterSashPos':0,
    #--Wrye Bash: Wizards
    'bash.wizard.size': (600,500),
    'bash.wizard.pos': wx.DefaultPosition,
    #--Wrye Bash: INI Tweaks
    'bash.ini.cols': ['File','Installer'],
    'bash.ini.sort': 'File',
    'bash.ini.colReverse': {},
    'bash.ini.sortValid': True,
    'bash.ini.colWidths': {
        'File':300,
        'Installer':100,
        },
    'bash.ini.colAligns': {},
    'bash.ini.choices': {},
    'bash.ini.choice': 0,
    'bash.ini.allowNewLines': bush.game.ini.allowNewLines,
    #--Wrye Bash: Mods
    'bash.mods.cols': ['File','Load Order','Rating','Group','Installer','Modified','Size','Author','CRC', 'Mod Status'],
    'bash.mods.esmsFirst': 1,
    'bash.mods.selectedFirst': 0,
    'bash.mods.sort': 'Load Order',
    'bash.mods.colReverse': {},
    'bash.mods.colWidths': {
        'Author':100,
        'File':200,
        'Group':10,
        'Installer':100,
        'Load Order':25,
        'Modified':135,
        'Rating':10,
        'Size':75,
        'CRC':60,
        'Mod Status':50,
        },
    'bash.mods.colAligns': {
        'Size':1,
        'Load Order':1,
        },
    'bash.mods.renames': {},
    'bash.mods.scanDirty': False,
    'bash.mods.export.skip': u'',
    'bash.mods.export.deprefix': u'',
    'bash.mods.export.skipcomments': False,
    #--Wrye Bash: Saves
    'bash.saves.cols': ['File','Modified','Size','PlayTime','Player','Cell'],
    'bash.saves.sort': 'Modified',
    'bash.saves.colReverse': {
        'Modified':1,
        },
    'bash.saves.colWidths': {
        'File':375,
        'Modified':135,
        'Size':65,
        'PlayTime':50,
        'Player':70,
        'Cell':80,
        },
    'bash.saves.colAligns': {
        'Size':1,
        'PlayTime':1,
        },
    #Wrye Bash: BSAs
    'bash.BSAs.cols': ['File','Modified','Size'],
    'bash.BSAs.colAligns': {
        'Size':1,
        'Modified':1,
        },
    'bash.BSAs.colReverse': {
        'Modified':1,
        },
    'bash.BSAs.colWidths': {
        'File':150,
        'Modified':150,
        'Size':75,
        },
    'bash.BSAs.sort': 'File',
    #--Wrye Bash: Screens
    'bash.screens.cols': ['File'],
    'bash.screens.sort': 'File',
    'bash.screens.colReverse': {
        'Modified':1,
        },
    'bash.screens.colWidths': {
        'File':100,
        'Modified':150,
        'Size':75,
        },
    'bash.screens.colAligns': {},
    'bash.screens.jpgQuality': 95,
    'bash.screens.jpgCustomQuality': 75,
    #--Wrye Bash: Messages
    'bash.messages.cols': ['Subject','Author','Date'],
    'bash.messages.sort': 'Date',
    'bash.messages.colReverse': {
        },
    'bash.messages.colWidths': {
        'Subject':250,
        'Author':100,
        'Date':150,
        },
    'bash.messages.colAligns': {},
    #--Wrye Bash: People
    'bash.people.cols': ['Name','Karma','Header'],
    'bash.people.sort': 'Name',
    'bash.people.colReverse': {},
    'bash.people.colWidths': {
        'Name': 80,
        'Karma': 25,
        'Header': 50,
        },
    'bash.people.colAligns': {
        'Karma': 1,
        },
    #--Tes4View/Edit/Trans
    'tes4View.iKnowWhatImDoing':False,
    #--BOSS:
    'BOSS.ClearLockTimes':True,
    'BOSS.AlwaysUpdate':True,
    }

# Exceptions ------------------------------------------------------------------
class BashError(BoltError): pass

# Gui Ids ---------------------------------------------------------------------
#------------------------------------------------------------------------------
# Constants
#--Indexed
wxListAligns = [wx.LIST_FORMAT_LEFT, wx.LIST_FORMAT_RIGHT, wx.LIST_FORMAT_CENTRE]
splitterStyle = wx.NO_BORDER|wx.SP_LIVE_UPDATE|wx.FULL_REPAINT_ON_RESIZE

#--Generic
ID_RENAME = 6000
ID_SET    = 6001
ID_SELECT = 6002
ID_BROWSER = 6003
#ID_NOTES  = 6004
ID_EDIT   = 6005
ID_BACK   = 6006
ID_NEXT   = 6007

#--File Menu
ID_REVERT_BACKUP = 6100
ID_REVERT_FIRST  = 6101
ID_BACKUP_NOW    = 6102

#--Label Menus
ID_LOADERS   = balt.IdList(10000, 90,'SAVE','EDIT','NONE','ALL')
ID_GROUPS    = balt.IdList(10100,290,'EDIT','NONE')
ID_RATINGS   = balt.IdList(10400, 90,'EDIT','NONE')
ID_PROFILES  = balt.IdList(10500, 90,'EDIT','DEFAULT')
ID_PROFILES2 = balt.IdList(10700, 90,'EDIT','DEFAULT') #Needed for Save_Move()
ID_TAGS      = balt.IdList(10600, 90,'AUTO','COPY')

# Images ----------------------------------------------------------------------
#------------------------------------------------------------------------------
class ColorChecks(balt.ImageList):
    """ColorChecks ImageList. Used by several List classes."""
    def __init__(self):
        balt.ImageList.__init__(self,16,16)
        for state in (u'on',u'off',u'inc',u'imp'):
            for status in (u'purple',u'blue',u'green',u'orange',u'yellow',u'red'):
                shortKey = status+u'.'+state
                imageKey = u'checkbox.'+shortKey
                file = GPath(bosh.dirs['images'].join(u'checkbox_'+status+u'_'+state+u'.png'))
                image = images[imageKey] = Image(file,wx.BITMAP_TYPE_PNG)
                self.Add(image,shortKey)

    def Get(self,status,on):
        self.GetImageList()
        if on == 3:
            if status <= -20: shortKey = 'purple.imp'
            elif status <= -10: shortKey = 'blue.imp'
            elif status <= 0: shortKey = 'green.imp'
            elif status <=10: shortKey = 'yellow.imp'
            elif status <=20: shortKey = 'orange.imp'
            else: shortKey = 'red.imp'
        elif on == 2:
            if status <= -20: shortKey = 'purple.inc'
            elif status <= -10: shortKey = 'blue.inc'
            elif status <= 0: shortKey = 'green.inc'
            elif status <=10: shortKey = 'yellow.inc'
            elif status <=20: shortKey = 'orange.inc'
            else: shortKey = 'red.inc'
        elif on:
            if status <= -20: shortKey = 'purple.on'
            elif status <= -10: shortKey = 'blue.on'
            elif status <= 0: shortKey = 'green.on'
            elif status <=10: shortKey = 'yellow.on'
            elif status <=20: shortKey = 'orange.on'
            else: shortKey = 'red.on'
        else:
            if status <= -20: shortKey = 'purple.off'
            elif status <= -10: shortKey = 'blue.off'
            elif status == 0: shortKey = 'green.off'
            elif status <=10: shortKey = 'yellow.off'
            elif status <=20: shortKey = 'orange.off'
            else: shortKey = 'red.off'
        return self.indices[shortKey]

#--Image lists
colorChecks = ColorChecks()
karmacons = balt.ImageList(16,16)
karmacons.data.extend({
    'karma+5': Image(GPath(bosh.dirs['images'].join(u'checkbox_purple_inc.png')),wx.BITMAP_TYPE_PNG),
    'karma+4': Image(GPath(bosh.dirs['images'].join(u'checkbox_blue_inc.png')),wx.BITMAP_TYPE_PNG),
    'karma+3': Image(GPath(bosh.dirs['images'].join(u'checkbox_blue_inc.png')),wx.BITMAP_TYPE_PNG),
    'karma+2': Image(GPath(bosh.dirs['images'].join(u'checkbox_green_inc.png')),wx.BITMAP_TYPE_PNG),
    'karma+1': Image(GPath(bosh.dirs['images'].join(u'checkbox_green_inc.png')),wx.BITMAP_TYPE_PNG),
    'karma+0': Image(GPath(bosh.dirs['images'].join(u'checkbox_white_off.png')),wx.BITMAP_TYPE_PNG),
    'karma-1': Image(GPath(bosh.dirs['images'].join(u'checkbox_yellow_off.png')),wx.BITMAP_TYPE_PNG),
    'karma-2': Image(GPath(bosh.dirs['images'].join(u'checkbox_yellow_off.png')),wx.BITMAP_TYPE_PNG),
    'karma-3': Image(GPath(bosh.dirs['images'].join(u'checkbox_orange_off.png')),wx.BITMAP_TYPE_PNG),
    'karma-4': Image(GPath(bosh.dirs['images'].join(u'checkbox_orange_off.png')),wx.BITMAP_TYPE_PNG),
    'karma-5': Image(GPath(bosh.dirs['images'].join(u'checkbox_red_off.png')),wx.BITMAP_TYPE_PNG),
    }.items())
installercons = balt.ImageList(16,16)
installercons.data.extend({
    #--Off/Archive
    'off.green':  Image(GPath(bosh.dirs['images'].join(u'checkbox_green_off.png')),wx.BITMAP_TYPE_PNG),
    'off.grey':   Image(GPath(bosh.dirs['images'].join(u'checkbox_grey_off.png')),wx.BITMAP_TYPE_PNG),
    'off.red':    Image(GPath(bosh.dirs['images'].join(u'checkbox_red_off.png')),wx.BITMAP_TYPE_PNG),
    'off.white':  Image(GPath(bosh.dirs['images'].join(u'checkbox_white_off.png')),wx.BITMAP_TYPE_PNG),
    'off.orange': Image(GPath(bosh.dirs['images'].join(u'checkbox_orange_off.png')),wx.BITMAP_TYPE_PNG),
    'off.yellow': Image(GPath(bosh.dirs['images'].join(u'checkbox_yellow_off.png')),wx.BITMAP_TYPE_PNG),
    #--Off/Archive - Wizard
    'off.green.wiz':    Image(GPath(bosh.dirs['images'].join(u'checkbox_green_off_wiz.png')),wx.BITMAP_TYPE_PNG),
    #grey
    'off.red.wiz':      Image(GPath(bosh.dirs['images'].join(u'checkbox_red_off_wiz.png')),wx.BITMAP_TYPE_PNG),
    'off.white.wiz':    Image(GPath(bosh.dirs['images'].join(u'checkbox_white_off_wiz.png')),wx.BITMAP_TYPE_PNG),
    'off.orange.wiz':   Image(GPath(bosh.dirs['images'].join(u'checkbox_orange_off_wiz.png')),wx.BITMAP_TYPE_PNG),
    'off.yellow.wiz':   Image(GPath(bosh.dirs['images'].join(u'checkbox_yellow_off_wiz.png')),wx.BITMAP_TYPE_PNG),
    #--On/Archive
    'on.green':  Image(GPath(bosh.dirs['images'].join(u'checkbox_green_inc.png')),wx.BITMAP_TYPE_PNG),
    'on.grey':   Image(GPath(bosh.dirs['images'].join(u'checkbox_grey_inc.png')),wx.BITMAP_TYPE_PNG),
    'on.red':    Image(GPath(bosh.dirs['images'].join(u'checkbox_red_inc.png')),wx.BITMAP_TYPE_PNG),
    'on.white':  Image(GPath(bosh.dirs['images'].join(u'checkbox_white_inc.png')),wx.BITMAP_TYPE_PNG),
    'on.orange': Image(GPath(bosh.dirs['images'].join(u'checkbox_orange_inc.png')),wx.BITMAP_TYPE_PNG),
    'on.yellow': Image(GPath(bosh.dirs['images'].join(u'checkbox_yellow_inc.png')),wx.BITMAP_TYPE_PNG),
    #--On/Archive - Wizard
    'on.green.wiz':  Image(GPath(bosh.dirs['images'].join(u'checkbox_green_inc_wiz.png')),wx.BITMAP_TYPE_PNG),
    #grey
    'on.red.wiz':    Image(GPath(bosh.dirs['images'].join(u'checkbox_red_inc_wiz.png')),wx.BITMAP_TYPE_PNG),
    'on.white.wiz':  Image(GPath(bosh.dirs['images'].join(u'checkbox_white_inc_wiz.png')),wx.BITMAP_TYPE_PNG),
    'on.orange.wiz': Image(GPath(bosh.dirs['images'].join(u'checkbox_orange_inc_wiz.png')),wx.BITMAP_TYPE_PNG),
    'on.yellow.wiz': Image(GPath(bosh.dirs['images'].join(u'checkbox_yellow_inc_wiz.png')),wx.BITMAP_TYPE_PNG),
    #--Off/Directory
    'off.green.dir':  Image(GPath(bosh.dirs['images'].join(u'diamond_green_off.png')),wx.BITMAP_TYPE_PNG),
    'off.grey.dir':   Image(GPath(bosh.dirs['images'].join(u'diamond_grey_off.png')),wx.BITMAP_TYPE_PNG),
    'off.red.dir':    Image(GPath(bosh.dirs['images'].join(u'diamond_red_off.png')),wx.BITMAP_TYPE_PNG),
    'off.white.dir':  Image(GPath(bosh.dirs['images'].join(u'diamond_white_off.png')),wx.BITMAP_TYPE_PNG),
    'off.orange.dir': Image(GPath(bosh.dirs['images'].join(u'diamond_orange_off.png')),wx.BITMAP_TYPE_PNG),
    'off.yellow.dir': Image(GPath(bosh.dirs['images'].join(u'diamond_yellow_off.png')),wx.BITMAP_TYPE_PNG),
    #--Off/Directory - Wizard
    'off.green.dir.wiz':  Image(GPath(bosh.dirs['images'].join(u'diamond_green_off_wiz.png')),wx.BITMAP_TYPE_PNG),
    #grey
    'off.red.dir.wiz':    Image(GPath(bosh.dirs['images'].join(u'diamond_red_off_wiz.png')),wx.BITMAP_TYPE_PNG),
    'off.white.dir.wiz':  Image(GPath(bosh.dirs['images'].join(u'diamond_white_off_wiz.png')),wx.BITMAP_TYPE_PNG),
    'off.orange.dir.wiz': Image(GPath(bosh.dirs['images'].join(u'diamond_orange_off_wiz.png')),wx.BITMAP_TYPE_PNG),
    'off.yellow.dir.wiz': Image(GPath(bosh.dirs['images'].join(u'diamond_yellow_off_wiz.png')),wx.BITMAP_TYPE_PNG),
    #--On/Directory
    'on.green.dir':  Image(GPath(bosh.dirs['images'].join(u'diamond_green_inc.png')),wx.BITMAP_TYPE_PNG),
    'on.grey.dir':   Image(GPath(bosh.dirs['images'].join(u'diamond_grey_inc.png')),wx.BITMAP_TYPE_PNG),
    'on.red.dir':    Image(GPath(bosh.dirs['images'].join(u'diamond_red_inc.png')),wx.BITMAP_TYPE_PNG),
    'on.white.dir':  Image(GPath(bosh.dirs['images'].join(u'diamond_white_inc.png')),wx.BITMAP_TYPE_PNG),
    'on.orange.dir': Image(GPath(bosh.dirs['images'].join(u'diamond_orange_inc.png')),wx.BITMAP_TYPE_PNG),
    'on.yellow.dir': Image(GPath(bosh.dirs['images'].join(u'diamond_yellow_inc.png')),wx.BITMAP_TYPE_PNG),
    #--On/Directory - Wizard
    'on.green.dir.wiz':  Image(GPath(bosh.dirs['images'].join(u'diamond_green_inc_wiz.png')),wx.BITMAP_TYPE_PNG),
    #grey
    'on.red.dir.wiz':    Image(GPath(bosh.dirs['images'].join(u'diamond_red_inc_wiz.png')),wx.BITMAP_TYPE_PNG),
    'on.white.dir.wiz':  Image(GPath(bosh.dirs['images'].join(u'diamond_white_off_wiz.png')),wx.BITMAP_TYPE_PNG),
    'on.orange.dir.wiz': Image(GPath(bosh.dirs['images'].join(u'diamond_orange_inc_wiz.png')),wx.BITMAP_TYPE_PNG),
    'on.yellow.dir.wiz': Image(GPath(bosh.dirs['images'].join(u'diamond_yellow_inc_wiz.png')),wx.BITMAP_TYPE_PNG),
    #--Broken
    'corrupt':   Image(GPath(bosh.dirs['images'].join(u'red_x.png')),wx.BITMAP_TYPE_PNG),
    }.items())

#--Icon Bundles
bashRed = None
bashBlue = None
bashDocBrowser = None
bashMonkey = None

fonts = None
# Windows ---------------------------------------------------------------------
#------------------------------------------------------------------------------
class NotebookPanel(wx.Panel):
    """Parent class for notebook panels."""

    def RefreshUIColors(self):
        """Called to signal that UI color settings have changed."""
        pass

    def SetStatusCount(self):
        """Sets status bar count field."""
        statusBar.SetStatusText(u'',2)

    def OnShow(self):
        """To be called when particular panel is changed to and/or shown for first time.
        Default version does nothing, but derived versions might update data."""
        if bosh.inisettings['AutoSizeListColumns']:
            for i in xrange(self.list.list.GetColumnCount()):
                self.list.list.SetColumnWidth(i, -bosh.inisettings['AutoSizeListColumns'])
        self.SetStatusCount()

    def OnCloseWindow(self):
        """To be called when containing frame is closing. Use for saving data, scrollpos, etc."""
        pass

#------------------------------------------------------------------------------
class SashPanel(NotebookPanel):
    """Subclass of Notebook Panel, designed for two pane panel."""
    def __init__(self,parent,sashPosKey=None,sashGravity=0.5,sashPos=0,mode=wx.VERTICAL,minimumSize=50,style=wx.BORDER_NONE|wx.SP_LIVE_UPDATE|wx.FULL_REPAINT_ON_RESIZE):
        """Initialize."""
        wx.Panel.__init__(self, parent, wx.ID_ANY)
        splitter = wx.gizmos.ThinSplitterWindow(self, wx.ID_ANY, style=style)
        self.left = wx.Panel(splitter)
        self.right = wx.Panel(splitter)
        if mode == wx.VERTICAL:
            splitter.SplitVertically(self.left, self.right)
        else:
            splitter.SplitHorizontally(self.left, self.right)
        splitter.SetSashGravity(sashGravity)
        sashPos = settings.get(sashPosKey, 0) or sashPos or -1
        splitter.SetSashPosition(sashPos)
        if sashPosKey is not None:
            self.sashPosKey = sashPosKey
        splitter.Bind(wx.EVT_SPLITTER_DCLICK, self.OnDClick)
        splitter.SetMinimumPaneSize(minimumSize)
        sizer = vSizer(
            (splitter,1,wx.EXPAND),
            )
        self.SetSizer(sizer)

    def OnDClick(self, event):
        """Don't allow unsplitting"""
        event.Veto()

    def OnCloseWindow(self):
        splitter = self.right.GetParent()
        if hasattr(self, 'sashPosKey'):
            settings[self.sashPosKey] = splitter.GetSashPosition()

class SashTankPanel(NotebookPanel):
    """Subclass of a notebook panel designed for a two pane tank panel."""
    def __init__(self,data,parent):
        """Initialize."""
        wx.Panel.__init__(self, parent,-1)
        self.data = data
        self.detailsItem = None
        sashPos = data.getParam('sashPos',200)
        self.left = leftSash(self,defaultSize=(sashPos,100),onSashDrag=self.OnSashDrag)
        self.right = wx.Panel(self,style=wx.NO_BORDER)
        #--Events
        self.Bind(wx.EVT_SIZE,self.OnSize)

    def OnShow(self):
        """Panel is shown. Update self.data."""
        if self.gList.data.refresh():
            self.gList.RefreshUI()
        if bosh.inisettings['AutoSizeListColumns']:
            for i in xrange(self.gList.gList.GetColumnCount()):
                self.gList.gList.SetColumnWidth(i, -bosh.inisettings['AutoSizeListColumns'])
        self.SetStatusCount()

    def OnSashDrag(self,event):
        """Handle sash moved."""
        wMin,wMax = 80,self.GetSizeTuple()[0]-80
        sashPos = max(wMin,min(wMax,event.GetDragRect().width))
        self.left.SetDefaultSize((sashPos,10))
        wx.LayoutAlgorithm().LayoutWindow(self, self.right)
        self.data.setParam('sashPos',sashPos)

    def OnSize(self,event=None):
        wx.LayoutAlgorithm().LayoutWindow(self, self.right)

    def OnCloseWindow(self):
        """To be called when containing frame is closing. Use for saving data, scrollpos, etc."""
        self.SaveDetails()
        self.data.save()

    def GetDetailsItem(self):
        """Returns item currently being shown in details view."""
        return self.detailsItem

#------------------------------------------------------------------------------
class List(wx.Panel):
    def __init__(self,parent,id=wx.ID_ANY,ctrlStyle=wx.LC_REPORT|wx.LC_SINGLE_SEL,
                 dndFiles=False,dndList=False,dndColumns=[]):
        wx.Panel.__init__(self,parent,id, style=wx.WANTS_CHARS)
        sizer = wx.BoxSizer(wx.VERTICAL)
        self.SetSizer(sizer)
        self.SetSizeHints(-1,50)
        self.dndColumns = dndColumns
        #--ListCtrl
        listId = self.listId = wx.NewId()
        self.list = ListCtrl(self, listId, style=ctrlStyle,
                             dndFiles=dndFiles, dndList=dndList,
                             fnDndAllow=self.dndAllow,
                             fnDropFiles=self.OnDropFiles,
                             fnDropIndexes=self.OnDropIndexes)
        self.checkboxes = colorChecks
        self.mouseItem = None
        self.mouseTexts = {}
        self.mouseTextPrev = u''
        self.vScrollPos = 0
        #--Columns
        self.PopulateColumns()
        #--Items
        self.sortDirty = 0
        self.PopulateItems()
        #--Events
        wx.EVT_SIZE(self, self.OnSize)
        #--Events: Items
        self.hitIcon = 0
        wx.EVT_LEFT_DOWN(self.list,self.OnLeftDown)
        self.list.Bind(wx.EVT_CONTEXT_MENU, self.DoItemMenu)
        #--Events: Columns
        wx.EVT_LIST_COL_CLICK(self, listId, self.DoItemSort)
        wx.EVT_LIST_COL_RIGHT_CLICK(self, listId, self.DoColumnMenu)
        self.checkcol = []
        wx.EVT_LIST_COL_END_DRAG(self,listId, self.OnColumnResize)
        wx.EVT_UPDATE_UI(self, listId, self.onUpdateUI)
        #--Mouse movement
        self.list.Bind(wx.EVT_MOTION,self.OnMouse)
        self.list.Bind(wx.EVT_LEAVE_WINDOW,self.OnMouse)
        self.list.Bind(wx.EVT_SCROLLWIN,self.OnScroll)

    #--New way for self.cols, so PopulateColumns will work with
    #  the optional columns menu
    def _getCols(self):
        if hasattr(self,'colsKey'):
            return settings[self.colsKey]
        else:
            return self._cols
    def _setCols(self,value):
        if hasattr(self,'colsKey'):
            del self.colsKey
        self._cols = value
    cols = property(_getCols,_setCols)

    #--Drag and Drop---------------------------------------
    def dndAllow(self):
        col = self.sort
        return col in self.dndColumns
    def OnDropFiles(self, x, y, filenames): raise AbstractError
    def OnDropIndexes(self, indexes, newPos): raise AbstractError

    #--Items ----------------------------------------------
    #--Populate Columns
    def PopulateColumns(self):
        """Create/name columns in ListCtrl."""
        cols = self.cols
        self.numCols = len(cols)
        colDict = self.colDict = {}
        for colDex in xrange(self.numCols):
            colKey = cols[colDex]
            colDict[colKey] = colDex
            colName = self.colNames.get(colKey,colKey)
            wxListAlign = wxListAligns[self.colAligns.get(colKey,0)]
            if colDex >= self.list.GetColumnCount():
                # Make a new column
                self.list.InsertColumn(colDex,colName,wxListAlign)
                self.list.SetColumnWidth(colDex,self.colWidths.get(colKey,30))
            else:
                # Update an existing column
                column = self.list.GetColumn(colDex)
                if column.GetText() == colName:
                    # Don't change it, just make sure the width is correct
                    self.list.SetColumnWidth(colDex,self.colWidths.get(colKey,30))
                elif column.GetText() not in self.cols:
                    # Column that doesn't exist anymore
                    self.list.DeleteColumn(colDex)
                    colDex -= 1
                else:
                    # New column
                    self.list.InsertColumn(colDex,colName,wxListAlign)
                    self.list.SetColumnWidth(colDex,self.colWidths.get(colKey,30))
        while self.list.GetColumnCount() > self.numCols:
            self.list.DeleteColumn(self.numCols)
        self.list.SetColumnWidth(self.numCols, wx.LIST_AUTOSIZE_USEHEADER)

    def PopulateItem(self,itemDex,mode=0,selected=set()):
        """Populate ListCtrl for specified item. [ABSTRACT]"""
        raise AbstractError

    def GetItems(self):
        """Set and return self.items."""
        self.items = self.data.keys()
        return self.items

    def PopulateItems(self,col=None,reverse=-2,selected='SAME'):
        """Sort items and populate entire list."""
        self.mouseTexts.clear()
        #--Sort Dirty?
        if self.sortDirty:
            self.sortDirty = 0
            (col, reverse) = (None,-1)
        #--Items to select afterwards. (Defaults to current selection.)
        if selected == 'SAME': selected = set(self.GetSelected())
        #--Reget items
        self.GetItems()
        self.SortItems(col,reverse)
        #--Delete Current items
        listItemCount = self.list.GetItemCount()
        #--Populate items
        for itemDex in xrange(len(self.items)):
            mode = int(itemDex >= listItemCount)
            self.PopulateItem(itemDex,mode,selected)
        #--Delete items?
        while self.list.GetItemCount() > len(self.items):
            self.list.DeleteItem(self.list.GetItemCount()-1)

    def ClearSelected(self):
        for itemDex in xrange(self.list.GetItemCount()):
            self.list.SetItemState(itemDex, 0, wx.LIST_STATE_SELECTED)

    def SelectAll(self):
        for itemDex in range(self.list.GetItemCount()):
            self.list.SetItemState(itemDex,wx.LIST_STATE_SELECTED,wx.LIST_STATE_SELECTED)

    def GetSelected(self):
        """Return list of items selected (hilighted) in the interface."""
        #--No items?
        if not 'items' in self.__dict__: return []
        selected = []
        itemDex = -1
        while True:
            itemDex = self.list.GetNextItem(itemDex,
                wx.LIST_NEXT_ALL,wx.LIST_STATE_SELECTED)
            if itemDex == -1 or itemDex >= len(self.items):
                break
            else:
                selected.append(self.items[itemDex])
        return selected

    def DeleteSelected(self):
        """Deletes selected items."""
        items = self.GetSelected()
        if items:
            message = [u'',_(u'Uncheck items to skip deleting them if desired.')]
            message.extend(sorted(items))
            dialog = ListBoxes(self,_(u'Delete Items'),
                         _(u'Delete these items?  This operation cannot be undone.'),
                         [message])
            if dialog.ShowModal() != wx.ID_CANCEL:
                id = dialog.ids[message[0]]
                checks = dialog.FindWindowById(id)
                if checks:
                    for i,mod in enumerate(items):
                        if checks.IsChecked(i):
                            self.data.delete(mod)
                self.RefreshUI()

    def checkUncheckMod(self, *mods):
        removed = []
        for item in mods:
            if item in removed: continue
            oldFiles = bosh.modInfos.ordered[:]
            fileName = GPath(item)
            #--Unselect?
            if self.data.isSelected(fileName):
                self.data.unselect(fileName)
                changed = bolt.listSubtract(oldFiles,bosh.modInfos.ordered)
                if len(changed) > (fileName in changed):
                    changed.remove(fileName)
                    changed = [x.s for x in changed]
                    removed += changed
                    balt.showList(self,u'${count} '+_(u'Children deactivated:'),changed,10,fileName.s)
            #--Select?
            else:
                ## For now, allow selecting unicode named files, for testing
                ## I'll leave the warning in place, but maybe we can get the
                ## game to load these files.s
                #if fileName in self.data.bad_names: return
                try:
                    self.data.select(fileName)
                    changed = bolt.listSubtract(bosh.modInfos.ordered,oldFiles)
                    if len(changed) > ((fileName in changed) + (GPath(u'Oblivion.esm') in changed)):
                        changed.remove(fileName)
                        changed = [x.s for x in changed]
                        balt.showList(self,u'${count} '+_(u'Masters activated:'),changed,10,fileName.s)
                except bosh.PluginsFullError:
                    balt.showError(self,_(u'Unable to add mod %s because load list is full.')
                        % fileName.s)
                    return
        #--Refresh
        bosh.modInfos.refresh()
        self.RefreshUI()
        #--Mark sort as dirty
        if self.selectedFirst:
            self.sortDirty = 1

    def GetSortSettings(self,col,reverse):
        """Return parsed col, reverse arguments. Used by SortSettings.
        col: sort variable.
          Defaults to last sort. (self.sort)
        reverse: sort order
          1: Descending order
          0: Ascending order
         -1: Use current reverse settings for sort variable, unless
             last sort was on same sort variable -- in which case,
             reverse the sort order.
         -2: Use current reverse setting for sort variable.
        """
        #--Sort Column
        if not col:
            col = self.sort
        #--Reverse
        oldReverse = self.colReverse.get(col,0)
        if col == 'Load Order': #--Disallow reverse for load
            reverse = 0
        elif reverse == -1 and col == self.sort:
            reverse = not oldReverse
        elif reverse < 0:
            reverse = oldReverse
        #--Done
        self.sort = col
        self.colReverse[col] = reverse
        return (col,reverse)

    #--Event Handlers -------------------------------------
    def onUpdateUI(self,event):
        if self.checkcol:
            colDex = self.checkcol[0]
            colName = self.cols[colDex]
            width = self.list.GetColumnWidth(colDex)
            if width < 25:
                width = 25
                self.list.SetColumnWidth(colDex, 25)
                self.list.resizeLastColumn(0)
            self.colWidths[colName] = width
            self.checkcol = []
        event.Skip()

    def OnMouse(self,event):
        """Check mouse motion to detect right click event."""
        if event.Moving():
            (mouseItem,mouseHitFlag) = self.list.HitTest(event.GetPosition())
            if mouseItem != self.mouseItem:
                self.mouseItem = mouseItem
                self.MouseEnteredItem(mouseItem)
        elif event.Leaving() and self.mouseItem != None:
            self.mouseItem = None
            self.MouseEnteredItem(None)
        event.Skip()

    def MouseEnteredItem(self,item):
        """Handle mouse entered item by showing tip or similar."""
        text = self.mouseTexts.get(item) or ''
        if text != self.mouseTextPrev:
            statusBar.SetStatusText(text,1)
            self.mouseTextPrev = text

    #--Column Menu
    def DoColumnMenu(self,event,column = None):
        if not self.mainMenu: return
        #--Build Menu
        if column is None: column = event.GetColumn()
        #--Show/Destroy Menu
        self.mainMenu.PopupMenu(self,bashFrame,column)

    #--Column Resize
    def OnColumnResize(self,event):
        """Due to a nastyness that ListCtrl.GetColumnWidth(col) returns
        the old size before this event completes just save what
        column is being edited and process after in OnUpdateUI()"""
        self.checkcol = [event.GetColumn()]
        event.Skip()

    #--Item Sort
    def DoItemSort(self, event):
        self.PopulateItems(self.cols[event.GetColumn()],-1)

    #--Item Menu
    def DoItemMenu(self,event):
        selected = self.GetSelected()
        if not selected:
            self.DoColumnMenu(event,0)
            return
        #--Show/Destroy Menu
        self.itemMenu.PopupMenu(self,bashFrame,selected)

    #--Size Change
    def OnSize(self, event):
        size = self.GetClientSizeTuple()
        #print self,size
        self.list.SetSize(size)

    #--Event: Left Down
    def OnLeftDown(self,event):
        #self.hitTest = self.list.HitTest((event.GetX(),event.GetY()))
        #self.pos[0] = event.GetX()
        #deprint(event.GetX())
        event.Skip()

    def OnScroll(self,event):
        """Event: List was scrolled. Save so can be accessed later."""
        if event.GetOrientation() == wx.VERTICAL:
            self.vScrollPos = event.GetPosition()
        event.Skip()

#------------------------------------------------------------------------------
class MasterList(List):
    mainMenu = Links()
    itemMenu = Links()

    def __init__(self,parent,fileInfo,setEditedFn):
        #--Columns
        self.cols = settings['bash.masters.cols']
        self.colNames = settings['bash.colNames']
        self.colWidths = settings['bash.masters.colWidths']
        self.colAligns = settings['bash.masters.colAligns']
        self.colReverse = settings['bash.masters.colReverse'].copy()
        #--Data/Items
        self.edited = False
        self.fileInfo = fileInfo
        self.prevId = -1
        self.data = {}  #--masterInfo = self.data[item], where item is id number
        self.items = [] #--Item numbers in display order.
        self.fileOrderItems = []
        self.loadOrderNames = []
        self.sort = settings['bash.masters.sort']
        self.esmsFirst = settings['bash.masters.esmsFirst']
        self.selectedFirst = settings['bash.masters.selectedFirst']
        #--Links
        self.mainMenu = MasterList.mainMenu
        self.itemMenu = MasterList.itemMenu
        #--Parent init
        List.__init__(self,parent,wx.ID_ANY,ctrlStyle=(wx.LC_REPORT|wx.LC_SINGLE_SEL|wx.LC_EDIT_LABELS))
        wx.EVT_LIST_END_LABEL_EDIT(self,self.listId,self.OnLabelEdited)
        #--Image List
        checkboxesIL = self.checkboxes.GetImageList()
        self.list.SetImageList(checkboxesIL,wx.IMAGE_LIST_SMALL)
        self._setEditedFn = setEditedFn

    #--NewItemNum
    def newId(self):
        self.prevId += 1
        return self.prevId

    #--Set ModInfo
    def SetFileInfo(self,fileInfo):
        self.ClearSelected()
        self.edited = False
        self.fileInfo = fileInfo
        self.prevId = -1
        self.data.clear()
        del self.items[:]
        del self.fileOrderItems[:]
        #--Null fileInfo?
        if not fileInfo:
            self.PopulateItems()
            return
        #--Fill data and populate
        for masterName in fileInfo.header.masters:
            item = self.newId()
            masterInfo = bosh.MasterInfo(masterName,0)
            self.data[item] = masterInfo
            self.items.append(item)
            self.fileOrderItems.append(item)
        self.ReList()
        self.PopulateItems()

    #--Get Master Status
    def GetMasterStatus(self,item):
        masterInfo = self.data[item]
        masterName = masterInfo.name
        status = masterInfo.getStatus()
        if status == 30:
            return status
        fileOrderIndex = self.fileOrderItems.index(item)
        loadOrderIndex = self.loadOrderNames.index(masterName)
        ordered = bosh.modInfos.ordered
        if fileOrderIndex != loadOrderIndex:
            return 20
        elif status > 0:
            return status
        elif ((fileOrderIndex < len(ordered)) and
            (ordered[fileOrderIndex] == masterName)):
            return -10
        else:
            return status

    #--Get Items
    def GetItems(self):
        return self.items

    #--Populate Item
    def PopulateItem(self,itemDex,mode=0,selected=set()):
        itemId = self.items[itemDex]
        masterInfo = self.data[itemId]
        masterName = masterInfo.name
        cols = self.cols
        for colDex in range(self.numCols):
            #--Value
            col = cols[colDex]
            if col == 'File':
                value = masterName.s
                if masterName == u'Oblivion.esm':
                    voCurrent = bosh.modInfos.voCurrent
                    if voCurrent: value += u' ['+voCurrent+u']'
            elif col == 'Num':
                value = u'%02X' % (self.fileOrderItems.index(itemId),)
            elif col == 'Current Order':
                #print itemId
                if masterName in bosh.modInfos.plugins.LoadOrder:
                    value = u'%02X' % (self.loadOrderNames.index(masterName),)
                else:
                    value = u''
            #--Insert/Set Value
            if mode and (colDex == 0):
                self.list.InsertStringItem(itemDex, value)
            else:
                self.list.SetStringItem(itemDex, colDex, value)
        #--Font color
        item = self.list.GetItem(itemDex)
        if masterInfo.isEsm():
            item.SetTextColour(colors['mods.text.esm'])
        else:
            item.SetTextColour(colors['default.text'])
        #--Text BG
        if bosh.modInfos.isBadFileName(masterName.s):
            if bosh.modInfos.isSelected(masterName):
                item.SetBackgroundColour(colors['mods.bkgd.doubleTime.load'])
            else:
                item.SetBackgroundColour(colors['mods.bkgd.doubleTime.exists'])
        elif masterInfo.hasActiveTimeConflict():
            item.SetBackgroundColour(colors['mods.bkgd.doubleTime.load'])
        elif masterInfo.isExOverLoaded():
            item.SetBackgroundColour(colors['mods.bkgd.exOverload'])
        elif masterInfo.hasTimeConflict():
            item.SetBackgroundColour(colors['mods.bkgd.doubleTime.exists'])
        elif masterInfo.isGhost:
            item.SetBackgroundColour(colors['mods.bkgd.ghosted'])
        else:
            item.SetBackgroundColour(colors['default.bkgd'])
        self.list.SetItem(item)
        #--Image
        status = self.GetMasterStatus(itemId)
        oninc = (masterName in bosh.modInfos.ordered) or (masterName in bosh.modInfos.merged and 2)
        self.list.SetItemImage(itemDex,self.checkboxes.Get(status,oninc))
        #--Selection State
        if masterName in selected:
            self.list.SetItemState(itemDex,wx.LIST_STATE_SELECTED,wx.LIST_STATE_SELECTED)
        else:
            self.list.SetItemState(itemDex,0,wx.LIST_STATE_SELECTED)

    #--Sort Items
    def SortItems(self,col=None,reverse=-2):
        (col, reverse) = self.GetSortSettings(col,reverse)
        #--Sort
        data = self.data
        #--Start with sort by type
        self.items.sort()
        self.items.sort(key=lambda a: data[a].name.cext)
        if col == 'File':
            pass #--Done by default
        elif col == 'Rating':
            self.items.sort(key=lambda a: bosh.modInfos.table.getItem(a,'rating',u''))
        elif col == 'Group':
            self.items.sort(key=lambda a: bosh.modInfos.table.getItem(a,'group',u''))
        elif col == 'Installer':
            self.items.sort(key=lambda a: bosh.modInfos.table.getItem(a,'installer',u''))
        elif col == 'Modified':
            self.items.sort(key=lambda a: data[a].mtime)
        elif col in ['Save Order','Num']:
            self.items.sort()
        elif col in ['Load Order','Current Order']:
            loadOrderNames = self.loadOrderNames
            data = self.data
            self.items.sort(key=lambda a: loadOrderNames.index(data[a].name))
        elif col == 'Status':
            self.items.sort(lambda a,b: cmp(self.GetMasterStatus(a),self.GetMasterStatus(b)))
        elif col == 'Author':
            self.items.sort(lambda a,b: cmp(data[a].author.lower(),data[b].author.lower()))
        else:
            raise BashError(u'Unrecognized sort key: '+col)
        #--Ascending
        if reverse: self.items.reverse()
        #--ESMs First?
        settings['bash.masters.esmsFirst'] = self.esmsFirst
        if self.esmsFirst or col == 'Load Order':
            self.items.sort(key=lambda a:data[a].name.cext)

    #--Relist
    def ReList(self):
        fileOrderNames = [self.data[item].name for item in self.fileOrderItems]
        self.loadOrderNames = bosh.modInfos.getOrdered(fileOrderNames,False)

    #--InitEdit
    def InitEdit(self):
        #--Pre-clean
        for itemId in self.items:
            masterInfo = self.data[itemId]
            #--Missing Master?
            if not masterInfo.modInfo:
                masterName = masterInfo.name
                newName = settings['bash.mods.renames'].get(masterName,None)
                #--Rename?
                if newName and newName in bosh.modInfos:
                    masterInfo.setName(newName)
        #--Done
        self.edited = True
        self.ReList()
        self.PopulateItems()
        self._setEditedFn()

    #--Item Sort
    def DoItemSort(self, event):
        pass #--Don't do column head sort.

    #--Column Menu
    def DoColumnMenu(self,event,column=None):
        if not self.fileInfo: return
        List.DoColumnMenu(self,event,column)

    #--Item Menu
    def DoItemMenu(self,event):
        if not self.edited:
            self.OnLeftDown(event)
        else:
            List.DoItemMenu(self,event)

    #--Column Resize
    def OnColumnResize(self,event):
        super(MasterList,self).OnColumnResize(event)
        settings.setChanged('bash.masters.colWidths')

    #--Event: Left Down
    def OnLeftDown(self,event):
        #--Not edited yet?
        if not self.edited and bush.game.ess.canEditMasters:
            message = (_(u"Edit/update the masters list? Note that the update process may automatically rename some files. Be sure to review the changes before saving."))
            if not balt.askContinue(self,message,'bash.masters.update',_(u'Update Masters')):
                return
            self.InitEdit()
        #--Pass event on (for label editing)
        else:
            event.Skip()

    #--Label Edited
    def OnLabelEdited(self,event):
        itemDex = event.m_itemIndex
        newName = GPath(event.GetText())
        #--No change?
        if newName in bosh.modInfos:
            masterInfo = self.data[self.items[itemDex]]
            oldName = masterInfo.name
            masterInfo.setName(newName)
            self.ReList()
            self.PopulateItem(itemDex)
            settings.getChanged('bash.mods.renames')[masterInfo.oldName] = newName
        elif newName == '':
            event.Veto()
        else:
            balt.showError(self,_(u'File %s does not exist.') % newName.s)
            event.Veto()

    #--GetMasters
    def GetNewMasters(self):
        """Returns new master list."""
        return [self.data[item].name for item in self.fileOrderItems]

#------------------------------------------------------------------------------
class INIList(List):
    mainMenu = Links()  #--Column menu
    itemMenu = Links()  #--Single item menu

    def __init__(self,parent):
        #--Columns
        self.colsKey = 'bash.ini.cols'
        self.colAligns = settings['bash.ini.colAligns']
        self.colNames = settings['bash.colNames']
        self.colReverse = settings.getChanged('bash.ini.colReverse')
        self.colWidths = settings['bash.ini.colWidths']
        self.sortValid = settings['bash.ini.sortValid']
        #--Data/Items
        self.data = bosh.iniInfos
        self.sort = settings['bash.ini.sort']
        #--Links
        self.mainMenu = INIList.mainMenu
        self.itemMenu = INIList.itemMenu
        #--Parent init
        List.__init__(self,parent,wx.ID_ANY,ctrlStyle=wx.LC_REPORT)
        #--Events
        self.list.Bind(wx.EVT_KEY_UP, self.OnKeyUp)
        #--Image List
        checkboxesIL = colorChecks.GetImageList()
        self.list.SetImageList(checkboxesIL,wx.IMAGE_LIST_SMALL)
        #--ScrollPos

    def CountTweakStatus(self):
        """Returns number of each type of tweak, in the
        following format:
        (applied,mismatched,not_applied,invalid)"""
        applied = 0
        mismatch = 0
        not_applied = 0
        invalid = 0
        for tweak in self.data.keys():
            status = self.data[tweak].status
            if status == -10: invalid += 1
            elif status == 0: not_applied += 1
            elif status == 10: mismatch += 1
            elif status == 20: applied += 1
        return (applied,mismatch,not_applied,invalid)

    def ListTweaks(self):
        """Returns text list of tweaks"""
        tweaklist = _(u'Active Ini Tweaks:') + u'\n'
        tweaklist += u'[spoiler][xml]\n'
        tweaks = self.data.keys()
        tweaks.sort()
        for tweak in tweaks:
            if not self.data[tweak].status == 20: continue
            tweaklist+= u'%s\n' % tweak
        tweaklist += u'[/xml][/spoiler]\n'
        return tweaklist

    def RefreshUI(self,files='ALL',detail='SAME'):
        """Refreshes UI for specified files."""
        #--Details
        if detail == 'SAME':
            selected = set(self.GetSelected())
        else:
            selected = set([detail])
        #--Populate
        if files == 'VALID':
            files = [GPath(self.items[x]) for x in xrange(len(self.items)) if self.data[GPath(self.items[x])].status >= 0]
        if files == 'ALL':
            self.PopulateItems(selected=selected)
        elif isinstance(files,bolt.Path):
            self.PopulateItem(files,selected=selected)
        else: #--Iterable
            for file in files:
                self.PopulateItem(file,selected=selected)
        bashFrame.SetStatusCount()

    def PopulateItem(self,itemDex,mode=0,selected=set()):
        #--String name of item?
        if not isinstance(itemDex,int):
            itemDex = self.items.index(itemDex)
        fileName = GPath(self.items[itemDex])
        fileInfo = self.data[fileName]
        cols = self.cols
        for colDex in range(self.numCols):
            col = cols[colDex]
            if col == 'File':
                value = fileName.s
            elif col == 'Installer':
                value = self.data.table.getItem(fileName, 'installer', u'')
            if mode and colDex == 0:
                self.list.InsertStringItem(itemDex, value)
            else:
                self.list.SetStringItem(itemDex, colDex, value)
        status = fileInfo.getStatus()
        #--Image
        checkMark = 0
        icon = 0    # Ok tweak, not applied
        mousetext = u''
        if status == 20:
            # Valid tweak, applied
            checkMark = 1
            mousetext = _(u'Tweak is currently applied.')
        elif status == 15:
            # Valid tweak, some settings applied, others are
            # overwritten by values in another tweak from same installer
            checkMark = 3
            mousetext = _(u'Some settings are applied.  Some are overwritten by another tweak from the same installer.')
        elif status == 10:
            # Ok tweak, some parts are applied, others not
            icon = 10
            checkMark = 3
            mousetext = _(u'Some settings are changed.')
        elif status == -10:
            # Bad tweak
            if not settings['bash.ini.allowNewLines']: icon = 20
            else: icon = 0
            mousetext = _(u'Tweak is invalid')
        self.mouseTexts[itemDex] = mousetext
        self.list.SetItemImage(itemDex,self.checkboxes.Get(icon,checkMark))
        #--Font/BG Color
        item = self.list.GetItem(itemDex)
        item.SetTextColour(colors['default.text'])
        if status < 0:
            item.SetBackgroundColour(colors['ini.bkgd.invalid'])
        else:
            item.SetBackgroundColour(colors['default.bkgd'])
        self.list.SetItem(item)
        if fileName in selected:
            self.list.SetItemState(itemDex,wx.LIST_STATE_SELECTED,wx.LIST_STATE_SELECTED)
        else:
            self.list.SetItemState(itemDex,0,wx.LIST_STATE_SELECTED)

    def SortItems(self,col=None,reverse=-2):
        (col, reverse) = self.GetSortSettings(col,reverse)
        settings['bash.ini.sort'] = col
        data = self.data
        #--Start with sort by name
        self.items.sort()
        self.items.sort(key = attrgetter('cext'))
        if col == 'File':
            pass #--Done by default
        elif col == 'Installer':
            self.items.sort(key=lambda a: bosh.iniInfos.table.getItem(a,'installer',u''))
        else:
            raise BashError(u'Unrecognized sort key: '+col)
        #--Ascending
        if reverse: self.items.reverse()
        #--Valid Tweaks first?
        self.sortValid = settings['bash.ini.sortValid']
        if self.sortValid:
            self.items.sort(key=lambda a: self.data[a].status < 0)

    def OnLeftDown(self,event):
        """Handle click on icon events"""
        event.Skip()
        (hitItem,hitFlag) = self.list.HitTest(event.GetPosition())
        if hitItem < 0 or hitFlag != wx.LIST_HITTEST_ONITEMICON: return
        tweak = bosh.iniInfos[self.items[hitItem]]
        if tweak.status == 20: return # already applied
        #-- If we're applying to Oblivion.ini, show the warning
        iniPanel = self.GetParent().GetParent().GetParent()
        choice = iniPanel.GetChoice().tail
        if choice in bush.game.iniFiles:
            message = (_(u"Apply an ini tweak to %s?") % choice
                       + u'\n\n' +
                       _(u"WARNING: Incorrect tweaks can result in CTDs and even damage to you computer!")
                       )
            if not balt.askContinue(self,message,'bash.iniTweaks.continue',_(u"INI Tweaks")):
                return
        dir = tweak.dir
        #--No point applying a tweak that's already applied
        file = dir.join(self.items[hitItem])
        iniList.data.ini.applyTweakFile(file)
        iniList.RefreshUI('VALID')
        iniPanel.iniContents.RefreshUI()
        iniPanel.tweakContents.RefreshUI(self.data[0])

    def OnKeyUp(self,event):
        """Char event: select all items"""
        ##Ctrl+A
        if event.CmdDown() and event.GetKeyCode() == ord('A'):
            self.SelectAll()
        elif event.GetKeyCode() in (wx.WXK_DELETE,wx.WXK_NUMPAD_DELETE):
            with balt.BusyCursor():
                self.DeleteSelected()
        event.Skip()

    def OnColumnResize(self,event):
        """Column resize: Stored modified column widths."""
        super(INIList,self).OnColumnResize(event)
        settings.setChanged('bash.ini.colWidths')

#------------------------------------------------------------------------------
class INITweakLineCtrl(wx.ListCtrl):
    def __init__(self, parent, iniContents, style=wx.LC_REPORT|wx.LC_SINGLE_SEL|wx.LC_NO_HEADER):
        wx.ListCtrl.__init__(self, parent, wx.ID_ANY, style=style)
        self.Bind(wx.EVT_LIST_ITEM_SELECTED, self.OnSelect)
        self.InsertColumn(0,u'')
        self.tweakLines = []
        self.iniContents = iniContents

    def OnSelect(self, event):
        index = event.GetIndex()
        iniLine = self.tweakLines[index][5]
        self.SetItemState(index, 0, wx.LIST_STATE_SELECTED)
        if iniLine != -1:
            self.iniContents.EnsureVisible(iniLine)
            scroll = iniLine - self.iniContents.GetScrollPos(wx.VERTICAL) - index
            self.iniContents.ScrollLines(scroll)
        event.Skip()

    def RefreshUI(self, tweakPath):
        if tweakPath is None:
            self.DeleteAllItems()
            return
        ini = bosh.iniInfos.ini
        tweakPath = bosh.iniInfos[tweakPath].dir.join(tweakPath)
        self.tweakLines = ini.getTweakFileLines(tweakPath)
        num = self.GetItemCount()
        updated = []
        for i,line in enumerate(self.tweakLines):
            #--Line
            if i >= num:
                self.InsertStringItem(i, line[0])
            else:
                self.SetStringItem(i, 0, line[0])
            #--Line color
            status = line[4]
            if status == -10: color = colors['tweak.bkgd.invalid']
            elif status == 10: color = colors['tweak.bkgd.mismatched']
            elif status == 20: color = colors['tweak.bkgd.matched']
            elif line[6]: color = colors['tweak.bkgd.mismatched']
            else: color = self.GetBackgroundColour()
            self.SetItemBackgroundColour(i, color)
            #--Set iniContents color
            lineNo = line[5]
            if lineNo != -1:
                self.iniContents.SetItemBackgroundColour(lineNo,color)
                updated.append(lineNo)
        #--Delete extra lines
        for i in range(len(self.tweakLines),num):
            self.DeleteItem(len(self.tweakLines))
        #--Reset line color for other iniContents lines
        for i in range(self.iniContents.GetItemCount()):
            if i in updated: continue
            if self.iniContents.GetItemBackgroundColour(i) != self.iniContents.GetBackgroundColour():
                self.iniContents.SetItemBackgroundColour(i, self.iniContents.GetBackgroundColour())
        #--Refresh column width
        self.SetColumnWidth(0,wx.LIST_AUTOSIZE_USEHEADER)

#------------------------------------------------------------------------------
class INILineCtrl(wx.ListCtrl):
    def __init__(self, parent, style=wx.LC_REPORT|wx.LC_SINGLE_SEL|wx.LC_NO_HEADER):
        wx.ListCtrl.__init__(self, parent, wx.ID_ANY, style=style)
        self.Bind(wx.EVT_LIST_ITEM_SELECTED, self.OnSelect)
        self.InsertColumn(0, u'')

    def SetTweakLinesCtrl(self, control):
        self.tweakContents = control

    def OnSelect(self, event):
        index = event.GetIndex()
        self.SetItemState(index, 0, wx.LIST_STATE_SELECTED)
        for i,line in enumerate(self.tweakContents.tweakLines):
            if index == line[5]:
                self.tweakContents.EnsureVisible(i)
                scroll = i - self.tweakContents.GetScrollPos(wx.VERTICAL) - index
                self.tweakContents.ScrollLines(scroll)
                break
        event.Skip()

    def RefreshUI(self,resetScroll=False):
        num = self.GetItemCount()
        if resetScroll:
            self.EnsureVisible(0)
        ini = None
        try:
            with bosh.iniInfos.ini.path.open('r') as ini:
                lines = ini.readlines()
                for i,line in enumerate(lines):
                    if i >= num:
                        self.InsertStringItem(i, line.rstrip())
                    else:
                        self.SetStringItem(i, 0, line.rstrip())
                for i in xrange(len(lines), num):
                    self.DeleteItem(len(lines))
        except IOError:
            balt.showWarning(self, _(u"%s does not exist yet.  %s will create this file on first run.  INI tweaks will not be usable until then.") % (bosh.iniInfos.ini.path, bush.game.iniFiles[0]))
        self.SetColumnWidth(0, wx.LIST_AUTOSIZE_USEHEADER)

#------------------------------------------------------------------------------
class ModList(List):
    #--Class Data
    mainMenu = Links() #--Column menu
    itemMenu = Links() #--Single item menu

    def __init__(self,parent):
        #--Columns
        self.colsKey = 'bash.mods.cols'
        self.colAligns = settings['bash.mods.colAligns']
        self.colNames = settings['bash.colNames']
        self.colReverse = settings.getChanged('bash.mods.colReverse')
        self.colWidths = settings['bash.mods.colWidths']
        #--Data/Items
        self.data = data = bosh.modInfos
        self.details = None #--Set by panel
        self.sort = settings['bash.mods.sort']
        self.esmsFirst = settings['bash.mods.esmsFirst']
        self.selectedFirst = settings['bash.mods.selectedFirst']
        #--Links
        self.mainMenu = ModList.mainMenu
        self.itemMenu = ModList.itemMenu
        #--Parent init
        List.__init__(self,parent,wx.ID_ANY,ctrlStyle=(wx.LC_REPORT), dndList=True, dndColumns=['Load Order'])#|wx.SUNKEN_BORDER))
        #--Image List
        checkboxesIL = colorChecks.GetImageList()
        self.sm_up = checkboxesIL.Add(balt.SmallUpArrow.GetBitmap())
        self.sm_dn = checkboxesIL.Add(balt.SmallDnArrow.GetBitmap())
        self.list.SetImageList(checkboxesIL,wx.IMAGE_LIST_SMALL)
        #--Events
        wx.EVT_LIST_ITEM_SELECTED(self,self.listId,self.OnItemSelected)
        self.list.Bind(wx.EVT_CHAR, self.OnChar)
        self.list.Bind(wx.EVT_LEFT_DCLICK, self.OnDoubleClick)
        self.list.Bind(wx.EVT_KEY_UP, self.OnKeyUp)
        #--ScrollPos
        self.list.ScrollLines(settings.get('bash.mods.scrollPos',0))
        self.vScrollPos = self.list.GetScrollPos(wx.VERTICAL)

    #-- Drag and Drop-----------------------------------------------------
    def OnDropIndexes(self, indexes, newPos):
        # Make sure we're not auto-sorting
        for thisFile in self.GetSelected():
            if GPath(thisFile) in bosh.modInfos.autoSorted:
                balt.showError(self,_(u"Auto-ordered files cannot be manually moved."))
                return
        start = indexes[0]
        stop = indexes[-1] + 1
        oldOrder = bosh.modInfos.plugins.LoadOrder
        # Dummy checks: can't move the game's master file anywhere else but position 0
        if newPos <= 0: return
        master = bosh.modInfos.masterName
        if master in oldOrder[start:stop]: return
        # List of names to move
        toMove = oldOrder[start:stop]
        # oldOrder will only have non-moving plugins now
        del oldOrder[start:stop]
        # create new order
        newOrder = oldOrder[:newPos] + toMove + oldOrder[newPos:]
        #--Save and Refresh
        try:
            bosh.boss.LoadOrder = newOrder
        except bapi.BossError as e:
            if e.code == bapi.BOSS_API_ERROR_INVALID_ARGS:
                #balt.showError(self, u'Cannot load plugins before masters.')
                pass
        bosh.modInfos.plugins.refresh(True)
        bosh.modInfos.refreshInfoLists()
        self.RefreshUI()

    def RefreshUI(self,files='ALL',detail='SAME',refreshSaves=True):
        """Refreshes UI for specified file. Also calls saveList.RefreshUI()!"""
        #--Details
        if detail == 'SAME':
            selected = set(self.GetSelected())
        else:
            selected = set([detail])
        #--Populate
        bosh.modInfos.plugins.refresh()  #CDC is this needed here?
        if files == 'ALL':
            self.PopulateItems(selected=selected)
        elif isinstance(files,bolt.Path):
            self.PopulateItem(files,selected=selected)
        else: #--Iterable
            for file in files:
                if file in bosh.modInfos:
                    self.PopulateItem(file,selected=selected)
        modDetails.SetFile(detail)
        bashFrame.SetStatusCount()
        #--Saves
        if refreshSaves and saveList:
            saveList.RefreshUI()

    #--Populate Item
    def PopulateItem(self,itemDex,mode=0,selected=set()):
        #--String name of item?
        if not isinstance(itemDex,int):
            itemDex = self.items.index(itemDex)
        fileName = GPath(self.items[itemDex])
        fileInfo = self.data[fileName]
        fileBashTags = bosh.modInfos[fileName].getBashTags()
        cols = self.cols
        for colDex in range(self.numCols):
            col = cols[colDex]
            #--Get Value
            if col == 'File':
                value = fileName.s
                if fileName == u'Oblivion.esm' and bosh.modInfos.voCurrent:
                    value += u' ['+bosh.modInfos.voCurrent+u']'
            elif col == 'Rating':
                value = bosh.modInfos.table.getItem(fileName,'rating',u'')
            elif col == 'Group':
                value = bosh.modInfos.table.getItem(fileName,'group',u'')
            elif col == 'Installer':
                value = bosh.modInfos.table.getItem(fileName,'installer',u'')
            elif col == 'Modified':
                value = formatDate(fileInfo.getPath().mtime)
            elif col == 'Size':
                value = formatInteger(fileInfo.size/1024)+u' KB'
            elif col == 'Author' and fileInfo.header:
                value = fileInfo.header.author
            elif col == 'Load Order':
                ordered = bosh.modInfos.ordered
                if fileName in ordered:
                    value = u'%02X' % ordered.index(fileName)
                else:
                    value = u''
            elif col == 'CRC':
                value = u'%08X' % fileInfo.cachedCrc()
            elif col == 'Mod Status':
                value = fileInfo.txt_status()
            else:
                value = u'-'
            #--Insert/SetString
            if mode and (colDex == 0):
                self.list.InsertStringItem(itemDex, value)
            else:
                self.list.SetStringItem(itemDex, colDex, value)
        #--Default message
        mouseText = u''
        #--Image
        status = fileInfo.getStatus()
        checkMark = (
            1 if fileName in bosh.modInfos.ordered
            else 2 if fileName in bosh.modInfos.merged
            else 3 if fileName in bosh.modInfos.imported
            else 0)
        self.list.SetItemImage(itemDex,self.checkboxes.Get(status,checkMark))
        #--Font color
        item = self.list.GetItem(itemDex)
        mouseText = u''
        if fileName in bosh.modInfos.bad_names:
            mouseText += _(u'Plugin name incompatible, cannot be activated.  ')
        if fileName in bosh.modInfos.missing_strings:
            mouseText += _(u'Plugin is missing String Localization files.  ')
        if fileInfo.isEsm():
            item.SetTextColour(colors['mods.text.esm'])
            mouseText += _(u"Master file. ")
        elif fileName in bosh.modInfos.mergeable:
            if u'NoMerge' in fileBashTags:
                item.SetTextColour(colors['mods.text.noMerge'])
                mouseText += _(u"Technically mergeable but has NoMerge tag.  ")
            else:
                item.SetTextColour(colors['mods.text.mergeable'])
                if checkMark == 2:
                    mouseText += _(u"Merged into Bashed Patch.  ")
                else:
                    mouseText += _(u"Can be merged into Bashed Patch.  ")
        else:
            item.SetTextColour(colors['default.text'])
        #--Image messages
        if status == 30:     mouseText += _(u"One or more masters are missing.  ")
        elif status == 20:   mouseText += _(u"Masters have been re-ordered.  ")
        if checkMark == 1:   mouseText += _(u"Active in load list.  ")
        elif checkMark == 3: mouseText += _(u"Imported into Bashed Patch.  ")

        #should mod be deactivated
        if u'Deactivate' in fileBashTags:
            item.SetFont(fonts[2])
        else:
            item.SetFont(fonts[0])
        #--Text BG
        if fileName in bosh.modInfos.bad_names:
            item.SetBackgroundColour(colors['mods.bkgd.doubleTime.exists'])
        elif fileName in bosh.modInfos.missing_strings:
            if fileName in bosh.modInfos.ordered:
                item.SetBackgroundColour(colors['mods.bkgd.doubleTime.load'])
            else:
                item.SetBackgroundColour(colors['mods.bkgd.doubleTime.exists'])
        elif fileInfo.hasBadMasterNames():
            if bosh.modInfos.isSelected(fileName):
                item.SetBackgroundColour(colors['mods.bkgd.doubleTime.load'])
            else:
                item.SetBackgroundColour(colors['mods.bkgd.doubleTime.exists'])
            mouseText += _(u"WARNING: Has master names that will not load.  ")
        elif fileInfo.hasActiveTimeConflict():
            item.SetBackgroundColour(colors['mods.bkgd.doubleTime.load'])
            mouseText += _(u"WARNING: Has same load order as another mod.  ")
        elif u'Deactivate' in fileBashTags and checkMark == 1:
            item.SetBackgroundColour(colors['mods.bkgd.deactivate'])
            mouseText += _(u"Mod should be imported and deactivated.  ")
        elif fileInfo.isExOverLoaded():
            item.SetBackgroundColour(colors['mods.bkgd.exOverload'])
            mouseText += _(u"WARNING: Exclusion group is overloaded.  ")
        elif fileInfo.hasTimeConflict():
            item.SetBackgroundColour(colors['mods.bkgd.doubleTime.exists'])
            mouseText += _(u"Has same time as another (unloaded) mod.  ")
        elif fileName.s[0] in u'.+=':
            item.SetBackgroundColour(colors['mods.bkgd.groupHeader'])
            mouseText += _(u"Group header.  ")
        elif fileInfo.isGhost:
            item.SetBackgroundColour(colors['mods.bkgd.ghosted'])
            mouseText += _(u"File is ghosted.  ")
        else:
            item.SetBackgroundColour(colors['default.bkgd'])
        if settings['bash.mods.scanDirty']:
            message = fileInfo.getDirtyMessage()
            mouseText += message[1]
            if message[0]:
                font = item.GetFont()
                font.SetUnderlined(True)
                item.SetFont(font)
        self.list.SetItem(item)
        self.mouseTexts[itemDex] = mouseText
        #--Selection State
        if fileName in selected:
            self.list.SetItemState(itemDex,wx.LIST_STATE_SELECTED,wx.LIST_STATE_SELECTED)
        else:
            self.list.SetItemState(itemDex,0,wx.LIST_STATE_SELECTED)
        #--Status bar text

    #--Sort Items
    def SortItems(self,col=None,reverse=-2):
        (col, reverse) = self.GetSortSettings(col,reverse)
        oldcol = settings['bash.mods.sort']
        settings['bash.mods.sort'] = col
        selected = bosh.modInfos.ordered
        data = self.data
        #--Start with sort by name
        self.items.sort()
        self.items.sort(key = attrgetter('cext'))
        if col == 'File':
            pass #--Done by default
        elif col == 'Author':
            self.items.sort(key=lambda a: data[a].header.author.lower())
        elif col == 'Rating':
            self.items.sort(key=lambda a: bosh.modInfos.table.getItem(a,'rating',u''))
        elif col == 'Group':
            self.items.sort(key=lambda a: bosh.modInfos.table.getItem(a,'group',u''))
        elif col == 'Installer':
            self.items.sort(key=lambda a: bosh.modInfos.table.getItem(a,'installer',u''))
        elif col == 'Load Order':
            self.items = bosh.modInfos.getOrdered(self.items,False)
        elif col == 'Modified':
            self.items.sort(key=lambda a: data[a].getPath().mtime)
        elif col == 'Size':
            self.items.sort(key=lambda a: data[a].size)
        elif col == 'Status':
            self.items.sort(key=lambda a: data[a].getStatus())
        elif col == 'Mod Status':
            self.items.sort(key=lambda a: data[a].txt_status())
        elif col == 'CRC':
            self.items.sort(key=lambda a: data[a].cachedCrc())
        else:
            raise BashError(u'Unrecognized sort key: '+col)
        #--Ascending
        if reverse: self.items.reverse()
        #--Selected First?
        settings['bash.mods.selectedFirst'] = self.selectedFirst
        if self.selectedFirst:
            active = set(selected) | bosh.modInfos.imported | bosh.modInfos.merged
            self.items.sort(key=lambda x: x not in active)
        #set column sort image
        try:
            try: self.list.ClearColumnImage(self.colDict[oldcol])
            except: pass # if old column no longer is active this will fail but not a problem since it doesn't exist anyways.
            if reverse: self.list.SetColumnImage(self.colDict[col], self.sm_up)
            else: self.list.SetColumnImage(self.colDict[col], self.sm_dn)
        except: pass

    #--Events ---------------------------------------------
    def OnDoubleClick(self,event):
        """Handle doubclick event."""
        (hitItem,hitFlag) = self.list.HitTest(event.GetPosition())
        if hitItem < 0: return
        fileInfo = self.data[self.items[hitItem]]
        if not docBrowser:
            DocBrowser().Show()
            settings['bash.modDocs.show'] = True
        #balt.ensureDisplayed(docBrowser)
        docBrowser.SetMod(fileInfo.name)
        docBrowser.Raise()

    def OnChar(self,event):
        """Char event: Delete, Reorder, Check/Uncheck."""
        ##Delete
        if event.GetKeyCode() in (wx.WXK_DELETE, wx.WXK_NUMPAD_DELETE):
            self.DeleteSelected()
        ##Ctrl+Up and Ctrl+Down
        elif ((event.CmdDown() and event.GetKeyCode() in (wx.WXK_UP,wx.WXK_DOWN,wx.WXK_NUMPAD_UP,wx.WXK_NUMPAD_DOWN)) and
            (settings['bash.mods.sort'] == 'Load Order')
            ):
                for thisFile in self.GetSelected():
                    if GPath(thisFile) in bosh.modInfos.autoSorted:
                        balt.showError(self,_(u"Auto-ordered files cannot be manually moved."))
                        event.Skip()
                        break
                else:
                    orderKey = lambda x: self.items.index(x)
                    moveMod = 1 if event.GetKeyCode() in (wx.WXK_DOWN,wx.WXK_NUMPAD_DOWN) else -1
                    isReversed = (moveMod != -1)
                    for thisFile in sorted(self.GetSelected(),key=orderKey,reverse=isReversed):
                        swapItem = self.items.index(thisFile) + moveMod
                        if swapItem < 0 or len(self.items) - 1 < swapItem: break
                        swapFile = self.items[swapItem]
                        if bosh.modInfos[thisFile].isEsm() != bosh.modInfos[swapFile].isEsm(): break
                        bosh.modInfos.swapOrder(thisFile,swapFile)
                        bosh.modInfos.refreshInfoLists()
                        self.RefreshUI(refreshSaves=False)
                    self.RefreshUI([],refreshSaves=True)
        event.Skip()

    def OnKeyUp(self,event):
        """Char event: Activate selected items, select all items"""
        ##Space
        code = event.GetKeyCode()
        if code == wx.WXK_SPACE:
            selected = self.GetSelected()
            toActivate = [item for item in selected if not self.data.isSelected(GPath(item))]
            if len(toActivate) == 0 or len(toActivate) == len(selected):
                #--Check/Uncheck all
                self.checkUncheckMod(*selected)
            else:
                #--Check all that aren't
                self.checkUncheckMod(*toActivate)
        ##Ctrl+A
        elif event.CmdDown() and code == ord('A'):
            self.SelectAll()
        event.Skip()

    def OnColumnResize(self,event):
        """Column resize: Stored modified column widths."""
        super(ModList,self).OnColumnResize(event)
        settings.setChanged('bash.mods.colWidths')

    def OnLeftDown(self,event):
        """Left Down: Check/uncheck mods."""
        (hitItem,hitFlag) = self.list.HitTest((event.GetX(),event.GetY()))
        if hitFlag == wx.LIST_HITTEST_ONITEMICON:
            self.list.SetDnD(False)
            self.checkUncheckMod(self.items[hitItem])
        else:
            self.list.SetDnD(True)
        #--Pass Event onward
        event.Skip()

    def OnItemSelected(self,event):
        """Item Selected: Set mod details."""
        modName = self.items[event.m_itemIndex]
        self.details.SetFile(modName)
        if docBrowser:
            docBrowser.SetMod(modName)

#------------------------------------------------------------------------------
class ModDetails(SashPanel):
    """Details panel for mod tab."""

    def __init__(self,parent):
        SashPanel.__init__(self, parent,'bash.mods.details.SashPos',1.0,mode=wx.HORIZONTAL,minimumSize=150,style=wx.SW_BORDER|wx.SP_LIVE_UPDATE|wx.FULL_REPAINT_ON_RESIZE)
        top,bottom = self.left, self.right
        #--Singleton
        global modDetails
        modDetails = self
        #--Data
        self.modInfo = None
        self.edited = False
        textWidth = 200
        if True: #setup
            #--Version
            self.version = staticText(top,u'v0.00')
            id = self.fileId = wx.NewId()
            #--File Name
            self.file = textCtrl(top,id)#,size=(textWidth,-1))
            self.file.SetMaxLength(200)
            self.file.Bind(wx.EVT_KILL_FOCUS, self.OnEditFile)
            self.file.Bind(wx.EVT_TEXT, self.OnTextEdit)
            #--Author
            id = self.authorId = wx.NewId()
            self.author = textCtrl(top,id)#,size=(textWidth,-1))
            self.author.SetMaxLength(512)
            wx.EVT_KILL_FOCUS(self.author,self.OnEditAuthor)
            wx.EVT_TEXT(self.author,id,self.OnTextEdit)
            #--Modified
            id = self.modifiedId = wx.NewId()
            self.modified = textCtrl(top,id,size=(textWidth,-1))
            self.modified.SetMaxLength(32)
            wx.EVT_KILL_FOCUS(self.modified,self.OnEditModified)
            wx.EVT_TEXT(self.modified,id,self.OnTextEdit)
            #--Description
            id = self.descriptionId = wx.NewId()
            self.description = (
                wx.TextCtrl(top,id,u'',size=(textWidth,150),style=wx.TE_MULTILINE))
            self.description.SetMaxLength(512)
            wx.EVT_KILL_FOCUS(self.description,self.OnEditDescription)
            wx.EVT_TEXT(self.description,id,self.OnTextEdit)
            subSplitter = self.subSplitter = wx.gizmos.ThinSplitterWindow(bottom)
            masterPanel = wx.Panel(subSplitter)
            tagPanel = wx.Panel(subSplitter)
            #--Masters
            id = self.mastersId = wx.NewId()
            self.masters = MasterList(masterPanel,None,self.SetEdited)
            #--Save/Cancel
            self.save = button(masterPanel,label=_(u'Save'),id=wx.ID_SAVE,onClick=self.DoSave,)
            self.cancel = button(masterPanel,label=_(u'Cancel'),id=wx.ID_CANCEL,onClick=self.DoCancel,)
            self.save.Disable()
            self.cancel.Disable()
            #--Bash tags
            self.allTags = bosh.allTags
            id = self.tagsId = wx.NewId()
            self.gTags = (
                wx.TextCtrl(tagPanel,id,u'',size=(textWidth,100),style=wx.TE_MULTILINE|wx.TE_READONLY))
        #--Layout
        detailsSizer = vSizer(
            (hSizer(
                (staticText(top,_(u"File:")),0,wx.TOP,4),
                spacer,
                (self.version,0,wx.TOP|wx.RIGHT,4)
                ),0,wx.EXPAND),
            (hSizer((self.file,1,wx.EXPAND)),0,wx.EXPAND),
            (hSizer((staticText(top,_(u"Author:")),0,wx.TOP,4)),0,wx.EXPAND),
            (hSizer((self.author,1,wx.EXPAND)),0,wx.EXPAND),
            (hSizer((staticText(top,_(u"Modified:")),0,wx.TOP,4)),0,wx.EXPAND),
            (hSizer((self.modified,1,wx.EXPAND)),0,wx.EXPAND),
            (hSizer((staticText(top,_(u"Description:")),0,wx.TOP,4)),0,wx.EXPAND),
            (hSizer((self.description,1,wx.EXPAND)),1,wx.EXPAND))
        detailsSizer.SetSizeHints(top)
        top.SetSizer(detailsSizer)
        subSplitter.SetMinimumPaneSize(100)
        subSplitter.SplitHorizontally(masterPanel,tagPanel)
        subSplitter.SetSashGravity(0.5)
        subSplitter.SetSashPosition(settings.get('bash.mods.details.subSplitterSashPos', 0))
        mastersSizer = vSizer(
            (hSizer((staticText(masterPanel,_(u"Masters:")),0,wx.TOP,4)),0,wx.EXPAND),
            (hSizer((self.masters,1,wx.EXPAND)),1,wx.EXPAND),
            (hSizer(
                self.save,
                (self.cancel,0,wx.LEFT,4)
                ),0,wx.EXPAND|wx.TOP,4),)
        tagsSizer = vSizer(
            (staticText(tagPanel,_(u"Bash Tags:")),0,wx.TOP,4),
            (hSizer((self.gTags,1,wx.EXPAND)),1,wx.EXPAND))
        mastersSizer.SetSizeHints(masterPanel)
        masterPanel.SetSizer(mastersSizer)
        tagsSizer.SetSizeHints(masterPanel)
        tagPanel.SetSizer(tagsSizer)
        bottom.SetSizer(vSizer((subSplitter,1,wx.EXPAND)))
        #--Events
        self.gTags.Bind(wx.EVT_CONTEXT_MENU,self.ShowBashTagsMenu)
        wx.EVT_MENU(self,ID_TAGS.AUTO,self.DoAutoBashTags)
        wx.EVT_MENU(self,ID_TAGS.COPY,self.DoCopyBashTags)
        wx.EVT_MENU_RANGE(self, ID_TAGS.BASE, ID_TAGS.MAX, self.ToggleBashTag)

    def SetFile(self,fileName='SAME'):
        #--Reset?
        if fileName == 'SAME':
            if not self.modInfo or self.modInfo.name not in bosh.modInfos:
                fileName = None
            else:
                fileName = self.modInfo.name
        #--Empty?
        if not fileName:
            modInfo = self.modInfo = None
            self.fileStr = u''
            self.authorStr = u''
            self.modifiedStr = u''
            self.descriptionStr = u''
            self.versionStr = u'v0.00'
            tagsStr = u''
        #--Valid fileName?
        else:
            modInfo = self.modInfo = bosh.modInfos[fileName]
            #--Remember values for edit checks
            self.fileStr = modInfo.name.s
            self.authorStr = modInfo.header.author
            self.modifiedStr = formatDate(modInfo.mtime)
            self.descriptionStr = modInfo.header.description
            self.versionStr = u'v%0.2f' % modInfo.header.version
            tagsStr = u'\n'.join(sorted(modInfo.getBashTags()))
        #--Editable mtime?
        if fileName in bosh.modInfos.autoSorted:
            self.modified.SetEditable(False)
            self.modified.SetBackgroundColour(self.GetBackgroundColour())
        else:
            self.modified.SetEditable(True)
            self.modified.SetBackgroundColour(self.author.GetBackgroundColour())
        #--Set fields
        self.file.SetValue(self.fileStr)
        self.author.SetValue(self.authorStr)
        self.modified.SetValue(self.modifiedStr)
        self.description.SetValue(self.descriptionStr)
        self.version.SetLabel(self.versionStr)
        self.masters.SetFileInfo(modInfo)
        self.gTags.SetValue(tagsStr)
        if fileName and bosh.modInfos.table.getItem(fileName,'bashTags', None) != None:
            self.gTags.SetBackgroundColour(self.author.GetBackgroundColour())
        else:
            self.gTags.SetBackgroundColour(self.GetBackgroundColour())
        #--Edit State
        self.edited = 0
        self.save.Disable()
        self.cancel.Disable()

    def SetEdited(self):
        self.edited = True
        if bush.game.esp.canEditHeader:
            self.save.Enable()
        self.cancel.Enable()

    def OnTextEdit(self,event):
        if self.modInfo and not self.edited:
            if ((self.fileStr != self.file.GetValue()) or
                (self.authorStr != self.author.GetValue()) or
                (self.modifiedStr != self.modified.GetValue()) or
                (self.descriptionStr != self.description.GetValue()) ):
                self.SetEdited()
        event.Skip()

    def OnEditFile(self,event):
        if not self.modInfo: return
        #--Changed?
        fileStr = self.file.GetValue()
        if fileStr == self.fileStr: return
        #--Extension Changed?
        if fileStr[-4:].lower() != self.fileStr[-4:].lower():
            balt.showError(self,_(u"Incorrect file extension: ")+fileStr[-3:])
            self.file.SetValue(self.fileStr)
        #--Else file exists?
        elif self.modInfo.dir.join(fileStr).exists():
            balt.showError(self,_(u"File %s already exists.") % fileStr)
            self.file.SetValue(self.fileStr)
        #--Okay?
        else:
            self.fileStr = fileStr
            self.SetEdited()

    def OnEditAuthor(self,event):
        if not self.modInfo: return
        authorStr = self.author.GetValue()
        if authorStr != self.authorStr:
            self.authorStr = authorStr
            self.SetEdited()

    def OnEditModified(self,event):
        if not self.modInfo: return
        modifiedStr = self.modified.GetValue()
        if modifiedStr == self.modifiedStr: return
        try:
            newTimeTup = bosh.unformatDate(modifiedStr,u'%c')
            time.mktime(newTimeTup)
        except ValueError:
            balt.showError(self,_(u'Unrecognized date: ')+modifiedStr)
            self.modified.SetValue(self.modifiedStr)
            return
        except OverflowError:
            balt.showError(self,_(u'Bash cannot handle files dates greater than January 19, 2038.)'))
            self.modified.SetValue(self.modifiedStr)
            return
        #--Normalize format
        modifiedStr = time.strftime(u'%c',newTimeTup)
        self.modifiedStr = modifiedStr
        self.modified.SetValue(modifiedStr) #--Normalize format
        self.SetEdited()

    def OnEditDescription(self,event):
        if not self.modInfo: return
        descriptionStr = self.description.GetValue()
        if descriptionStr != self.descriptionStr:
            self.descriptionStr = descriptionStr
            self.SetEdited()

    def DoSave(self,event):
        modInfo = self.modInfo
        #--Change Tests
        changeName = (self.fileStr != modInfo.name)
        changeDate = (self.modifiedStr != formatDate(modInfo.mtime))
        changeHedr = (self.authorStr != modInfo.header.author or
                      self.descriptionStr != modInfo.header.description)
        changeMasters = self.masters.edited
        #--Warn on rename if file has BSA and/or dialog
        hasBsa, hasVoices = modInfo.hasResources()
        if changeName and (hasBsa or hasVoices):
            modName = modInfo.name.s
            if hasBsa and hasVoices:
                message = (_(u'This mod has an associated archive (%s.bsa) and an associated voice directory (Sound\\Voices\\%s), which will become detached when the mod is renamed.')
                           + u'\n\n' +
                           _(u'Note that the BSA archive may also contain a voice directory (Sound\\Voices\\%s), which would remain detached even if the archive name is adjusted.')
                           ) % (modName[:-4],modName,modName)
            elif hasBsa:
                message = (_(u'This mod has an associated archive (%s.bsa), which will become detached when the mod is renamed.')
                           + u'\n\n' +
                           _(u'Note that this BSA archive may contain a voice directory (Sound\\Voices\\%s), which would remain detached even if the archive file name is adjusted.')
                           ) % (modName[:-4],modName)
            else: #hasVoices
                message = _(u'This mod has an associated voice directory (Sound\\Voice\\%s), which will become detached when the mod is renamed.') % modName
            if not balt.askOk(self,message):
                return
        #--Only change date?
        if changeDate and not (changeName or changeHedr or changeMasters):
            newTimeTup = bosh.unformatDate(self.modifiedStr,u'%c')
            newTimeInt = int(time.mktime(newTimeTup))
            modInfo.setmtime(newTimeInt)
            self.SetFile(self.modInfo.name)
            bosh.modInfos.refresh(doInfos=False)
            bosh.modInfos.refreshInfoLists()
            modList.RefreshUI()
            return
        #--Backup
        modInfo.makeBackup()
        #--Change Name?
        fileName = modInfo.name
        if changeName:
            oldName,newName = modInfo.name,GPath(self.fileStr.strip())
            #--Bad name?
            if (bosh.modInfos.isBadFileName(newName.s) and
                not balt.askContinue(self,_(u'File name %s cannot be encoded to ASCII.  %s may not be able to activate this plugin because of this.  Do you want to rename the plugin anyway?')
                                     % (newName.s,bush.game.name),
                                     'bash.rename.isBadFileName')
                ):
                return
            modList.items[modList.items.index(oldName)] = newName
            settings.getChanged('bash.mods.renames')[oldName] = newName
            bosh.modInfos.rename(oldName,newName)
            fileName = newName
        #--Change hedr/masters?
        if changeHedr or changeMasters:
            modInfo.header.author = self.authorStr.strip()
            modInfo.header.description = bolt.winNewLines(self.descriptionStr.strip())
            modInfo.header.masters = self.masters.GetNewMasters()
            modInfo.header.changed = True
            modInfo.writeHeader()
        #--Change date?
        if (changeDate or changeHedr or changeMasters):
            newTimeTup = bosh.unformatDate(self.modifiedStr,u'%c')
            newTimeInt = int(time.mktime(newTimeTup))
            modInfo.setmtime(newTimeInt)
        #--Done
        try:
            #bosh.modInfos.refresh()
            bosh.modInfos.refreshFile(fileName)
            self.SetFile(fileName)
        except bosh.FileError:
            balt.showError(self,_(u'File corrupted on save!'))
            self.SetFile(None)
        if bosh.modInfos.refresh(doInfos=False):
            bosh.modInfos.refreshInfoLists()
        bosh.modInfos.plugins.refresh()  #CDC I don't think this is needed here
        modList.RefreshUI()

    def DoCancel(self,event):
        self.SetFile(self.modInfo.name)

    #--Bash Tags
    def ShowBashTagsMenu(self,event):
        """Show bash tags menu."""
        if not self.modInfo: return
        self.modTags = self.modInfo.getBashTags()
        #--Build menu
        menu = wx.Menu()
        #--Revert to auto
        #--Separator
        isAuto = bosh.modInfos.table.getItem(self.modInfo.name,'bashTags',None) is None
        menuItem = wx.MenuItem(menu,ID_TAGS.AUTO,_(u'Automatic'),kind=wx.ITEM_CHECK,
            help=_(u"Use the tags from the description and masterlist/userlist."))
        menu.AppendItem(menuItem)
        menuItem.Check(isAuto)
        menuItem = wx.MenuItem(menu,ID_TAGS.COPY,_(u'Copy to Description'))
        menu.AppendItem(menuItem)
        menuItem.Enable(not isAuto and self.modTags != self.modInfo.getBashTagsDesc())
        menu.AppendSeparator()
        for id,tag in zip(ID_TAGS,self.allTags):
            menu.AppendCheckItem(id,tag,help=_(u"Add %(tag)s to %(modname)s") % ({'tag':tag,'modname':self.modInfo.name}))
            menu.Check(id,tag in self.modTags)
        self.gTags.PopupMenu(menu)
        menu.Destroy()

    def DoAutoBashTags(self,event):
        """Handle selection of automatic bash tags."""
        modInfo = self.modInfo
        if bosh.modInfos.table.getItem(modInfo.name,'bashTags',None) is None:
            modInfo.setBashTags(modInfo.getBashTags())
        else:
            bosh.modInfos.table.delItem(modInfo.name,'bashTags')
        modList.RefreshUI(self.modInfo.name)

    def DoCopyBashTags(self,event):
        """Handle selection of automatic bash tags."""
        modInfo = self.modInfo
        modInfo.setBashTagsDesc(modInfo.getBashTags())
        modList.RefreshUI(self.modInfo.name)

    def ToggleBashTag(self,event):
        """Toggle bash tag from menu."""
        tag = self.allTags[event.GetId()-ID_TAGS.BASE]
        modTags = self.modTags ^ set((tag,))
        self.modInfo.setBashTags(modTags)
        modList.RefreshUI(self.modInfo.name)

#------------------------------------------------------------------------------
class INIPanel(SashPanel):
    def __init__(self, parent):
        SashPanel.__init__(self, parent,'bash.ini.sashPos')
        left,right = self.left, self.right
        #--Remove from list button
        self.button = button(right,_(u'Remove'),onClick=self.OnRemove)
        #--Edit button
        self.edit = button(right,_(u'Edit...'),onClick=self.OnEdit)
        #--Choices
        self.choices = settings['bash.ini.choices']
        self.choice = settings['bash.ini.choice']
        self.CheckTargets()
        self.lastDir = bosh.dirs['mods'].s
        self.SortChoices()
        if self.choice < 0 or self.choice >= len(self.sortKeys):
            self.choice = 0
        #--Watch for changes to the target INI
        self.trackedInfo = bosh.TrackedFileInfos(bosh.INIInfo)
        self.trackedInfo.track(self.GetChoice())
        #--Ini file
        self.iniContents = INILineCtrl(right)
        #--Tweak file
        self.tweakContents = INITweakLineCtrl(right,self.iniContents)
        self.iniContents.SetTweakLinesCtrl(self.tweakContents)
        self.tweakName = textCtrl(right, style=wx.TE_READONLY|wx.NO_BORDER)
        self.SetBaseIni(self.GetChoice())
        global iniList
        iniList = INIList(left)
        self.list = iniList
        self.comboBox = balt.comboBox(right,wx.ID_ANY,value=self.GetChoiceString(),choices=self.sortKeys,style=wx.CB_READONLY)
        #--Events
        wx.EVT_SIZE(self,self.OnSize)
        self.comboBox.Bind(wx.EVT_COMBOBOX,self.OnSelectDropDown)
        iniList.Bind(wx.EVT_LIST_ITEM_SELECTED, self.OnSelectTweak)
        #--Layout
        iniSizer = vSizer(
                (hSizer(
                    (self.comboBox,1,wx.ALIGN_CENTER|wx.EXPAND|wx.TOP,1),
                    ((4,0),0),
                    (self.button,0,wx.ALIGN_TOP,0),
                    (self.edit,0,wx.ALIGN_TOP,0),
                    ),0,wx.EXPAND|wx.BOTTOM,4),
                (self.iniContents,1,wx.EXPAND),
                )
        lSizer = hSizer(
            (iniList,2,wx.EXPAND),
            )
        rSizer = hSizer(
            (vSizer(
                (self.tweakName,0,wx.EXPAND|wx.TOP,6),
                (self.tweakContents,1,wx.EXPAND),
                ),1,wx.EXPAND|wx.RIGHT,4),
            (iniSizer,1,wx.EXPAND),
            )
        iniSizer.SetSizeHints(right)
        right.SetSizer(rSizer)
        left.SetSizer(lSizer)

    def RefreshUIColors(self):
        self.RefreshUI()

    def OnSelectTweak(self, event):
        tweakFile = iniList.items[event.GetIndex()]
        self.tweakName.SetValue(tweakFile.sbody)
        self.tweakContents.RefreshUI(tweakFile)
        event.Skip()

    def GetChoice(self,index=None):
        """ Return path for a given choice, or the
        currently selected choice if index is None."""
        if index is None:
            return self.choices[self.sortKeys[self.choice]]
        else:
            return self.choices[self.sortKeys[index]]

    def GetChoiceString(self,index=None):
        """Return text for a given choice, or the
        currently selected choice if index is None."""
        if index is None:
            return self.sortKeys[self.choice]
        else:
            return self.sortKeys[index]

    def OnShow(self):
        changed = self.trackedInfo.refresh()
        changed = set([x for x in changed if x != bosh.oblivionIni.path])
        if self.GetChoice() in changed:
            self.RefreshUI()
        self.SetStatusCount()

    def RefreshUI(self,what='ALL'):
        if what == 'ALL' or what == 'TARGETS':
            # Refresh the drop down list
            path = self.GetChoice()
            if path is None:
                self.choice -= 1
            elif not path.isfile():
                del self.choices[self.GetChoiceString()]
                self.choice -= 1
                what = 'ALL'
            self.SetBaseIni(self.GetChoice())
            self.comboBox.SetItems(self.SortChoices())
            self.comboBox.SetSelection(self.choice)
        if what == 'ALL' or what == 'TWEAKS':
            iniList.RefreshUI()

    def SetBaseIni(self,path=None):
        """Sets the target INI file."""
        refresh = True
        choicePath = self.GetChoice()
        isGameIni = False
        for iFile in bosh.gameInis:
            if iFile.path == choicePath:
                refresh = bosh.iniInfos.ini != iFile
                bosh.iniInfos.setBaseIni(iFile)
                self.button.Enable(False)
                isGameIni = True
                break
        if not isGameIni:
            if not path:
                path = choicePath
            ini = bosh.BestIniFile(path)
            refresh = bosh.iniInfos.ini != ini
            bosh.iniInfos.setBaseIni(ini)
            self.button.Enable(True)
        selected = None
        if iniList is not None:
            selected = iniList.GetSelected()
            if len(selected) > 0:
                selected = selected[0]
            else:
                selected = None
        if refresh:
            self.trackedInfo.clear()
            self.trackedInfo.track(self.GetChoice())
        self.iniContents.RefreshUI(refresh)
        self.tweakContents.RefreshUI(selected)
        if iniList is not None: iniList.RefreshUI()

    def OnRemove(self,event):
        """Called when the 'Remove' button is pressed."""
        selection = self.comboBox.GetValue()
        self.choice -= 1
        del self.choices[selection]
        self.comboBox.SetItems(self.SortChoices())
        self.comboBox.SetSelection(self.choice)
        self.SetBaseIni()
        iniList.RefreshUI()

    def OnEdit(self,event):
        """Called when the 'Edit' button is pressed."""
        selection = self.comboBox.GetValue()
        self.choices[selection].start()

    def CheckTargets(self):
        """Check the list of target INIs, remove any that don't exist"""
        changed = False
        for i in self.choices.keys():
            if i == _(u'Browse...'): continue
            path = self.choices[i]
            # If user started with non-translated, 'Browse...'
            # will still be in here, but in English.  It wont get picked
            # up by the previous check, so we'll just delete any non-Path
            # objects.  That will take care of it.
            if not isinstance(path,bolt.Path) or not path.isfile():
                del self.choices[i]
                changed = True
        csChoices = [x.lower() for x in self.choices]
        for iFile in bosh.gameInis:
            if iFile.path.tail.cs not in csChoices:
                self.choices[iFile.path.stail] = iFile.path
                changed = True
        if _(u'Browse...') not in self.choices:
            self.choices[_(u'Browse...')] = None
            changed = True
        if changed: self.SortChoices()
        if len(self.choices.keys()) <= self.choice + 1:
            self.choice = 0

    def SortChoices(self):
        """Sorts the list of target INIs alphabetically, but with
        Oblivion.ini at the top and 'Browse...' at the bottom"""
        keys = self.choices.keys()
        # Sort alphabetically
        keys.sort()
        # Sort Oblivion.ini to the top, and 'Browse...' to the bottom
        keys.sort(key=lambda a:
                  bush.game.iniFiles.index(a) if a in bush.game.iniFiles
                  else len(bush.game.iniFiles)+1 if a == _(u'Browse...')
                  else len(bush.game.iniFiles))
        self.sortKeys = keys
        return keys

    def SetStatusCount(self):
        """Sets mod count in last field."""
        stati = iniList.CountTweakStatus()
        text = _(u'Tweaks:') + u' %d/%d' % (stati[0],sum(stati[:-1]))
        statusBar.SetStatusText(text,2)

    def AddOrSelectIniDropDown(self, path):
        if path.stail not in self.choices:
            self.choices[path.stail] = path
            self.SortChoices()
            self.comboBox.SetItems(self.sortKeys)
        else:
            if self.choice == self.sortKeys.index(path.stail):
                return
        self.choice = self.sortKeys.index(path.stail)
        self.comboBox.SetSelection(self.choice)
        self.SetBaseIni(path)
        iniList.RefreshUI()


    def OnSelectDropDown(self,event):
        """Called when the user selects a new target INI from the drop down."""
        selection = event.GetString()
        path = self.choices[selection]
        if not path:
            # 'Browse...'
            wildcard =  u'|'.join([_(u'Supported files')+u' (*.ini,*.cfg)|*.ini;*.cfg',
                                   _(u'INI files')+u' (*.ini)|*.ini',
                                   _(u'Config files')+u' (*.cfg)|*.cfg',
                                   ])
            path = balt.askOpen(self,defaultDir=self.lastDir,wildcard=wildcard,mustExist=True)
            if not path:
                self.comboBox.SetSelection(self.choice)
                return
            # Make sure the 'new' file isn't already in the list
            if path.stail in self.choices:
                new_choice = self.sortKeys.index(path.stail)
                refresh = new_choice != self.choice
                self.choice = new_choice
                self.comboBox.SetSelection(self.choice)
                if refresh:
                    self.SetBaseIni(path)
                    iniList.RefreshUI()
                return
            self.lastDir = path.shead
        self.AddOrSelectIniDropDown(path)

    def OnSize(self,event):
        wx.Window.Layout(self)
        iniList.Layout()

    def OnCloseWindow(self):
        """To be called when containing frame is closing.  Use for saving data, scrollpos, etc."""
        settings['bash.ini.choices'] = self.choices
        settings['bash.ini.choice'] = self.choice
        bosh.iniInfos.table.save()
        splitter = self.right.GetParent()
        if hasattr(self, 'sashPosKey'):
            settings[self.sashPosKey] = splitter.GetSashPosition()

#------------------------------------------------------------------------------
class ModPanel(SashPanel):
    def __init__(self,parent):
        SashPanel.__init__(self, parent,'bash.mods.sashPos',1.0,minimumSize=150)
        left,right = self.left, self.right
        global modList
        modList = ModList(left)
        self.list = modList
        self.modDetails = ModDetails(right)
        modList.details = self.modDetails
        #--Events
        wx.EVT_SIZE(self,self.OnSize)
        #--Layout
        right.SetSizer(hSizer((self.modDetails,1,wx.EXPAND)))
        left.SetSizer(hSizer((modList,2,wx.EXPAND)))

    def RefreshUIColors(self):
        self.list.RefreshUI()
        self.modDetails.SetFile()

    def SetStatusCount(self):
        """Sets mod count in last field."""
        text = _(u'Mods:')+u' %d/%d' % (len(bosh.modInfos.ordered),len(bosh.modInfos.data))
        statusBar.SetStatusText(text,2)

    def OnSize(self,event):
        wx.Window.Layout(self)
        modList.Layout()
        self.modDetails.Layout()

    def OnCloseWindow(self):
        """To be called when containing frame is closing. Use for saving data, scrollpos, etc."""
        bosh.modInfos.table.save()
        settings['bash.mods.scrollPos'] = modList.vScrollPos
        splitter = self.right.GetParent()
        settings[self.sashPosKey] = splitter.GetSashPosition()
        # Mod details Sash Positions
        splitter = self.modDetails.right.GetParent()
        settings[self.modDetails.sashPosKey] = splitter.GetSashPosition()
        splitter = self.modDetails.subSplitter
        settings['bash.mods.details.subSplitterSashPos'] = splitter.GetSashPosition()

#------------------------------------------------------------------------------
class SaveList(List):
    #--Class Data
    mainMenu = Links() #--Column menu
    itemMenu = Links() #--Single item menu

    def __init__(self,parent):
        #--Columns
        self.colsKey = 'bash.saves.cols'
        self.colAligns = settings['bash.saves.colAligns']
        self.colNames = settings['bash.colNames']
        self.colReverse = settings.getChanged('bash.saves.colReverse')
        self.colWidths = settings['bash.saves.colWidths']
        #--Data/Items
        self.data = data = bosh.saveInfos
        self.details = None #--Set by panel
        self.sort = settings['bash.saves.sort']
        #--Links
        self.mainMenu = SaveList.mainMenu
        self.itemMenu = SaveList.itemMenu
        #--Parent init
        List.__init__(self,parent,-1,ctrlStyle=(wx.LC_REPORT|wx.SUNKEN_BORDER|wx.LC_EDIT_LABELS))
        #--Image List
        checkboxesIL = self.checkboxes.GetImageList()
        self.list.SetImageList(checkboxesIL,wx.IMAGE_LIST_SMALL)
        #--Events
        self.list.Bind(wx.EVT_CHAR, self.OnChar)
        wx.EVT_LIST_ITEM_SELECTED(self,self.listId,self.OnItemSelected)
        self.list.Bind(wx.EVT_KEY_UP, self.OnKeyUp)
        self.list.Bind(wx.EVT_LIST_BEGIN_LABEL_EDIT, self.OnBeginEditLabel)
        self.list.Bind(wx.EVT_LIST_END_LABEL_EDIT, self.OnEditLabel)
        #--ScrollPos
        self.list.ScrollLines(settings.get('bash.saves.scrollPos',0))
        self.vScrollPos = self.list.GetScrollPos(wx.VERTICAL)

    def OnBeginEditLabel(self,event):
        """Start renaming saves"""
        item = self.items[event.GetIndex()]
        # Change the selection to not include the extension
        editbox = self.list.GetEditControl()
        to = len(GPath(event.GetLabel()).sbody)
        editbox.SetSelection(0,to)

    def OnEditLabel(self, event):
        """Savegame renamed."""
        if event.IsEditCancelled(): return
        #--File Info
        newName = event.GetLabel()
        if not newName.lower().endswith(u'.ess'):
            newName += u'.ess'
        newFileName = newName
        selected = self.GetSelected()
        for index, path in enumerate(selected):
            if index:
                newFileName = newName.replace(u'.ess',u'%d.ess' % index)
            if newFileName != path.s:
                oldPath = bosh.saveInfos.dir.join(path.s)
                newPath = bosh.saveInfos.dir.join(newFileName)
                if not newPath.exists():
                    oldPath.moveTo(newPath)
                    if GPath(oldPath.s[:-3]+bush.game.se.shortName.lower()).exists():
                        GPath(oldPath.s[:-3]+bush.game.se.shortName.lower()).moveTo(GPath(newPath.s[:-3]+bush.game.se.shortName.lower()))
                    if GPath(oldPath.s[:-3]+u'pluggy').exists():
                        GPath(oldPath.s[:-3]+u'pluggy').moveTo(GPath(newPath.s[:-3]+u'pluggy'))
        bosh.saveInfos.refresh()
        self.RefreshUI()

    def RefreshUI(self,files='ALL',detail='SAME'):
        """Refreshes UI for specified files."""
        #--Details
        if detail == 'SAME':
            selected = set(self.GetSelected())
        else:
            selected = set([detail])
        #--Populate
        if files == 'ALL':
            self.PopulateItems(selected=selected)
        elif isinstance(files,bolt.Path):
            self.PopulateItem(files,selected=selected)
        else: #--Iterable
            for file in files:
                self.PopulateItem(file,selected=selected)
        saveDetails.SetFile(detail)
        bashFrame.SetStatusCount()

    #--Populate Item
    def PopulateItem(self,itemDex,mode=0,selected=set()):
        #--String name of item?
        if not isinstance(itemDex,int):
            itemDex = self.items.index(itemDex)
        fileName = GPath(self.items[itemDex])
        fileInfo = self.data[fileName]
        cols = self.cols
        for colDex in range(self.numCols):
            col = cols[colDex]
            if col == 'File':
                value = fileName.s
            elif col == 'Modified':
                value = formatDate(fileInfo.mtime)
            elif col == 'Size':
                value = formatInteger(fileInfo.size/1024)+u' KB'
            elif col == 'Player' and fileInfo.header:
                value = fileInfo.header.pcName
            elif col == 'PlayTime' and fileInfo.header:
                playMinutes = fileInfo.header.gameTicks/60000
                value = u'%d:%02d' % (playMinutes/60,(playMinutes % 60))
            elif col == 'Cell' and fileInfo.header:
                value = fileInfo.header.pcLocation
            else:
                value = u'-'
            if mode and (colDex == 0):
                self.list.InsertStringItem(itemDex, value)
            else:
                self.list.SetStringItem(itemDex, colDex, value)
        #--Image
        status = fileInfo.getStatus()
        on = fileName.cext == u'.ess'
        self.list.SetItemImage(itemDex,self.checkboxes.Get(status,on))
        #--Selection State
        if fileName in selected:
            self.list.SetItemState(itemDex,wx.LIST_STATE_SELECTED,wx.LIST_STATE_SELECTED)
        else:
            self.list.SetItemState(itemDex,0,wx.LIST_STATE_SELECTED)

    #--Sort Items
    def SortItems(self,col=None,reverse=-2):
        (col, reverse) = self.GetSortSettings(col,reverse)
        settings['bash.saves.sort'] = col
        data = self.data
        #--Start with sort by name
        self.items.sort()
        if col == 'File':
            pass #--Done by default
        elif col == 'Modified':
            self.items.sort(key=lambda a: data[a].mtime)
        elif col == 'Size':
            self.items.sort(key=lambda a: data[a].size)
        elif col == 'Status':
            self.items.sort(key=lambda a: data[a].getStatus())
        elif col == 'Player':
            self.items.sort(key=lambda a: data[a].header.pcName)
        elif col == 'PlayTime':
            self.items.sort(key=lambda a: data[a].header.gameTicks)
        elif col == 'Cell':
            self.items.sort(key=lambda a: data[a].header.pcLocation)
        else:
            raise BashError(u'Unrecognized sort key: '+col)
        #--Ascending
        if reverse: self.items.reverse()

    #--Events ---------------------------------------------
    def OnChar(self,event):
        """Char event: Reordering."""
        ## Delete
        if event.GetKeyCode() in (wx.WXK_DELETE, wx.WXK_NUMPAD_DELETE):
            self.DeleteSelected()
        ## F2 - Rename
        if event.GetKeyCode() == wx.WXK_F2:
            selected = self.GetSelected()
            if len(selected) > 0:
                index = self.list.FindItem(0,selected[0].s)
                if index != -1:
                    self.list.EditLabel(index)
        event.Skip()

    #--Column Resize
    def OnColumnResize(self,event):
        super(SaveList,self).OnColumnResize(event)
        settings.setChanged('bash.saves.colWidths')

    def OnKeyUp(self,event):
        """Char event: select all items"""
        ##Ctrl+A
        if event.CmdDown() and event.GetKeyCode() == ord('A'):
            self.SelectAll()
        event.Skip()
    #--Event: Left Down
    def OnLeftDown(self,event):
        (hitItem,hitFlag) = self.list.HitTest((event.GetX(),event.GetY()))
        if hitFlag == wx.LIST_HITTEST_ONITEMICON:
            fileName = GPath(self.items[hitItem])
            newEnabled = not self.data.isEnabled(fileName)
            newName = self.data.enable(fileName,newEnabled)
            if newName != fileName: self.RefreshUI()
        #--Pass Event onward
        event.Skip()

    def OnItemSelected(self,event=None):
        saveName = self.items[event.m_itemIndex]
        self.details.SetFile(saveName)

#------------------------------------------------------------------------------
class SaveDetails(SashPanel):
    """Savefile details panel."""
    def __init__(self,parent):
        """Initialize."""
        SashPanel.__init__(self, parent,'bash.saves.details.SashPos',0.0,sashPos=230,mode=wx.HORIZONTAL,minimumSize=230,style=wx.SW_BORDER|wx.SP_LIVE_UPDATE|wx.FULL_REPAINT_ON_RESIZE)
        top,bottom = self.left, self.right
        readOnlyColour = self.GetBackgroundColour()
        #--Singleton
        global saveDetails
        saveDetails = self
        #--Data
        self.saveInfo = None
        self.edited = False
        textWidth = 200
        #--File Name
        id = self.fileId = wx.NewId()
        self.file = wx.TextCtrl(top,id,u'',size=(textWidth,-1))
        self.file.SetMaxLength(256)
        wx.EVT_KILL_FOCUS(self.file,self.OnEditFile)
        wx.EVT_TEXT(self.file,id,self.OnTextEdit)
        #--Player Info
        self.playerInfo = staticText(top,u" \n \n ")
        self.gCoSaves = staticText(top,u'--\n--')
        #--Picture
        self.picture = balt.Picture(top,textWidth,192*textWidth/256,style=wx.BORDER_SUNKEN,background=colors['screens.bkgd.image']) #--Native: 256x192
        subSplitter = self.subSplitter = wx.gizmos.ThinSplitterWindow(bottom)
        masterPanel = wx.Panel(subSplitter)
        notePanel = wx.Panel(subSplitter)
        #--Masters
        id = self.mastersId = wx.NewId()
        self.masters = MasterList(masterPanel,None,self.SetEdited)
        #--Save Info
        self.gInfo = wx.TextCtrl(notePanel,wx.ID_ANY,u'',size=(textWidth,100),style=wx.TE_MULTILINE)
        self.gInfo.SetMaxLength(2048)
        self.gInfo.Bind(wx.EVT_TEXT,self.OnInfoEdit)
        #--Save/Cancel
        self.save = button(masterPanel,id=wx.ID_SAVE,onClick=self.DoSave)
        self.cancel = button(masterPanel,id=wx.ID_CANCEL,onClick=self.DoCancel)
        self.save.Disable()
        self.cancel.Disable()
        #--Layout
        detailsSizer = vSizer(
            (self.file,0,wx.EXPAND|wx.TOP,4),
            (hSizer(
                (self.playerInfo,1,wx.EXPAND),
                (self.gCoSaves,0,wx.EXPAND),
                ),0,wx.EXPAND|wx.TOP,4),
            (self.picture,1,wx.TOP|wx.EXPAND,4),
            )
        mastersSizer = vSizer(
            (self.masters,1,wx.EXPAND|wx.TOP,4),
            (hSizer(
                self.save,
                (self.cancel,0,wx.LEFT,4),
                )),
            )
        noteSizer = vSizer(
            (hSizer((self.gInfo,1,wx.EXPAND)),1,wx.EXPAND),
            )
        detailsSizer.SetSizeHints(top)
        top.SetSizer(detailsSizer)
        subSplitter.SetMinimumPaneSize(100)
        subSplitter.SplitHorizontally(masterPanel,notePanel)
        subSplitter.SetSashGravity(1.0)
        subSplitter.SetSashPosition(settings.get('bash.saves.details.subSplitterSashPos', 500))
        mastersSizer.SetSizeHints(masterPanel)
        masterPanel.SetSizer(mastersSizer)
        noteSizer.SetSizeHints(masterPanel)
        notePanel.SetSizer(noteSizer)
        bottom.SetSizer(vSizer((subSplitter,1,wx.EXPAND)))

    def SetFile(self,fileName='SAME'):
        """Set file to be viewed."""
        #--Reset?
        if fileName == 'SAME':
            if not self.saveInfo or self.saveInfo.name not in bosh.saveInfos:
                fileName = None
            else:
                fileName = self.saveInfo.name
        #--Null fileName?
        if not fileName:
            saveInfo = self.saveInfo = None
            self.fileStr = u''
            self.playerNameStr = u''
            self.curCellStr = u''
            self.playerLevel = 0
            self.gameDays = 0
            self.playMinutes = 0
            self.picData = None
            self.coSaves = u'--\n--'
        #--Valid fileName?
        else:
            saveInfo = self.saveInfo = bosh.saveInfos[fileName]
            #--Remember values for edit checks
            self.fileStr = saveInfo.name.s
            self.playerNameStr = saveInfo.header.pcName
            self.curCellStr = saveInfo.header.pcLocation
            self.gameDays = saveInfo.header.gameDays
            self.playMinutes = saveInfo.header.gameTicks/60000
            self.playerLevel = saveInfo.header.pcLevel
            self.picData = saveInfo.header.image
            self.coSaves = u'%s\n%s' % saveInfo.coSaves().getTags()
        #--Set Fields
        self.file.SetValue(self.fileStr)
        self.playerInfo.SetLabel((self.playerNameStr+u'\n'+
                                  _(u'Level')+u' %d, '+
                                  _(u'Day')+u' %d, '+
                                  _(u'Play')+u' %d:%02d\n%s') %
                                 (self.playerLevel,int(self.gameDays),
                                  self.playMinutes/60,(self.playMinutes%60),
                                  self.curCellStr))
        self.gCoSaves.SetLabel(self.coSaves)
        self.masters.SetFileInfo(saveInfo)
        #--Picture
        if not self.picData:
            self.picture.SetBitmap(None)
        else:
            width,height,data = self.picData
            image = wx.EmptyImage(width,height)
            image.SetData(data)
            self.picture.SetBitmap(image.ConvertToBitmap())
        #--Edit State
        self.edited = 0
        self.save.Disable()
        self.cancel.Disable()
        #--Info Box
        self.gInfo.DiscardEdits()
        if fileName:
            self.gInfo.SetValue(bosh.saveInfos.table.getItem(fileName,'info',_(u'Notes: ')))
        else:
            self.gInfo.SetValue(_(u'Notes: '))

    def SetEdited(self):
        """Mark as edited."""
        self.edited = True
        if bush.game.ess.canEditMasters:
            self.save.Enable()
        self.cancel.Enable()

    def OnInfoEdit(self,event):
        """Info field was edited."""
        if self.saveInfo and self.gInfo.IsModified():
            bosh.saveInfos.table.setItem(self.saveInfo.name,'info',self.gInfo.GetValue())

    def OnTextEdit(self,event):
        """Event: Editing file or save name text."""
        if self.saveInfo and not self.edited:
            if self.fileStr != self.file.GetValue():
                self.SetEdited()
        event.Skip()

    def OnEditFile(self,event):
        """Event: Finished editing file name."""
        if not self.saveInfo: return
        #--Changed?
        fileStr = self.file.GetValue()
        if fileStr == self.fileStr: return
        #--Extension Changed?
        if self.fileStr[-4:].lower() not in (u'.ess',u'.bak'):
            balt.showError(self,_(u"Incorrect file extension: ")+fileStr[-3:])
            self.file.SetValue(self.fileStr)
        #--Else file exists?
        elif self.saveInfo.dir.join(fileStr).exists():
            balt.showError(self,_(u"File %s already exists.") % (fileStr,))
            self.file.SetValue(self.fileStr)
        #--Okay?
        else:
            self.fileStr = fileStr
            self.SetEdited()

    def DoSave(self,event):
        """Event: Clicked Save button."""
        saveInfo = self.saveInfo
        #--Change Tests
        changeName = (self.fileStr != saveInfo.name)
        changeMasters = self.masters.edited
        #--Backup
        saveInfo.makeBackup()
        prevMTime = saveInfo.mtime
        #--Change Name?
        if changeName:
            (oldName,newName) = (saveInfo.name,GPath(self.fileStr.strip()))
            saveList.items[saveList.items.index(oldName)] = newName
            bosh.saveInfos.rename(oldName,newName)
        #--Change masters?
        if changeMasters:
            saveInfo.header.masters = self.masters.GetNewMasters()
            saveInfo.header.writeMasters(saveInfo.getPath())
            saveInfo.setmtime(prevMTime)
        #--Done
        try:
            bosh.saveInfos.refreshFile(saveInfo.name)
            self.SetFile(self.saveInfo.name)
        except bosh.FileError:
            balt.showError(self,_(u'File corrupted on save!'))
            self.SetFile(None)
            saveList.RefreshUI()
        else:
            saveList.RefreshUI(saveInfo.name)

    def DoCancel(self,event):
        """Event: Clicked cancel button."""
        self.SetFile(self.saveInfo.name)

#------------------------------------------------------------------------------
class SavePanel(SashPanel):
    """Savegames tab."""
    def __init__(self,parent):
        if not bush.game.ess.canReadBasic:
            raise Exception(u'Wrye Bash cannot read save games for %s.' % bush.game.name)
        SashPanel.__init__(self, parent,'bash.saves.sashPos',1.0,minimumSize=200)
        left,right = self.left, self.right
        global saveList
        saveList = SaveList(left)
        self.list = saveList
        self.saveDetails = SaveDetails(right)
        saveList.details = self.saveDetails
        #--Events
        wx.EVT_SIZE(self,self.OnSize)
        #--Layout
        right.SetSizer(hSizer((self.saveDetails,1,wx.EXPAND)))
        left.SetSizer(hSizer((saveList,2,wx.EXPAND)))

    def RefreshUIColors(self):
        self.saveDetails.SetFile()
        self.saveDetails.picture.SetBackground(colors['screens.bkgd.image'])

    def SetStatusCount(self):
        """Sets mod count in last field."""
        text = _(u"Saves: %d") % (len(bosh.saveInfos.data))
        statusBar.SetStatusText(text,2)

    def OnSize(self,event=None):
        wx.Window.Layout(self)
        saveList.Layout()
        self.saveDetails.Layout()

    def OnCloseWindow(self):
        """To be called when containing frame is closing. Use for saving data, scrollpos, etc."""
        table = bosh.saveInfos.table
        for saveName in table.keys():
            if saveName not in bosh.saveInfos:
                del table[saveName]
        table.save()
        bosh.saveInfos.profiles.save()
        settings['bash.saves.scrollPos'] = saveList.vScrollPos
        splitter = self.right.GetParent()
        settings[self.sashPosKey] = splitter.GetSashPosition()
        # Mod details Sash Positions
        splitter = self.saveDetails.right.GetParent()
        settings[self.saveDetails.sashPosKey] = splitter.GetSashPosition()
        splitter = self.saveDetails.subSplitter
        settings['bash.saves.details.subSplitterSashPos'] = splitter.GetSashPosition()

#------------------------------------------------------------------------------
class InstallersList(balt.Tank):
    def __init__(self,parent,data,icons=None,mainMenu=None,itemMenu=None,
            details=None,id=-1,style=(wx.LC_REPORT | wx.LC_SINGLE_SEL)):
        self.colNames = settings['bash.colNames']
        self.colAligns = settings['bash.installers.colAligns']
        self.colReverse = settings['bash.installers.colReverse']
        self.colWidths = settings['bash.installers.colWidths']
        self.sort = settings['bash.installers.sort']
        balt.Tank.__init__(self,parent,data,icons,mainMenu,itemMenu,
            details,id,style|wx.LC_EDIT_LABELS,dndList=True,dndFiles=True,dndColumns=['Order'])
        self.gList.Bind(wx.EVT_CHAR, self.OnChar)
        self.gList.Bind(wx.EVT_KEY_UP, self.OnKeyUp)
        self.gList.Bind(wx.EVT_LIST_BEGIN_LABEL_EDIT, self.OnBeginEditLabel)
        self.gList.Bind(wx.EVT_LIST_END_LABEL_EDIT, self.OnEditLabel)
        self.hitItem = None
        self.hitTime = 0

    @property
    def cols(self): return settings['bash.installers.cols']

    def SetSort(self,sort):
        self.sort = settings['bash.installers.sort'] = sort

    def SetColumnReverse(self,column,reverse):
        settings['bash.installers.colReverse'][column] = reverse
        settings.setChanged('bash.installers.colReverse')

    def GetColumnDex(self,column):
        return settingDefaults['bash.installers.cols'].index(column)

    def OnColumnResize(self,event):
        """Column has been resized."""
        super(InstallersList, self).OnColumnResize(event)
        settings.setChanged('bash.installers.colWidths')

    def MouseOverItem(self,item):
        """Handle mouse entered item by showing tip or similar."""
        if item < 0: return
        item = self.GetItem(item)
        text = self.mouseTexts.get(item) or u''
        if text != self.mouseTextPrev:
            statusBar.SetStatusText(text,1)
            self.mouseTextPrev = text

    def OnBeginEditLabel(self,event):
        """Start renaming installers"""
        #--Only rename multiple items of the same type
        firstItem = self.data[self.GetSelected()[0]]
        InstallerType = None
        if(isinstance(firstItem,bosh.InstallerMarker)):
            InstallerType = bosh.InstallerMarker
        elif(isinstance(firstItem,bosh.InstallerArchive)):
            InstallerType = bosh.InstallerArchive
        elif(isinstance(firstItem,bosh.InstallerProject)):
            InstallerType = bosh.InstallerProject
        else:
            event.Veto()
            return
        for item in self.GetSelected():
            if not isinstance(self.data[item],InstallerType):
                event.Veto()
                return
            #--Also, don't allow renaming the 'Last' marker
            elif item == u'==Last==':
                event.Veto()
                return
        editbox = self.gList.GetEditControl()
        editbox.Bind(wx.EVT_CHAR, self.OnEditLabelChar)
        #--Markers, change the selection to not include the '=='
        if InstallerType is bosh.InstallerMarker:
            to = len(event.GetLabel()) - 2
            editbox.SetSelection(2,to)
        #--Archives, change the selection to not include the extension
        elif InstallerType is bosh.InstallerArchive:
            to = len(GPath(event.GetLabel()).sbody)
            editbox.SetSelection(0,to)

    def OnEditLabelChar(self, event):
        """For pressing F2 on the edit box for renaming"""
        if event.GetKeyCode() == wx.WXK_F2:
            editbox = self.gList.GetEditControl()
            selection = editbox.GetSelection()
            text = editbox.GetValue()
            lenWithExt = len(text)
            if selection[0] != 0:
                selection = (0,lenWithExt)
            selectedText = GPath(text[selection[0]:selection[1]])
            textNextLower = selectedText.body
            if textNextLower == selectedText:
                lenNextLower = lenWithExt
            else:
                lenNextLower = len(textNextLower.s)

            selected = self.data[self.GetSelected()[0]]
            if isinstance(selected, bosh.InstallerArchive):
                selection = (0, lenNextLower)
            elif isinstance(selected, bosh.InstallerMarker):
                selection = (2, lenWithExt-2)
            else:
                selection = (0, lenWithExt)
            editbox.SetSelection(*selection)
        else:
            event.Skip()

    def OnEditLabel(self, event):
        """Renamed some installers"""
        if event.IsEditCancelled(): return

        newName = event.GetLabel()

        selected = self.GetSelected()
        if isinstance(self.data[selected[0]], bosh.InstallerArchive):
            InstallerType = bosh.InstallerArchive
            rePattern = re.compile(ur'^([^\\/]+?)(\d*)((\.(7z|rar|zip|001))+)$',re.I|re.U)
        elif isinstance(self.data[selected[0]], bosh.InstallerMarker):
            InstallerType = bosh.InstallerMarker
            rePattern = re.compile(ur'^([^\\/]+?)(\d*)$',re.I|re.U)
        elif isinstance(self.data[selected[0]], bosh.InstallerProject):
            InstallerType = bosh.InstallerProject
            rePattern = re.compile(ur'^([^\\/]+?)(\d*)$',re.I|re.U)
        maPattern = rePattern.match(newName)
        if not maPattern:
            balt.showError(self,_(u'Bad extension or file root: ')+newName)
            event.Veto()
            return
        root,numStr = maPattern.groups()[:2]
        if InstallerType is bosh.InstallerMarker:
            root = root.strip(u'=')
        #--Rename each installer, keeping the old extension (for archives)
        numLen = len(numStr)
        num = int(numStr or 0)
        installersDir = bosh.dirs['installers']
        with balt.BusyCursor():
            refreshNeeded = False
            for archive in selected:
                installer = self.data[archive]
                newName = GPath(root+numStr+archive.ext)
                if InstallerType is bosh.InstallerMarker:
                    newName = GPath(u'==' + newName.s + u'==')
                if newName != archive:
                    oldPath = installersDir.join(archive)
                    newPath = installersDir.join(newName)
                    if not newPath.exists():
                        if InstallerType is not bosh.InstallerMarker:
                            oldPath.moveTo(newPath)
                        self.data.pop(installer)
                        installer.archive = newName.s
                        #--Add the new archive to Bash
                        self.data[newName] = installer
                        #--Update the iniInfos & modInfos for 'installer'
                        if InstallerType is not bosh.InstallerMarker:
                            mfiles = (x for x in bosh.modInfos.table.getColumn('installer') if bosh.modInfos.table[x]['installer'] == oldPath.stail)
                            ifiles = (x for x in bosh.iniInfos.table.getColumn('installer') if bosh.iniInfos.table[x]['installer'] == oldPath.stail)
                            for i in mfiles:
                                bosh.modInfos.table[i]['installer'] = newPath.stail
                            for i in ifiles:
                                bosh.iniInfos.table[i]['installer'] = newPath.stail
                    if InstallerType is bosh.InstallerMarker:
                        del self.data[archive]
                    refreshNeeded = True
                num += 1
                numStr = unicode(num)
                numStr = u'0'*(numLen-len(numStr))+numStr
            #--Refresh UI
            if refreshNeeded:
                self.data.refresh(what='I')
                modList.RefreshUI()
                if iniList is not None:
                    # It will be None if the INI Edits Tab was hidden at startup,
                    # and never initialized
                    iniList.RefreshUI()
                self.RefreshUI()
            event.Veto()

    def OnDropFiles(self, x, y, filenames):
        filenames = [GPath(x) for x in filenames]
        omodnames = [x for x in filenames if not x.isdir() and x.cext == u'.omod']
        converters = [x for x in filenames if self.data.validConverterName(x)]
        filenames = [x for x in filenames if x.isdir() or x.cext in bosh.readExts and x not in converters]
        if len(omodnames) > 0:
            failed = []
            completed = []
            progress = balt.Progress(_(u'Extracting OMODs...'),u'\n'+u' '*60,abort=True)
            progress.setFull(len(omodnames))
            try:
                for i,omod in enumerate(omodnames):
                    progress(i,omod.stail)
                    outDir = bosh.dirs['installers'].join(omod.body)
                    if outDir.exists():
                        if balt.askYes(progress.dialog,_(u"The project '%s' already exists.  Overwrite with '%s'?") % (omod.sbody,omod.stail)):
                            outDir.rmtree(omod.sbody)
                        else:
                            continue
                    try:
                        bosh.OmodFile(omod).extractToProject(outDir,SubProgress(progress,i))
                        completed.append(omod)
                    except CancelError:
                        # Clean up from current omod that is extracting
                        try:
                            outDir.rmtree(omod.sbody)
                        except:
                            bolt.deprint(_(u'Failed to clean up output dir:')+u'\n', traceback=True)
                        try:
                            bosh.dirs['mopy'].join(u'temp').rmtree(u'temp')
                        except:
                            bolt.deprint(_(u'Failed to clean up temp dir:')+u'\n', traceback=True)
                        raise
                    except:
                        bolt.deprint(_(u"Failed to extract '%s'.") % omod.stail + u'\n\n', traceback=True)

                        # Clean up
                        failed.append(u' * ' + omod.stail)
                        try:
                            outDir.rmtree(omod.sbody)
                        except:
                            bolt.deprint(_(u'Failed to clean up output dir:')+u'\n', traceback=True)
                        try:
                            bosh.dirs['mopy'].join(u'temp').rmtree(u'temp')
                        except:
                            bolt.deprint(_(u'Failed to clean up temp dir:')+u'\n', taceback=True)
            except CancelError:
                skipped = set(omodnames) - set(completed)
                msg = u''
                if len(completed) > 0:
                    completed = [u' * ' + x.stail for x in completed]
                    msg += _(u'The following OMODs were unpacked:')+u'\n%s\n\n' % u'\n'.join(completed)
                if len(skipped) > 0:
                    skipped = [u' * ' + x.stail for x in skipped]
                    msg += _(u'The following OMODs were skipped:')+u'\n%s\n\n' % u'\n'.join(skipped)
                if len(failed) > 0:
                    msg += _(u'The following OMODs failed to extract:')+u'\n%s' % u'\n'.join(failed)
                balt.showOk(self,msg,_(u'OMOD Extraction Canceled'))
            else:
                if len(failed) > 0:
                    balt.showWarning(self,
                                     _(u'The following OMODs failed to extract.  This could be a file IO error, or an unsupported OMOD format:')+u'\n\n'+u'\n'.join(failed),
                                     _(u'OMOD Extraction Complete'))
            finally:
                progress(len(omodnames),_(u'Refreshing...'))
                self.data.refresh(what='I')
                self.RefreshUI()
                progress.Destroy()
        if not filenames and not converters:
            return
        action = settings['bash.installers.onDropFiles.action']
        if action not in ['COPY','MOVE']:
            message = _(u'You have dragged the following files into Wrye Bash:')+u'\n'
            for file in filenames:
                message += u' * ' + file.s + u'\n'
            message += u'\n'
            message += _(u'What would you like to do with them?')

            self.dialog = dialog= wx.Dialog(self,wx.ID_ANY,_(u'Move or Copy?'),size=(400,200),style=wx.DEFAULT_DIALOG_STYLE|wx.RESIZE_BORDER)
            icon = wx.StaticBitmap(dialog,wx.ID_ANY,wx.ArtProvider_GetBitmap(wx.ART_WARNING,wx.ART_MESSAGE_BOX, (32,32)))
            gCheckBox = checkBox(dialog,_(u"Don't show this in the future."))

            sizer = vSizer(
                (hSizer(
                    (icon,0,wx.ALL,6),
                    (staticText(dialog,message,style=wx.ST_NO_AUTORESIZE),1,wx.EXPAND|wx.LEFT,6),
                    ),1,wx.EXPAND|wx.ALL,6),
                (gCheckBox,0,wx.EXPAND|wx.LEFT|wx.RIGHT|wx.BOTTOM,6),
                (hSizer(
                    spacer,
                    button(dialog,label=_(u'Move'),onClick=self.OnClickMove),
                    (button(dialog,label=_(u'Copy'),onClick=self.OnClickCopy),0,wx.LEFT,4),
                    (button(dialog,id=wx.ID_CANCEL),0,wx.LEFT,4),
                    ),0,wx.EXPAND|wx.LEFT|wx.RIGHT|wx.BOTTOM,6),
                )
            dialog.SetSizer(sizer)
            result = dialog.ShowModal()
            if result == 1:
                action = 'MOVE'
            elif result == 2:
                action = 'COPY'
            else:
                return
            if gCheckBox.GetValue():
                settings['bash.installers.onDropFiles.action'] = action
        with balt.BusyCursor():
            if action == 'COPY':
                #--Copy the dropped files
                for file in filenames:
                    file.copyTo(bosh.dirs['installers'].join(file.tail))
                for file in converters:
                    file.copyTo(bosh.dirs['converters'].join(file.tail))
            elif action == 'MOVE':
                for file in filenames:
                    file.moveTo(bosh.dirs['installers'].join(file.tail))
                for file in converters:
                    file.copyTo(bosh.dirs['converters'].join(file.tail))
            else:
                return
            modList.RefreshUI()
            if iniList:
                iniList.RefreshUI()
        gInstallers.frameActivated = True
        gInstallers.OnShow()

    def OnClickMove(self,event):
        self.dialog.EndModal(1)

    def OnClickCopy(self,event):
        self.dialog.EndModal(2)

    def SelectAll(self):
        for itemDex in range(self.gList.GetItemCount()):
            self.gList.SetItemState(itemDex,wx.LIST_STATE_SELECTED,wx.LIST_STATE_SELECTED)

    def OnChar(self,event):
        """Char event: Reorder."""
        code = event.GetKeyCode()
        ##Ctrl+Up/Ctrl+Down - Move installer up/down install order
        if event.CmdDown() and code in (wx.WXK_UP,wx.WXK_DOWN,wx.WXK_NUMPAD_UP,wx.WXK_NUMPAD_DOWN):
            if len(self.GetSelected()) < 1: return
            orderKey = lambda x: self.data.data[x].order
            maxPos = max(self.data.data[x].order for x in self.data.data)
            if code in (wx.WXK_DOWN,wx.WXK_NUMPAD_DOWN):
                moveMod = 1
                visibleIndex = self.GetIndex(sorted(self.GetSelected(),key=orderKey)[-1]) + 2
            else:
                moveMod = -1
                visibleIndex = self.GetIndex(sorted(self.GetSelected(),key=orderKey)[0]) - 2
            for thisFile in sorted(self.GetSelected(),key=orderKey,reverse=(moveMod != -1)):
                newPos = self.data.data[thisFile].order + moveMod
                if newPos < 0 or maxPos < newPos: break
                self.data.moveArchives([thisFile],newPos)
            self.data.refresh(what='IN')
            self.RefreshUI()
            if visibleIndex > maxPos: visibleIndex = maxPos
            elif visibleIndex < 0: visibleIndex = 0
            self.gList.EnsureVisible(visibleIndex)
        elif code in (wx.WXK_RETURN,wx.WXK_NUMPAD_ENTER):
        ##Enter - Open selected Installer/
            selected = self.GetSelected()
            if selected:
                path = self.data.dir.join(selected[0])
                if path.exists(): path.start()
        elif event.CmdDown() and code == ord('V'):
            ##Ctrl+V
            if wx.TheClipboard.Open():
                if wx.TheClipboard.IsSupported(wx.DataFormat(wx.DF_FILENAME)):
                    obj = wx.FileDataObject()
                    wx.TheClipboard.GetData(obj)
                    wx.CallLater(10,self.OnDropFiles,0,0,obj.GetFilenames())
                wx.TheClipboard.Close()
        else:
            event.Skip()

    def OnDClick(self,event):
        """Double click, open the installer."""
        (hitItem,hitFlag) = self.gList.HitTest(event.GetPosition())
        if hitItem < 0: return
        item = self.GetItem(hitItem)
        if isinstance(self.data[item],bosh.InstallerMarker):
            # Double click on a Marker, select all items below
            # it in install order, up to the next Marker
            sorted = self.data.getSorted('order',False,False)
            item = self.data[item]
            for nextItem in sorted[item.order+1:]:
                installer = self.data[nextItem]
                if isinstance(installer,bosh.InstallerMarker):
                    break
                itemDex = self.GetIndex(nextItem)
                self.gList.SetItemState(itemDex,wx.LIST_STATE_SELECTED,
                                        wx.LIST_STATE_SELECTED)
        else:
            path = self.data.dir.join(self.GetItem(hitItem))
            if path.exists(): path.start()
        event.Skip()

    def OnLeftDown(self,event):
        """Left click, do stuff; currently nothing."""
        event.Skip()
        return

    def OnKeyUp(self,event):
        """Char events: Action depends on keys pressed"""
        code = event.GetKeyCode()
        ##Ctrl+A - select all
        if event.CmdDown() and code == ord('A'):
            self.SelectAll()
        ##Delete - delete
        elif code in (wx.WXK_DELETE,wx.WXK_NUMPAD_DELETE):
            with balt.BusyCursor():
                self.DeleteSelected()
        ##F2 - Rename selected.
        elif code == wx.WXK_F2:
            selected = self.GetSelected()
            if selected > 0:
                index = self.GetIndex(selected[0])
                if index != -1:
                    self.gList.EditLabel(index)
        ##Ctrl+Shift+N - Add a marker
        elif event.CmdDown() and event.ShiftDown() and code == ord('N'):
            index = self.GetIndex(GPath(u'===='))
            if index == -1:
                self.data.addMarker(u'====')
                self.data.refresh(what='OS')
                gInstallers.RefreshUIMods()
                index = self.GetIndex(GPath(u'===='))
            if index != -1:
                self.ClearSelected()
                self.gList.SetItemState(index,wx.LIST_STATE_SELECTED,wx.LIST_STATE_SELECTED)
                self.gList.EditLabel(index)
        event.Skip()


class TextDropTargetForTextToWizardString(wx.TextDropTarget):
    ''' This object implements Drop Target functionality for Text '''
    def __init__(self, window):
        # Initialize the Drop Target, passing in the Object Reference to indicate what should receive the dropped text
        wx.TextDropTarget.__init__(self)
        # Store the Object Reference for dropped text
        self.window = window

    def OnDropText(self, x, y, text):
        ''' Implement Text Drop & Convert to a Wizard String '''
        # When text is dropped, write it into the object specified
        self.window.BeginUndoAction()

        self.window.ClearAll()# Delete the drag and drop into this window initial message or anything else.

        self.window.AddText(text)

        #------- Text to wizard string Conversion START ---------
        target = '\\'
        newtext = '\\\\'
        try:
            self.window.SetText(self.window.GetText().replace(target, newtext))  # Escape all Backslashes - Whole Doc
        except:
            self.window.SetTextUTF8(self.window.GetTextUTF8().replace(target, newtext))

        self.window.SelectAll()

        selectedtext = self.window.GetSelectedText()
        splitselectedtext = selectedtext.split('\n')
        length = len(splitselectedtext)

        for i in range(0,length,1):
            self.window.ReplaceSelection(' \\n' + splitselectedtext[i] + '\n')
        self.window.DeleteBack()

        totalnumlines = self.window.GetLineCount()

        for i in range(0,totalnumlines,1):
            self.window.GotoLine(i)
            self.window.Home()
            # self.window.AddText(' \\n')

            self.window.Home()
            self.window.DeleteBack()

        self.window.GotoLine(1)
        self.window.Home()
        self.window.GotoPos(3)
        for i in range(0,3): self.window.DeleteBack()

        target = '"'
        newtext = "''"
        try:
            self.window.SetText(self.window.GetText().replace(target, newtext))  # Convert " to '' - Whole Doc
        except:
            self.window.SetTextUTF8(self.window.GetTextUTF8().replace(target, newtext))

        self.window.SelectAll()
        selectedtext2 = self.window.GetSelectedText()

        self.window.SelectAll()
        self.window.DeleteBack()
        self.window.SetFocus()

        self.window.AddText('Mod_Readme = str("' + selectedtext2 + '")')
        self.window.StyleSetBackground(style=stc.STC_STYLE_DEFAULT, back='#CFFFCC')

        self.window.EndUndoAction()
        #------- Text to wizard string Conversion END -----------

class FileDropTargetForTextToWizardString(wx.FileDropTarget):
    ''' This object implements Drop Target functionality for Files '''
    def __init__(self, window):
        ''' Initialize the Drop Target, passing in the Object Reference to indicate what should receive the dropped file '''
        wx.FileDropTarget.__init__(self)
        self.window = window

    def OnDropFiles(self, x, y, filenames):
        ''' Implement File Drop & Convert to a Wizard String '''
        for name in filenames:
            try:
                self.window.BeginUndoAction()

                self.window.ClearAll()# Delete the drag and drop into this window initial message or anything else.

                textfile = open(name, 'r')
                text = textfile.read()
                self.window.AddText(text)
                textfile.close()
                #------- Text to wizard string Conversion START ---------
                target = '\\'
                newtext = '\\\\'
                try:
                    self.window.SetText(self.window.GetText().replace(target, newtext))  # Escape all Backslashes - Whole Doc
                except:
                    self.window.SetTextUTF8(self.window.GetTextUTF8().replace(target, newtext))

                self.window.SelectAll()

                selectedtext = self.window.GetSelectedText()
                splitselectedtext = selectedtext.split('\n')
                length = len(splitselectedtext)

                for i in range(0,length,1):
                    self.window.ReplaceSelection(' \\n' + splitselectedtext[i] + '\n')
                self.window.DeleteBack()

                totalnumlines = self.window.GetLineCount()

                for i in range(0,totalnumlines,1):
                    self.window.GotoLine(i)
                    self.window.Home()

                    self.window.Home()
                    self.window.DeleteBack()

                self.window.GotoLine(1)
                self.window.Home()
                self.window.GotoPos(3)
                for i in range(0,3): self.window.DeleteBack()

                target = '"'
                newtext = "''"
                try:
                    self.window.SetText(self.window.GetText().replace(target, newtext))  # Convert " to '' - Whole Doc
                except:
                    self.window.SetTextUTF8(self.window.GetTextUTF8().replace(target, newtext))

                self.window.SelectAll()
                selectedtext2 = self.window.GetSelectedText()

                self.window.SelectAll()
                self.window.DeleteBack()
                self.window.SetFocus()

                #Prep wizstring basename and replace spaces with underscores for BAIN and/or UNIX compatability
                basename = os.path.basename(name)
                basename = basename[:basename.rfind('.')]
                basename = basename.replace(' ','_')
                self.window.AddText(basename + ' = str("' + selectedtext2 + '")')
                self.window.StyleSetBackground(style=stc.STC_STYLE_DEFAULT, back='#CFFFCC')

                self.window.EndUndoAction()
                #------- Text to wizard string Conversion END -----------
            except IOError, error:
                dialog = wx.MessageDialog(None, 'Error opening file\n' + str(error))
                dialog.ShowModal()
            except UnicodeDecodeError, error:
                dialog = wx.MessageDialog(None, 'Cannot open non ascii files\n' + str(error))
                dialog.ShowModal()

class TextToWizardStringSTC(stc.StyledTextCtrl):
    def __init__(self, parent):
        stc.StyledTextCtrl.__init__(self, parent, wx.ID_ANY)
        self.SetMarginWidth(1, 0)# This makes it look like just a simple textctrl.

        self.Bind(stc.EVT_STC_DO_DROP, self.OnDoDrop)
        self.Bind(stc.EVT_STC_DRAG_OVER, self.OnDragOver)

    def OnDragOver(self, event):
        event.SetDragResult(wx.DragNone)   # prevent dropping at the beginning of the buffer

    def OnDoDrop(self, event):
        event.SetDragText(event.GetDragText())  # Can change text if needed


class WizBAINStyledTextCtrl(stc.StyledTextCtrl):
    def __init__(self, parent, ID):
        stc.StyledTextCtrl.__init__(self, parent, -1)

        global gWizSTC
        gWizSTC = self

        mopyDir = os.getcwd()
        self.imgDir = mopyDir + os.sep + 'bash' + os.sep + 'images'
        self.imgstcDir = mopyDir + os.sep + 'bash' + os.sep + 'images' + os.sep + 'stc'
        # print self.imgDir
        # print self.imgstcDir

        global gGlobalsDict

        from collections import OrderedDict
        gGlobalsDict = OrderedDict([
            ('LoadSTCLexer' , 'wizbainlexer'),
            ('ThemeOnStartup' , 'Default'),
            ('FolderMarginStyle', 1),
            ('ShowLineNumbersMargin', 1),
            ('AutoAdjustLineMargin', 1),
            ('CaretLineBackgroundAlpha', 100),
            ('WordWrap', 0),
            ('TabsOrSpaces', 0),
            ('IndentSize', 4),
            ('BraceCompletion', 0),
            ])

        self.SetLexer(stc.STC_LEX_PYTHON)

        self.SetKeyWords(0, u' '.join(keywordWIZBAIN.kwlist))
        self.SetKeyWords(1, u' '.join(keywordWIZBAIN2.kwlist))

        self.SetEOLMode(stc.STC_EOL_LF)#UNIX

        self.SetCaretLineVisible(True)
        self.SetCaretLineBackground('#D7DEEB')
        self.SetUseTabs(0)
        # self.SetTabIndents(4)
        self.SetTabWidth(4)
        self.SetViewWhiteSpace(1) # Set to 0,1,or 2

        self.SetProperty('fold', '1')
        self.SetProperty('tab.timmy.whinge.level', '1')
        self.SetProperty('fold.quotes.python', '1')
        self.SetProperty('fold.comment.python', '1')

        self.StyleClearAll()

        self.StyleSetSpec(stc.STC_STYLE_DEFAULT,     'fore:#000000,back:#FFFFFF,face:%(mono)s,size:%(size)d' % faces)
        self.StyleSetSpec(stc.STC_STYLE_INDENTGUIDE, 'fore:#33FF33,back:#FF0000')
        self.StyleSetSpec(stc.STC_STYLE_LINENUMBER,  'fore:#000000,back:#99AA99,face:%(mono)s,size:%(size2)d' % faces)
        self.StyleSetSpec(stc.STC_STYLE_CONTROLCHAR, 'fore:#000000,back:#FFFFFF,face:%(other)s' % faces)
        self.StyleSetSpec(stc.STC_STYLE_BRACELIGHT,  'fore:#FF0000,back:#0000FF,bold')
        self.StyleSetSpec(stc.STC_STYLE_BRACEBAD,    'fore:#000000,back:#FF0000,bold')

        #Setup a margin to hold bookmarks
        self.SetMarginType(1, stc.STC_MARGIN_SYMBOL)
        self.SetMarginSensitive(1, True)
        self.SetMarginWidth(1, 16)

        # Define the bookmark images
        self.MarkerDefineBitmap(0, wx.Image(self.imgstcDir + os.sep + 'caretlinebm16.png', wx.BITMAP_TYPE_PNG).ConvertToBitmap())
        self.MarkerDefineBitmap(1, wx.Image(self.imgstcDir + os.sep + 'bookmark16.png', wx.BITMAP_TYPE_PNG).ConvertToBitmap())

        # Setup a margin to hold line numbers
        self.SetMarginType(2, stc.STC_MARGIN_NUMBER)
        self.SetMarginWidth(2, 40)  #5 digits using a small mono font (40 pixels). Good up to 9999

        # Setup a margin to hold fold markers
        ## self.SetFoldFlags(16)  ###  WHAT IS THIS VALUE?  WHAT ARE THE OTHER FLAGS?  DOES IT MATTER?
        self.SetMarginType(3, stc.STC_MARGIN_SYMBOL)
        self.SetMarginMask(3, stc.STC_MASK_FOLDERS)
        self.SetMarginSensitive(3, True)
        self.SetMarginWidth(3, 16)

        self.SetWrapMode(gGlobalsDict['WordWrap'])
        self.SetWrapVisualFlags(1) #0 = off. 1 = wraparrow at right. 2 = wraparrow at left. 3 = wraparrow at left and right.
        #Set the location of visual flags for wrapped lines. 0&2 = far right. 1&3 = EOL char at where the wrap starts on the right.
        self.SetWrapVisualFlagsLocation(stc.STC_WRAPVISUALFLAGLOC_DEFAULT)

        # Set Python Styles
        # default
        self.StyleSetSpec(stc.STC_P_DEFAULT,        'fore:#000000,back:#FFFFFF,face:%(mono)s,size:%(size)d' % faces)
        # comments
        self.StyleSetSpec(stc.STC_P_COMMENTLINE,    'fore:#007F00,back:#EAFFE9,face:%(mono)s,size:%(size)d' % faces)
        # number
        self.StyleSetSpec(stc.STC_P_NUMBER,         'fore:#FF0000,back:#FFFFFF,size:%(size)d' % faces)
        # string
        self.StyleSetSpec(stc.STC_P_STRING,         'fore:#FF8000,back:#FFFFFF,face:%(mono)s,size:%(size)d' % faces)
        # single quoted string
        self.StyleSetSpec(stc.STC_P_CHARACTER,      'fore:#FF8000,back:#FFFFFF,face:%(mono)s,size:%(size)d' % faces)
        # keyword
        self.StyleSetSpec(stc.STC_P_WORD,           'fore:#FF0000,back:#FFFFFF,face:%(mono)s,size:%(size)d' % faces)
        # keyword2
        self.StyleSetSpec(stc.STC_P_WORD2,          'fore:#6000FF,back:#FFFFFF,face:%(mono)s,size:%(size)d' % faces)
        # triple quotes
        self.StyleSetSpec(stc.STC_P_TRIPLE,         'fore:#000000,back:#FFF7EE,size:%(size)d' % faces)
        # triple double quotes
        self.StyleSetSpec(stc.STC_P_TRIPLEDOUBLE,   'fore:#FF8000,back:#FFF7EE,size:%(size)d' % faces)
        # class name definition
        self.StyleSetSpec(stc.STC_P_CLASSNAME,      'fore:#0000FF,back:#FFFFFF,bold,underline,size:%(size)d' % faces)
        # function or method name definition
        self.StyleSetSpec(stc.STC_P_DEFNAME,        'fore:#007F7F,back:#FFFFFF,bold,size:%(size)d' % faces)
        # operators
        self.StyleSetSpec(stc.STC_P_OPERATOR,       'fore:#000000,back:#FFFFFF,bold,size:%(size)d' % faces)
        # identifiers
        self.StyleSetSpec(stc.STC_P_IDENTIFIER,     'fore:#000000,back:#FFFFFF,face:%(mono)s,size:%(size)d' % faces)
        # comment-blocks
        self.StyleSetSpec(stc.STC_P_COMMENTBLOCK,   'fore:#7F7F7F,back:#F8FFF8,size:%(size)d' % faces)
        # end of line where string is not closed
        self.StyleSetSpec(stc.STC_P_STRINGEOL,      'fore:#000000,back:#E0C0E0,face:%(mono)s,eol,size:%(size)d' % faces)

        self.Bind(stc.EVT_STC_MARGINCLICK,      self.OnMarginClick)
        self.Bind(wx.EVT_CONTEXT_MENU,          self.OnContextMenu)
        self.Bind(stc.EVT_STC_UPDATEUI,         self.OnUpdateUI)
        self.Bind(wx.EVT_KEY_DOWN,              self.OnKeyDown)

        # Brace Completion stuff
        self.brace_dict={40:')',
                         91:']',
                         123:'}',
                         39:"'",
                         34:'"'}

        self.Bind(wx.stc.EVT_STC_CHARADDED, self.OnCharAdded) # When a character is added to the stc

        # AutoComplete Images
        self.RegisterImage(5, wx.Image(self.imgstcDir + os.sep + 'wizardhat16.png', wx.BITMAP_TYPE_PNG).ConvertToBitmap())

        ''' Mouse Gestures...Visualize your numpad and start drawing from 5 to an outside number. 9 possible events
        # [7][8][9]
        # [4][5][6]
        # [1][2][3] '''
        # rmouse
        self.rmousegesture = MouseGestures(self, Auto=True, MouseButton=wx.MOUSE_BTN_RIGHT)#wx.MOUSE_BTN_LEFT,wx.MOUSE_BTN_RIGHT
        self.rmousegesture.AddGesture('L', self.OnRMouseGestureMenu4, 'You moved left')
        self.rmousegesture.AddGesture('R', self.OnRMouseGestureMenu6, 'You moved right')
        self.rmousegesture.AddGesture('U', self.OnRMouseGestureMenu8, 'You moved up')
        self.rmousegesture.AddGesture('D', self.OnRMouseGestureMenu2, 'You moved down')
        # the diag gestures
        self.rmousegesture.AddGesture('1', self.OnRMouseGestureMenu1, 'You moved left/down  diag1')
        self.rmousegesture.AddGesture('3', self.OnRMouseGestureMenu3, 'You moved right/down diag3')
        self.rmousegesture.AddGesture('7', self.OnRMouseGestureMenu7, 'You moved left/up    diag7')
        self.rmousegesture.AddGesture('9', self.OnRMouseGestureMenu9, 'You moved right/up   diag9')
        self.rmousegesture.AddGesture('' , self.OnRMouseGestureMenuNone, 'Reg Context Menu')

        self.rmousegesture.SetGesturesVisible(True)
        self.rmousegesture.SetGesturePen(wx.Colour(230, 230, 76), 5)#(color, linepixelwidth)

        self.rect_selection_clipboard_flag = False #Set to false initially so that if upon open user tries to paste, it won't throw an error.

        self.IndicatorSetStyle(1,1)
        self.IndicatorSetForeground(1,'#FF0000')

        self.OnSetTheme(self)

        self.OnFolderMarginStyle4(self, '#FFFFFF', '#000000')#Hmmmm This is having problems changing correctly on startup again...
        self.OnSetFolderMarginStyle(self)#Hmmmm

    def OnSelectNone(self, event):
        ''' Select nothing in the document. (DeSelect) '''
        p = self.GetCurrentPos()
        self.SetSelection(p,p)

    def OnKeyDown(self, event):
        key = event.GetKeyCode()
        # print (key)
        event.Skip()#Removing this line will cause the keyboard to NOT function properly!

        # Handle the Non-STC Standard Keyboard Accelerators Here since there is no wx.Menu
        if key == 81 and event.ControlDown():#Ctrl+Q
            self.OnToggleComment(event)

        if key == 87 and event.ControlDown():#Ctrl+W
            self.OnShowWordCompleteBox(event)

        if key == 32 and event.ControlDown():
            # tips
            if event.ShiftDown():#Ctrl+Shift+Space
                self.OnShowSelectedTextCallTip(event)
            else:#Ctrl+Space
                self.OnShowAutoCompleteBox(event)

        if key == 315 and event.ControlDown() and event.ShiftDown():#Ctrl+Shift+Up
            self.OnMoveLineUp(event)

        if key == 317 and event.ControlDown() and event.ShiftDown():#Ctrl+Shift+Down
            self.OnMoveLineDown(event)

        if key == 343:#F4
            self.OnFindSelectedForwards(event)

        if key == 351:#F12
            self.OnToggleEditorThemes(event)

        ''' Auto-Adjust linenumber margin width'''
        if gGlobalsDict['ShowLineNumbersMargin'] == 1:
            if gGlobalsDict['AutoAdjustLineMargin'] == 1:
                totallines = self.GetLineCount()
                if totallines < 99:
                    self.SetMarginWidth(2, 22)  #3 digits using a small mono font (22 pixels). Good up to 99
                elif totallines < 999:
                    self.SetMarginWidth(2, 30)  #4 digits using a small mono font (30 pixels). Good up to 999
                elif totallines < 9999:
                    self.SetMarginWidth(2, 40)  #5 digits using a small mono font (40 pixels). Good up to 9999

        if key == 27: self.OnSelectNone(event) #Escape doesn't like accelerators on windows for some reason...

    def OnUpdateUI(self, event):
        ''' If the text, the styling, or the selection has been changed, This is bound by stc.EVT_STC_UPDATEUI above.
            Used to update any GUI elements that should change as a result. Also for other tasks that can be performed using background processing. '''

        '''Responsible for the bad brace check feature.'''
        # check for matching braces
        braceatcaret = -1
        braceopposite = -1
        charbefore = None
        caretpos = self.GetCurrentPos()
        if caretpos > 0:
            charbefore = self.GetCharAt(caretpos - 1)
            styleBefore = self.GetStyleAt(caretpos - 1)
        # check before
        if charbefore and chr(charbefore) in '[]{}()'\
                and styleBefore == stc.STC_P_OPERATOR:
            braceatcaret = caretpos - 1
        # check after
        if braceatcaret < 0:
            charafter = self.GetCharAt(caretpos)
            styleafter = self.GetStyleAt(caretpos)

            if charafter and chr(charafter) in '[]{}()'\
                    and styleafter == stc.STC_P_OPERATOR:
                braceatcaret = caretpos
        if braceatcaret >= 0:
            braceopposite = self.BraceMatch(braceatcaret)
        if braceatcaret != -1  and braceopposite == -1:
            self.BraceBadLight(braceatcaret)
        else:
            self.BraceHighlight(braceatcaret, braceopposite)

        # Caret Line Margin
        lineclicked = self.LineFromPosition(event.GetPosition())
        linecount = self.GetLineCount()
        for i in range(0,linecount+1):
            self.MarkerDelete(i, 0)
        self.MarkerAdd(self.GetCurrentLine(), 0)

    def OnMarginClick(self, event):
        # Fold and unfold as needed
        if event.GetMargin() == 3:
            if event.GetShift() and event.GetControl():
                self.OnFoldAll()
            else:
                lineClicked = self.LineFromPosition(event.GetPosition())
                if self.GetFoldLevel(lineClicked) &\
                        stc.STC_FOLDLEVELHEADERFLAG:
                    if event.GetShift():
                        self.SetFoldexpanded(lineClicked, True)
                        self.OnExpand(lineClicked, True, True, 1)
                    elif event.GetControl():
                        if self.GetFoldexpanded(lineClicked):
                            self.SetFoldexpanded(lineClicked, False)
                            self.OnExpand(lineClicked, False, True, 0)
                        else:
                            self.SetFoldexpanded(lineClicked, True)
                            self.OnExpand(lineClicked, True, True, 100)
                    else:
                        self.ToggleFold(lineClicked)
        # Bookmark Margin
        if event.GetMargin() == 1:
            lineClicked = self.LineFromPosition(event.GetPosition())
            if self.MarkerGet(lineClicked):
                self.MarkerDelete(lineClicked, 1)
            else:
                self.MarkerAdd(lineClicked, 1)

    def OnFoldAll(self):
        ''' folding folds, marker - to + '''
        lineCount = self.GetLineCount()
        expanding = True
        # Find out if folding or unfolding
        for lineNum in range(lineCount):
            if self.GetFoldLevel(lineNum) &\
                    stc.STC_FOLDLEVELHEADERFLAG:
                expanding = not self.GetFoldExpanded(lineNum)
                break;
        lineNum = 0
        while lineNum < lineCount:
            level = self.GetFoldLevel(lineNum)
            if level & stc.STC_FOLDLEVELHEADERFLAG and \
               (level & stc.STC_FOLDLEVELNUMBERMASK) ==\
                    stc.STC_FOLDLEVELBASE:
                if expanding:
                    self.SetFoldExpanded(lineNum, True)
                    lineNum = self.OnExpand(lineNum, True)
                    lineNum = lineNum - 1
                else:
                    lastChild = self.GetLastChild(lineNum, -1)
                    self.SetFoldExpanded(lineNum, False)
                    if lastChild > lineNum:
                        self.HideLines(lineNum+1, lastChild)
            lineNum = lineNum + 1

    def OnExpand(self, line, doexpand, force=False, visLevels=0, level=-1):
        ''' Expanding folds, marker + to - '''
        lastChild = self.GetLastChild(line, level)
        line = line + 1
        while line <= lastChild:
            if force:
                if visLevels > 0:
                    self.ShowLines(line, line)
                else:
                    self.HideLines(line, line)
            else:
                if doexpand:
                    self.ShowLines(line, line)
            if level == -1:
                level = self.GetFoldLevel(line)
            if level & stc.STC_FOLDLEVELHEADERFLAG:
                if force:
                    if visLevels > 1:
                        self.SetFoldexpanded(line, True)
                    else:
                        self.SetFoldexpanded(line, False)
                    line = self.OnExpand(line, doexpand, force, visLevels-1)
                else:
                    if doexpand and self.GetFoldexpanded(line):
                        line = self.OnExpand(line, True, force, visLevels-1)
                    else:
                        line = self.OnExpand(line, False, force, visLevels-1)
            else:
                line = line + 1;
        return line

    def OnCharAdded(self, event):
        ''' Brace Completion. If the feature is enabled, it adds a closing brace at the current caret/cursor position. '''
        key = event.GetKey()
        if gGlobalsDict['BraceCompletion'] == 1:
            if key in [40,91,123,39,34]: #These numbers are the keycodes of the braces defined above: ( [ { ' " (the first half of them)
                self.AddText(self.brace_dict[key])
                self.CharLeft()

    def OnSelectAll(self, event):
        self.SelectAll()

    def OnUndo(self,event):
        ''' Undo one action in the undo history. '''
        if self.CanUndo() == 1:
            self.Undo()

    def OnRedo(self,event):
        ''' Redoes the next action on the undo history. '''
        if self.CanRedo() == 1:
            self.Redo()

    def OnCut(self, event):
        ''' Cut the selection to the clipboard and explicitly set the rect_selection_clipboard_flag for each pass. '''
        if self.SelectionIsRectangle():
            self.rect_selection_clipboard_flag = True
            # print ('rect_selection_clipboard_flag = True')
        else:
            self.rect_selection_clipboard_flag = False
            # print ('rect_selection_clipboard_flag = False')
        self.Cut()

    def OnCopy(self, event):
        ''' Copy the selection to the clipboard and explicitly set the rect_selection_clipboard_flag for each pass. '''
        if self.SelectionIsRectangle():
            self.rect_selection_clipboard_flag = True
            # print ('rect_selection_clipboard_flag = True')
        else:
            self.rect_selection_clipboard_flag = False
            # print ('rect_selection_clipboard_flag = False')
        self.Copy()

    def OnCopyAll(self, event):
        self.SelectAll()
        self.Copy()

    def OnPaste(self, event):
        ''' Paste the contents of the clipboard into the document replacing the selection.
        or Override CmdKeyExecute if the rect_selection_clipboard_flag is set. '''
        if self.CanPaste() == 1: #Will a paste succeed? 1 For Yes, 0 for No.
            if self.rect_selection_clipboard_flag:
                self.OnColumnPaste(event)
            else:
                self.Paste() # or self.CmdKeyExecute(stc.STC_CMD_PASTE)
        elif self.CanPaste() == 0:
            wx.Bell()
            # print ('This Paste can\'t succeed.')

    def OnColumnPaste(self, event):
        if self.rect_selection_clipboard_flag:
            self.BeginUndoAction()
            data_obj = wx.TextDataObject() # Create the data object we'll use to store the clipboard data.
            wx.TheClipboard.Open()
            if wx.TheClipboard.GetData(data_obj): # Continue only if there's data in the clipboard...
                if self.SelectionIsRectangle():
                    self.DeleteBackNotLine() # Delete what is selected before rectangular/column pasting.
                text = data_obj.GetText() # Get the text from the clipboard.
                ind = 0
                pos = self.GetCurrentPos()
                oldpos = pos
                line = self.GetCurrentLine()
                col = self.GetColumn(self.GetCurrentPos())
                while text.find('\n', ind) != -1:
                        newind = text.find('\n', ind)
                        self.AddText(text[ind:newind - 1])
                        self.GotoPos(pos)
                        self.LineDown() #or self.CmdKeyExecute (wx.stc.STC_CMD_LINEDOWN)
                        pos = self.GetCurrentPos()
                        line += 1
                        ind = newind + 1
                self.GotoPos(oldpos) # Move the caret back to original start pos.
            wx.TheClipboard.Close()
            self.EndUndoAction()

    def OnDelete(self, event):
        ''' Clear the selection. '''
        self.Clear()

    def OnRemoveTrailingWhitespace(self, event):
        '''Eliminates/Removes all trailing/extra whitespace characters from the end of each line in the whole document.'''
        self.BeginUndoAction()
        curline = self.GetCurrentLine()
        firstvisline = self.GetFirstVisibleLine()
        endofdoc = self.GetLength()

        stripedlist = []
        for line in range(0, self.GetLineCount()):
            linetext = self.GetLine(line)
            striped = linetext.rstrip()
            stripedlist.append(striped)

        self.ClearAll()
        totallines = len(stripedlist)
        count = 0
        for stripedline in stripedlist:
            count += 1
            if count == totallines:#lastline don't add extra newline
                self.AppendText(stripedline)
            elif stripedline == '':
                self.AppendText('\n')
            else:
                self.AppendText(stripedline + '\n')

        self.GotoLine(curline)
        secondvisline = self.GetFirstVisibleLine()
        # Retain the topline & line of the doc before striping
        for i in range(0, (firstvisline - secondvisline)):
            self.LineScrollDown()
        self.EndUndoAction()

    def OnSaveAsProjectsWizard(self, event):
        self.ConvertEOLs(2)#Unix. LF. Fix for Mixed EOL problem
        try:
            dir = gInstallers.data.dir
            packagename = gInstallers.gPackage.GetValue()
            # print dir
            # print packagename

            projectpath = u'%s%s%s' %(dir, os.sep, packagename)
            wizpath = u'%s%s%s%swizard.txt' %(dir, os.sep, packagename, os.sep)
            # print wizpath

            if packagename == '':#Don't save the wizard in the Bash Installers dir
                wx.MessageBox(u'Select a package first!', u'ERROR', wx.ICON_ERROR | wx.OK)
                wx.Bell()
            elif packagename.startswith(u'==') and packagename.endswith(u'=='):
                if not os.path.exists(projectpath):
                    wx.MessageBox(u'You can\'t save a wizard to a marker', u'ERROR', wx.ICON_ERROR | wx.OK)
                    wx.Bell()
                else:
                    somefile = open(wizpath, 'w')
                    somefile.write(self.GetTextUTF8())
                    # print ('Saved Document.')
                    somefile.close()
                    # self.SetSavePoint() #Don't use this here. If user immediately clicks on another package afterwards, infos won't get saved as this resets the Modify Flag.
            elif os.path.exists(projectpath):
                somefile = open(wizpath, 'w')
                somefile.write(self.GetTextUTF8())
                # print ('Saved Document.')
                somefile.close()
                # self.SetSavePoint() #Don't use this here. If user immediately clicks on another package afterwards, infos won't get saved as this resets the Modify Flag.
        except:
            wx.MessageBox(u'Error in saving file.', u'ERROR', wx.ICON_ERROR | wx.OK)
            wx.Bell()

    def OnTextToWizardStringFileDropMiniFrame(self, event):
        texttowizardstringminiframe = wx.MiniFrame(self, -1, u'Text To Wizard String (File Drop)', style=wx.DEFAULT_FRAME_STYLE | wx.FRAME_FLOAT_ON_PARENT, size=(300, 150))

        texttowizardstringminiframe.SetSizeHints(200,150)

        texttowizardstringminiframe.textctrl1 = TextToWizardStringSTC(texttowizardstringminiframe)
        msg = u'Drag & Drop the textfile into this miniframe. \nIt will automatically be converted to a wizard string! \nYou can then SelectAll, Cut, Paste it into the Editor. \nThis is useful for readmes, etc...'
        try:
            texttowizardstringminiframe.textctrl1.SetText(msg)
        except:
            texttowizardstringminiframe.textctrl1.SetTextUTF8(msg)
        texttowizardstringminiframe.textctrl1.EmptyUndoBuffer()

        #Drag and Drop - File Drop
        filedroptarget = FileDropTargetForTextToWizardString(texttowizardstringminiframe.textctrl1)
        texttowizardstringminiframe.textctrl1.SetDropTarget(filedroptarget)

        texttowizardstringminiframe.Centre()
        texttowizardstringminiframe.Show()

    def OnTextToWizardStringTextDropMiniFrame(self, event):
        texttowizardstringtextdropminiframe = wx.MiniFrame(self, -1, u'Text To Wizard String (Text Drop)', style=wx.DEFAULT_FRAME_STYLE | wx.FRAME_FLOAT_ON_PARENT, size=(300, 150))

        texttowizardstringtextdropminiframe.SetSizeHints(200,150)

        texttowizardstringtextdropminiframe.textctrl1 = TextToWizardStringSTC(texttowizardstringtextdropminiframe)
        msg = u'Drag & Drop some text into this miniframe. \nIt will automatically be converted to a wizard string! \nYou can then SelectAll, Cut, Paste it into the Editor. \nThis is useful for text from a web page, some of the editor text, etc...'
        try:
            texttowizardstringtextdropminiframe.textctrl1.SetText(msg)
        except:
            texttowizardstringtextdropminiframe.textctrl1.SetTextUTF8(msg)
        texttowizardstringtextdropminiframe.textctrl1.EmptyUndoBuffer()

        #Drag and Drop - Text Drop
        textdroptarget = TextDropTargetForTextToWizardString(texttowizardstringtextdropminiframe.textctrl1)
        texttowizardstringtextdropminiframe.textctrl1.SetDropTarget(textdroptarget)

        texttowizardstringtextdropminiframe.Centre()
        texttowizardstringtextdropminiframe.Show()

    def OnContextMenu(self, event):
        ''' This handles making the context key still work and a none mouse gesture pull up the context without poping up again after a different mouse gesture menu. '''
        pass
        # print ('This is handled by OnRMouseGestureMenuNone')

    def OnHelpWizBAINEditorGeneral(self, event):
        message = (
        u'The WizBAIN Editor is for mod authors and players to write fancy install scripts for their packages(called wizards),'\
        u'thus easing headaches and confusion during installation by all users. The Editor is primarily mouse gesture/context '\
        u'menu based and may not be obvious to a casual or first time user.\nThe mouse gesture menus are based off of a NUMPad, '\
        u'such as are on many keyboards. NUMPad 5 would be the default right or middle click context. To access the other menus '\
        u'just mouse gesture outward from 5 to another number. An example of how to open the right click mouse gesture 8 menu(R MGM 8) '\
        u'would be to first right click and hold the mouse button down and move your mouse forward/up and release.\n'\
        u'The WizBAIN Editor is currently a WIPz\n'\
        u'\n'\
        u'[7][8][9]\n'\
        u'[4][5][6]\n'\
        u'[1][2][3]\n'\
        u'\n'\
        u'\n'\
        u'Enjoy ~Metallicow, TES4WizBAIN Dev\n'
        )

        dialog = wx.lib.dialogs.ScrolledMessageDialog(self, message, u'WizBAIN Editor Help-General', size=(500, 350))
        dialog.SetIcon(wx.Icon(self.imgstcDir + os.sep + '..' + os.sep + 'help16.png', wx.BITMAP_TYPE_PNG))
        dialog.ShowModal()
        dialog.Destroy()

    def OnHelpWizBAINEditorAPIDocStrings(self, event):
        ''' print the doctrings of the fuction for help '''

        functionlist = [self.OnToggleComment,self.OnUPPERCASE,self.Onlowercase,self.OnInvertCase,self.OnCapitalCase]
        message = ''
        for function in functionlist:
            message += function.__name__ # ''' bla bla bla docstring '''
            message += '\n'
            message += function.__doc__ # ''' bla bla bla docstring '''
            message += '\n'
            message += '\n'

        dialog = wx.lib.dialogs.ScrolledMessageDialog(self, u'%s' %message, u'WizBAIN Editor API Doc Strings', size=(500, 350))
        dialog.SetIcon(wx.Icon(self.imgstcDir + os.sep + '..' + os.sep + 'help16.png', wx.BITMAP_TYPE_PNG))
        dialog.ShowModal()
        dialog.Destroy()

    def OnToggleComment(self, event):
        ''' Toggle commenting on current or selected line(s) - ;#'''
        self.BeginUndoAction()
        selstart = self.GetSelectionStart()
        selend = self.GetSelectionEnd()
        line = self.LineFromPosition(self.GetCurrentPos())
        # print ('char1: ' + str(self.GetCharAt(self.GetLineIndentPosition(line))))

        if selstart == selend:
            # print('Nothing Selected - Toggle Comment Single Line')
            retainposafterwards = self.GetCurrentPos()
            if self.GetCharAt(self.GetLineIndentPosition(line)) == 10:
                pass
                # print ('line:' + str(line+1) + ' is blank LF') # char is LF EOL.
            elif self.GetCharAt(self.GetLineIndentPosition(line)) == 13:
                pass
                # print ('line:' + str(line+1) + ' is blank CR') # char is CR EOL.
            elif self.GetCharAt(self.GetLineIndentPosition(line)) == 0:
                pass
                # print ('line:' + str(line+1) + ' is blank nothing') # char is nothing. end of doc
            elif gGlobalsDict['LoadSTCLexer'] == 'wizbainlexer':
                if self.GetCharAt(self.GetLineIndentPosition(line)) == 59: # char is ;
                    if self.GetCharAt(self.GetLineIndentPosition(line) + 1) == 35: # char is #
                        if self.GetCharAt(self.GetLineIndentPosition(line) + 2) == 32: # char is space
                            # print ('wizbain commented line')
                            self.GotoPos(self.GetLineIndentPosition(line) + 3)
                            for i in range(0,3):
                                self.DeleteBackNotLine()
                            self.GotoPos(retainposafterwards - 3)
                else:
                    self.GotoPos(self.GetLineIndentPosition(line))
                    self.AddText(u';# ')
                    self.GotoPos(retainposafterwards + 3)
        else:
            # print('Toggle Comment On Selected Lines')
            startline = self.LineFromPosition(selstart)
            endline = self.LineFromPosition(selend)
            for i in range(startline, endline + 1):
                # print ('line:' + str(i + 1) + ' ' + str(self.GetLine(i)))

                if self.GetCharAt(self.GetLineIndentPosition(i)) == 10:
                    pass
                    # print ('line:' + str(i+1) + ' is blank LF') # char is LF EOL.
                elif self.GetCharAt(self.GetLineIndentPosition(i)) == 13:
                    pass
                    # print ('line:' + str(i+1) + ' is blank CR') # char is CR EOL.
                elif self.GetCharAt(self.GetLineIndentPosition(i)) == 0:
                    pass
                    # print ('line:' + str(i+1) + ' is blank nothing') # char is nothing. end of doc
                elif gGlobalsDict['LoadSTCLexer'] == 'wizbainlexer':
                    if self.GetCharAt(self.GetLineIndentPosition(i)) == 59: # char is ;
                        if self.GetCharAt(self.GetLineIndentPosition(i) + 1) == 35: # char is #
                            if self.GetCharAt(self.GetLineIndentPosition(i) + 2) == 32: # char is space
                                # print ('wizbain commented line')
                                self.GotoPos(self.GetLineIndentPosition(i) + 3)
                                for i in range(0,3):
                                    self.DeleteBackNotLine()
                                currentline = self.GetCurrentLine()
                                self.SetSelection(self.GetLineEndPosition(currentline),selstart)
                    else:
                        self.GotoPos(self.GetLineIndentPosition(i))
                        self.AddText(u';# ')

                        self.SetSelection(self.GetLineEndPosition(self.LineFromPosition(self.GetCurrentPos())),selstart)
                else:
                    print ('Huh')
        self.EndUndoAction()
        #print ('OnToggleComment might need some more work.')

    def OnUPPERCASE(self, event):
        '''Converts selection to UPPERCASE.'''
        self.UpperCase()
        #print ('OnUPPERCASE')

    def Onlowercase(self, event):
        '''Converts selection to lowercase.'''
        self.LowerCase()
        #print ('Onlowercase')

    def OnInvertCase(self, event):
        '''Inverts the case of the selected text.'''
        getsel = self.GetSelection()
        selectedtext = self.GetSelectedText()
        if len(selectedtext):
            self.BeginUndoAction()
            self.ReplaceSelection(selectedtext.swapcase())
            self.SetSelection(getsel[1],getsel[0])#Keep the text selected afterwards retaining caret pos
            self.EndUndoAction()
        #print ('OnInvertCase')

    def OnCapitalCase(self, event):
        '''Capitalizes the first letter of each word of the selected text.'''
        self.BeginUndoAction()
        self.Onlowercase(event)
        getsel = self.GetSelection()
        text = self.GetSelectedText()
        if len(text) > 0:
            s=[]
            word = False
            for character in text:
                if 'a' <= character.lower() <= 'z':
                    if word == False:
                        character = character.upper()
                        word = True
                else:
                    if word == True:
                        word = False
                s.append(character)
            text = ''.join(s)
            self.BeginUndoAction()
            self.ReplaceSelection(text)
            self.SetSelection(getsel[1],getsel[0])#Keep the text selected afterwards retaining caret pos
            self.EndUndoAction()
        self.EndUndoAction()
        #print ('OnCapitalCase')

    def OnRMouseGestureMenuNone(self, event):
        rightclickmenu = wx.Menu()

        p = wx.BITMAP_TYPE_PNG

        rcheader1 = wx.MenuItem(rightclickmenu, 0000, u'R MGM 5', u'ContextMenu5')
        rcheader1.SetBackgroundColour('#000000')
        rightclickmenu.AppendItem(rcheader1)
        rcheader1.SetDisabledBitmap(wx.Image(self.imgstcDir + os.sep + ('mousebuttonright16.png'),p).ConvertToBitmap())
        rcheader1.Enable(False)

        submenu = wx.Menu()
        mgm1 = wx.MenuItem(rightclickmenu, 3001, u'&R MGM 1', u' Call Mouse Gesture Menu 1')
        mgm1.SetBitmap(wx.Image(self.imgstcDir + os.sep + ('mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm1)

        mgm2 = wx.MenuItem(rightclickmenu, 3002, u'&R MGM 2 Wizard', u' Call Mouse Gesture Menu 2')
        mgm2.SetBitmap(wx.Image(self.imgstcDir + os.sep + ('mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm2)

        mgm3 = wx.MenuItem(rightclickmenu, 3003, u'&R MGM 3', u' Call Mouse Gesture Menu 3')
        mgm3.SetBitmap(wx.Image(self.imgstcDir + os.sep + ('mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm3)

        mgm4 = wx.MenuItem(rightclickmenu, 3004, u'&R MGM 4 Case', u' Call Mouse Gesture Menu 4')
        mgm4.SetBitmap(wx.Image(self.imgstcDir + os.sep + ('mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm4)

        mgm5 = wx.MenuItem(rightclickmenu, 3005, u'&R MGM 5 You Are Here!', u' Call Mouse Gesture Menu 5')
        mgm5.SetBitmap(wx.Image(self.imgstcDir + os.sep + ('youarehere16.png'),p).ConvertToBitmap())
        mgm5.SetBackgroundColour('#F4FAB4')
        mgm5.Enable(False)
        submenu.AppendItem(mgm5)

        mgm6 = wx.MenuItem(rightclickmenu, 3006, u'&R MGM 6 Conversion', u' Call Mouse Gesture Menu 6')
        mgm6.SetBitmap(wx.Image(self.imgstcDir + os.sep + ('mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm6)

        mgm7 = wx.MenuItem(rightclickmenu, 3007, u'&R MGM 7', u' Call Mouse Gesture Menu 7')
        mgm7.SetBitmap(wx.Image(self.imgstcDir + os.sep + ('mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm7)

        mgm8 = wx.MenuItem(rightclickmenu, 3008, u'&R MGM 8', u' Call Mouse Gesture Menu 8')
        mgm8.SetBitmap(wx.Image(self.imgstcDir + os.sep + ('mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm8)

        mgm9 = wx.MenuItem(rightclickmenu, 3009, u'&R MGM 9 Options', u' Call Mouse Gesture Menu 9')
        mgm9.SetBitmap(wx.Image(self.imgstcDir + os.sep + ('mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm9)
        rightclickmenu.AppendMenu(wx.NewId(), u'Mouse Gesture Menus', submenu)

        rightclickmenu.AppendSeparator()
        undo = wx.MenuItem(rightclickmenu, 2001, u'&Undo\tCtrl+Z', u' Undo last modifications')
        undo.SetBitmap(wx.Image(self.imgstcDir + os.sep + ('undo16.png'),p).ConvertToBitmap())
        rightclickmenu.AppendItem(undo)
        if self.CanUndo() == 0:   undo.Enable(False)#trying to disable a menu item before it's appended to the menu doesn't work.
        elif self.CanUndo() == 1: undo.Enable(True)
        redo = wx.MenuItem(rightclickmenu, 2002, u'&Redo\tCtrl+Y', u' Redo last modifications')
        redo.SetBitmap(wx.Image(self.imgstcDir + os.sep + ('redo16.png'),p).ConvertToBitmap())
        rightclickmenu.AppendItem(redo)
        if self.CanRedo() == 0:   redo.Enable(False)
        elif self.CanRedo() == 1: redo.Enable(True)
        rightclickmenu.AppendSeparator()
        cut = wx.MenuItem(rightclickmenu, 2004, u'&Cut\tCtrl+X', u' Cut selected text')
        cut.SetBitmap(wx.Image(self.imgstcDir + os.sep + ('cut16.png'),p).ConvertToBitmap())
        rightclickmenu.AppendItem(cut)
        copy = wx.MenuItem(rightclickmenu, 2005, u'&Copy\tCtrl+C', u' Copy selected text')
        copy.SetBitmap(wx.Image(self.imgstcDir + os.sep + ('copy16.png'),p).ConvertToBitmap())
        rightclickmenu.AppendItem(copy)
        paste = wx.MenuItem(rightclickmenu, 2006, u'&Paste\tCtrl+V', u' Paste from clipboard')
        paste.SetBitmap(wx.Image(self.imgstcDir + os.sep + ('paste16.png'),p).ConvertToBitmap())
        rightclickmenu.AppendItem(paste)
        if self.CanPaste() == 0:   paste.Enable(False)
        elif self.CanPaste() == 1: paste.Enable(True)
        delete = wx.MenuItem(rightclickmenu, 2007, u'&Delete', u' Delete selected text')
        delete.SetBitmap(wx.Image(self.imgstcDir + os.sep + ('delete16.png'),p).ConvertToBitmap())
        rightclickmenu.AppendItem(delete)
        rightclickmenu.AppendSeparator()
        selectall = wx.MenuItem(rightclickmenu, 2010, u'&Select All\tCtrl+A', u' Select All Text in Document')
        selectall.SetBitmap(wx.Image(self.imgstcDir + os.sep + ('selectall2416.png'),p).ConvertToBitmap())
        rightclickmenu.AppendItem(selectall)

        rightclickmenu.AppendSeparator()

        togglecomment = wx.MenuItem(rightclickmenu, 4006, u'&Toggle Comment\tCtrl+Q', u' Toggle Commenting on the selected line(s)')
        togglecomment.SetBitmap(wx.Image(self.imgstcDir + os.sep + ('togglecomment16.png'),p).ConvertToBitmap())
        rightclickmenu.AppendItem(togglecomment)

        removetrailingwhitespace = wx.MenuItem(rightclickmenu, 4013, u'&Remove Trailing Whitespace', u' Remove trailing whitespace from end of lines in the document')
        removetrailingwhitespace.SetBitmap(wx.Image(self.imgstcDir + os.sep + ('removetrailingspaces16.png'),p).ConvertToBitmap())
        rightclickmenu.AppendItem(removetrailingwhitespace)

        rightclickmenu.AppendSeparator()

        submenu = wx.Menu()
        saveasprojectwizard = wx.MenuItem(rightclickmenu, 1001, u'&Save as this project\'s wizard', u' Save as Project\'s wizard.txt')
        saveasprojectwizard.SetBitmap(wx.Image(self.imgstcDir + os.sep + ('save16.png'),p).ConvertToBitmap())
        submenu.AppendItem(saveasprojectwizard)
        rightclickmenu.AppendMenu(wx.NewId(), u'File', submenu)

        submenu = wx.Menu()
        helpwizbaineditorgeneral = wx.MenuItem(rightclickmenu, 1901, u'&WizBAIN Editor General', u' Help explaining general features')
        helpwizbaineditorgeneral.SetBitmap(wx.Image(self.imgDir + os.sep + ('help16.png'),p).ConvertToBitmap())
        submenu.AppendItem(helpwizbaineditorgeneral)

        helpwizbaineditorgeneral = wx.MenuItem(rightclickmenu, 1902, u'&WizBAIN Editor API Doc Strings', u' Help explaining the function performed upon execution')
        helpwizbaineditorgeneral.SetBitmap(wx.Image(self.imgDir + os.sep + ('help16.png'),p).ConvertToBitmap())
        submenu.AppendItem(helpwizbaineditorgeneral)
        rightclickmenu.AppendMenu(wx.NewId(), u'Help', submenu)

        #events
        wx.EVT_MENU(rightclickmenu, 1001, self.OnSaveAsProjectsWizard)

        wx.EVT_MENU(rightclickmenu, 1901, self.OnHelpWizBAINEditorGeneral)
        wx.EVT_MENU(rightclickmenu, 1902, self.OnHelpWizBAINEditorAPIDocStrings)

        wx.EVT_MENU(rightclickmenu, 2001, self.OnUndo)
        wx.EVT_MENU(rightclickmenu, 2002, self.OnRedo)
        wx.EVT_MENU(rightclickmenu, 2004, self.OnCut)
        wx.EVT_MENU(rightclickmenu, 2005, self.OnCopy)
        wx.EVT_MENU(rightclickmenu, 2006, self.OnPaste)
        wx.EVT_MENU(rightclickmenu, 2007, self.OnDelete)
        wx.EVT_MENU(rightclickmenu, 2010, self.OnSelectAll)
        wx.EVT_MENU(rightclickmenu, 4006, self.OnToggleComment)
        wx.EVT_MENU(rightclickmenu, 4013, self.OnRemoveTrailingWhitespace)

        wx.EVT_MENU(rightclickmenu, 3001, self.OnRMouseGestureMenu1)
        wx.EVT_MENU(rightclickmenu, 3002, self.OnRMouseGestureMenu2)
        wx.EVT_MENU(rightclickmenu, 3003, self.OnRMouseGestureMenu3)
        wx.EVT_MENU(rightclickmenu, 3004, self.OnRMouseGestureMenu4)
        wx.EVT_MENU(rightclickmenu, 3005, self.OnRMouseGestureMenuNone)
        wx.EVT_MENU(rightclickmenu, 3006, self.OnRMouseGestureMenu6)
        wx.EVT_MENU(rightclickmenu, 3007, self.OnRMouseGestureMenu7)
        wx.EVT_MENU(rightclickmenu, 3008, self.OnRMouseGestureMenu8)
        wx.EVT_MENU(rightclickmenu, 3009, self.OnRMouseGestureMenu9)

        self.PopupMenu(rightclickmenu)
        rightclickmenu.Destroy()

    def OnRMouseGestureMenu1(self, event):
        rightclickmenu = wx.Menu()

        p = wx.BITMAP_TYPE_PNG

        rcheader1 = wx.MenuItem(rightclickmenu, 0000, u'R MGM 1', u'ContextMenu1')
        rcheader1.SetBackgroundColour('#000000')
        rightclickmenu.AppendItem(rcheader1)
        rcheader1.SetDisabledBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousebuttonright16.png'),p).ConvertToBitmap())
        rcheader1.Enable(False)

        submenu = wx.Menu()
        mgm1 = wx.MenuItem(rightclickmenu, 3001, u'&R MGM 1 You Are Here!', u' Call Mouse Gesture Menu 1')
        mgm1.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'youarehere16.png'),p).ConvertToBitmap())
        mgm1.SetBackgroundColour('#F4FAB4')
        mgm1.Enable(False)
        submenu.AppendItem(mgm1)

        mgm2 = wx.MenuItem(rightclickmenu, 3002, u'&R MGM 2 Wizard', u' Call Mouse Gesture Menu 2')
        mgm2.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm2)

        mgm3 = wx.MenuItem(rightclickmenu, 3003, u'&R MGM 3', u' Call Mouse Gesture Menu 3')
        mgm3.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm3)

        mgm4 = wx.MenuItem(rightclickmenu, 3004, u'&R MGM 4 Case', u' Call Mouse Gesture Menu 4')
        mgm4.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm4)

        mgm5 = wx.MenuItem(rightclickmenu, 3005, u'&R MGM 5', u' Call Mouse Gesture Menu 5')
        mgm5.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm5)

        mgm6 = wx.MenuItem(rightclickmenu, 3006, u'&R MGM 6 Conversion', u' Call Mouse Gesture Menu 6')
        mgm6.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm6)

        mgm7 = wx.MenuItem(rightclickmenu, 3007, u'&R MGM 7', u' Call Mouse Gesture Menu 7')
        mgm7.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm7)

        mgm8 = wx.MenuItem(rightclickmenu, 3008, u'&R MGM 8 Line Operations', u' Call Mouse Gesture Menu 8')
        mgm8.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm8)

        mgm9 = wx.MenuItem(rightclickmenu, 3009, u'&R MGM 9 Options', u' Call Mouse Gesture Menu 9')
        mgm9.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm9)
        rightclickmenu.AppendMenu(wx.NewId(), u'Mouse Gesture Menus', submenu)

        rightclickmenu.AppendSeparator()

        sort = wx.MenuItem(rightclickmenu, 1097, u'&Sort...', u' Sort selected lines in the active document')
        sort.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'sort16.png',p).ConvertToBitmap())
        rightclickmenu.AppendItem(sort)

        findselectedforwards = wx.MenuItem(rightclickmenu, 1099, u'&Find Selected Forwards\tF4', u' Find selected text forwards')
        findselectedforwards.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'arrowdownbw16.png',p).ConvertToBitmap())
        rightclickmenu.AppendItem(findselectedforwards)

        #events
        wx.EVT_MENU(rightclickmenu, 1097, self.OnSort)
        wx.EVT_MENU(rightclickmenu, 1099, self.OnFindSelectedForwards)

        wx.EVT_MENU(rightclickmenu, 3001, self.OnRMouseGestureMenu1)
        wx.EVT_MENU(rightclickmenu, 3002, self.OnRMouseGestureMenu2)
        wx.EVT_MENU(rightclickmenu, 3003, self.OnRMouseGestureMenu3)
        wx.EVT_MENU(rightclickmenu, 3004, self.OnRMouseGestureMenu4)
        wx.EVT_MENU(rightclickmenu, 3005, self.OnRMouseGestureMenuNone)
        wx.EVT_MENU(rightclickmenu, 3006, self.OnRMouseGestureMenu6)
        wx.EVT_MENU(rightclickmenu, 3007, self.OnRMouseGestureMenu7)
        wx.EVT_MENU(rightclickmenu, 3008, self.OnRMouseGestureMenu8)
        wx.EVT_MENU(rightclickmenu, 3009, self.OnRMouseGestureMenu9)

        self.PopupMenu(rightclickmenu)
        rightclickmenu.Destroy()

    def OnSort(self, event):
        self.BeginUndoAction()
        linestring = str(self.GetSelectedText())
        linestringlist = linestring.split('\n')
        length = len(linestringlist)

        if self.GetSelectionStart() == self.GetSelectionEnd():
            wx.MessageBox('No Text Selected!', 'Sort Error', wx.OK|wx.ICON_ERROR)
        else:
            dialog = wx.SingleChoiceDialog(self, "How do you want to sort the selection?", 'Sort...',
                    ['Ascending Case Sensitive', 'Ascending Case insensitive', 'Descending Case Sensitive', 'Descending Case insensitive', 'Randomly'],
                    wx.CHOICEDLG_STYLE)

            if dialog.ShowModal() == wx.ID_OK:
                getsel = self.GetSelection()
                if dialog.GetStringSelection() == 'Ascending Case Sensitive':
                    linestringlist.sort()
                    for i in range(0,length-1):
                        self.ReplaceSelection(linestringlist[i] + '\n')
                    self.ReplaceSelection(linestringlist[length-1])
                elif dialog.GetStringSelection() == 'Ascending Case insensitive':
                    linestringlist.sort(key=str.lower)
                    for i in range(0,length-1):
                        self.ReplaceSelection(linestringlist[i] + '\n')
                    self.ReplaceSelection(linestringlist[length-1])
                elif dialog.GetStringSelection() == 'Descending Case Sensitive':
                    linestringlist.sort()
                    linestringlist.reverse()
                    for i in range(0,length-1):
                        self.ReplaceSelection(linestringlist[i] + '\n')
                    self.ReplaceSelection(linestringlist[length-1])
                elif dialog.GetStringSelection() == 'Descending Case insensitive':
                    linestringlist.sort(key=str.lower)
                    linestringlist.reverse()
                    for i in range(0,length-1):
                        self.ReplaceSelection(linestringlist[i] + '\n')
                    self.ReplaceSelection(linestringlist[length-1])
                elif dialog.GetStringSelection() == 'Randomly':
                    r = []
                    for i in range(self.LineFromPosition(self.GetSelectionStart()),self.LineFromPosition(self.GetSelectionEnd()) + 1):
                        r.append(self.GetLine(i).rstrip())
                    random.shuffle(r)
                    self.DeleteBack()
                    for line in r:
                        self.AddText(line + '\n')
                    self.DeleteBack()
                self.SetSelection(getsel[1],getsel[0])#Keep the text selected afterwards retaining caret pos

            dialog.Destroy()
        self.EndUndoAction()

    def OnFindSelectedForwards(self, event):
        if self.GetSelectionStart() == self.GetSelectionEnd():
            pass
        else:
            try:
                val = self.GetSelectedText()
            except:
                val = self.GetSelectedTextUTF8()

            curpos = self.GetCurrentPos()
            findstring = self.FindText(curpos, self.GetLength(), val, flags=1)
            # print ('QF findstring = ' + str(findstring))

            if findstring != -1:
                self.GotoPos(findstring)
                self.SetSelection(findstring, findstring + len(val))
            else:
                try:
                    findstring = self.FindText(0, self.GetLength(), val, flags=1)
                    if findstring != -1:
                        self.GotoPos(findstring)
                        self.SetSelection(findstring, findstring + len(val))
                    else: wx.Bell()
                except:
                    pass#print ('Quick Find String Not Found')


    def OnRMouseGestureMenu2(self, event):
        rightclickmenu = wx.Menu()

        p = wx.BITMAP_TYPE_PNG

        rcheader1 = wx.MenuItem(rightclickmenu, 0000, u'R MGM 2 Wizard', u'ContextMenu2')
        rcheader1.SetBackgroundColour('#000000')
        rightclickmenu.AppendItem(rcheader1)
        rcheader1.SetDisabledBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousebuttonright16.png'),p).ConvertToBitmap())
        rcheader1.Enable(False)

        submenu = wx.Menu()
        mgm1 = wx.MenuItem(rightclickmenu, 3001, u'&R MGM 1', u' Call Mouse Gesture Menu 1')
        mgm1.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm1)

        mgm2 = wx.MenuItem(rightclickmenu, 3002, u'&R MGM 2 You Are Here!', u' Call Mouse Gesture Menu 2')
        mgm2.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'youarehere16.png'),p).ConvertToBitmap())
        mgm2.SetBackgroundColour('#F4FAB4')
        mgm2.Enable(False)
        submenu.AppendItem(mgm2)

        mgm3 = wx.MenuItem(rightclickmenu, 3003, u'&R MGM 3', u' Call Mouse Gesture Menu 3')
        mgm3.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm3)

        mgm4 = wx.MenuItem(rightclickmenu, 3004, u'&R MGM 4 Case', u' Call Mouse Gesture Menu 4')
        mgm4.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm4)

        mgm5 = wx.MenuItem(rightclickmenu, 3005, u'&R MGM 5', u' Call Mouse Gesture Menu 5')
        mgm5.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm5)

        mgm6 = wx.MenuItem(rightclickmenu, 3006, u'&R MGM 6 Conversion', u' Call Mouse Gesture Menu 6')
        mgm6.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm6)

        mgm7 = wx.MenuItem(rightclickmenu, 3007, u'&R MGM 7', u' Call Mouse Gesture Menu 7')
        mgm7.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm7)

        mgm8 = wx.MenuItem(rightclickmenu, 3008, u'&R MGM 8 Line Operations', u' Call Mouse Gesture Menu 8')
        mgm8.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm8)

        mgm9 = wx.MenuItem(rightclickmenu, 3009, u'&R MGM 9 Options', u' Call Mouse Gesture Menu 9')
        mgm9.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm9)
        rightclickmenu.AppendMenu(wx.NewId(), u'Mouse Gesture Menus', submenu)

        rightclickmenu.AppendSeparator()

        reqversky = wx.MenuItem(rightclickmenu, 2001, u'&RequireVersions Oblivion', u' RequireVersions "1.2.0.416","0.0.20.6","3.0.0.0","295"')
        reqversky.SetBitmap(wx.Image(self.imgDir + os.sep + (u'oblivion16.png'),p).ConvertToBitmap())
        rightclickmenu.AppendItem(reqversky)
        reqverob = wx.MenuItem(rightclickmenu, 2002, u'&RequireVersions Skyrim', u' RequireVersions "1.1.21.0","","","295"')
        reqverob.SetBitmap(wx.Image(self.imgDir + os.sep + (u'skyrim16.png'),p).ConvertToBitmap())
        rightclickmenu.AppendItem(reqverob)

        selectone = wx.MenuItem(rightclickmenu, 2003, u'&SelectOne', u' SelectOne "", \\')
        rightclickmenu.AppendItem(selectone)
        selectmany = wx.MenuItem(rightclickmenu, 2004, u'&SelectMany', u' SelectMany "", \\')
        rightclickmenu.AppendItem(selectmany)
        choicesx2 = wx.MenuItem(rightclickmenu, 2005, u'&"","","",\\ X2', u' "","","",\\ X2')
        rightclickmenu.AppendItem(choicesx2)
        endselect = wx.MenuItem(rightclickmenu, 2006, u'&EndSelect', u' EndSelect')
        rightclickmenu.AppendItem(endselect)
        case = wx.MenuItem(rightclickmenu, 2007, u'&Case', u' Case')
        rightclickmenu.AppendItem(case)
        bbreak = wx.MenuItem(rightclickmenu, 2008, u'&Break', u' Break')
        rightclickmenu.AppendItem(bbreak)
        selectall = wx.MenuItem(rightclickmenu, 2009, u'&SelectAll', u' SelectAll')
        rightclickmenu.AppendItem(selectall)
        deselectall = wx.MenuItem(rightclickmenu, 2010, u'&DeSelectAll', u' DeSelectAll')
        rightclickmenu.AppendItem(deselectall)
        selectsubpackage = wx.MenuItem(rightclickmenu, 2011, u'&SelectSubPackage', u' SelectSubPackage')
        rightclickmenu.AppendItem(selectsubpackage)
        deselectsubpackage = wx.MenuItem(rightclickmenu, 2012, u'&DeSelectSubPackage', u' DeSelectSubPackage')
        rightclickmenu.AppendItem(deselectsubpackage)
        selectespm = wx.MenuItem(rightclickmenu, 2013, u'&SelectEspm', u' SelectEspm')
        rightclickmenu.AppendItem(selectespm)
        selectallespms = wx.MenuItem(rightclickmenu, 2014, u'&SelectAllEspms', u' SelectAllEspms')
        rightclickmenu.AppendItem(selectallespms)
        deselectespm = wx.MenuItem(rightclickmenu, 2015, u'&DeSelectEspm', u' DeSelectEspm')
        rightclickmenu.AppendItem(deselectespm)
        deselectallespms = wx.MenuItem(rightclickmenu, 2016, u'&DeSelectAllEspms', u' DeSelectAllEspms')
        rightclickmenu.AppendItem(deselectallespms)
        renameespm = wx.MenuItem(rightclickmenu, 2017, u'&RenameEspm', u' RenameEspm')
        rightclickmenu.AppendItem(renameespm)
        resetespmname = wx.MenuItem(rightclickmenu, 2018, u'&ResetEspmName', u' ResetEspmName')
        rightclickmenu.AppendItem(resetespmname)
        resetallespmnames = wx.MenuItem(rightclickmenu, 2019, u'&ResetAllEspmNames', u' ResetAllEspmNames')
        rightclickmenu.AppendItem(resetallespmnames)

        #events
        wx.EVT_MENU(rightclickmenu, 2001, self.OnRequireVersionsOblivion)
        wx.EVT_MENU(rightclickmenu, 2002, self.OnRequireVersionsSkyrim)
        wx.EVT_MENU(rightclickmenu, 2003, self.OnSelectOne)
        wx.EVT_MENU(rightclickmenu, 2004, self.OnSelectMany)
        wx.EVT_MENU(rightclickmenu, 2005, self.OnChoicesX02)
        wx.EVT_MENU(rightclickmenu, 2006, self.OnEndSelect)
        wx.EVT_MENU(rightclickmenu, 2007, self.OnCase)
        wx.EVT_MENU(rightclickmenu, 2008, self.OnBreak)
        wx.EVT_MENU(rightclickmenu, 2009, self.OnSelectAll)
        wx.EVT_MENU(rightclickmenu, 2010, self.OnDeSelectAll)
        wx.EVT_MENU(rightclickmenu, 2011, self.OnSelectSubPackage)
        wx.EVT_MENU(rightclickmenu, 2012, self.OnDeSelectSubPackage)
        wx.EVT_MENU(rightclickmenu, 2013, self.OnSelectEspm)
        wx.EVT_MENU(rightclickmenu, 2014, self.OnSelectAllEspms)
        wx.EVT_MENU(rightclickmenu, 2015, self.OnDeSelectEspm)
        wx.EVT_MENU(rightclickmenu, 2016, self.OnDeSelectAllEspms)
        wx.EVT_MENU(rightclickmenu, 2017, self.OnRenameEspm)
        wx.EVT_MENU(rightclickmenu, 2018, self.OnResetEspmName)
        wx.EVT_MENU(rightclickmenu, 2019, self.OnResetAllEspmNames)

        wx.EVT_MENU(rightclickmenu, 3001, self.OnRMouseGestureMenu1)
        wx.EVT_MENU(rightclickmenu, 3002, self.OnRMouseGestureMenu2)
        wx.EVT_MENU(rightclickmenu, 3003, self.OnRMouseGestureMenu3)
        wx.EVT_MENU(rightclickmenu, 3004, self.OnRMouseGestureMenu4)
        wx.EVT_MENU(rightclickmenu, 3005, self.OnRMouseGestureMenuNone)
        wx.EVT_MENU(rightclickmenu, 3006, self.OnRMouseGestureMenu6)
        wx.EVT_MENU(rightclickmenu, 3007, self.OnRMouseGestureMenu7)
        wx.EVT_MENU(rightclickmenu, 3008, self.OnRMouseGestureMenu8)
        wx.EVT_MENU(rightclickmenu, 3009, self.OnRMouseGestureMenu9)

        self.PopupMenu(rightclickmenu)
        rightclickmenu.Destroy()

    def OnDeleteIfSelectedText(self, event):
        if self.GetSelectionStart() == self.GetSelectionEnd():
            pass
        else:
            self.DeleteBack()

    def OnRequireVersionsOblivion(self, event):
        self.AddText(u'RequireVersions "1.2.0.416","0.0.20.6","3.0.0.0","295"')
    def OnRequireVersionsSkyrim(self, event):
        self.AddText(u'RequireVersions "1.1.21.0","","","295"')
    def OnSelectOne(self, event):
        self.AddText(u'SelectOne "", \\')
        for i in range(0,4): self.CharLeft()
    def OnSelectMany(self, event):
        self.AddText(u'SelectMany "", \\')
        for i in range(0,4): self.CharLeft()
    def OnChoicesX02(self, event): # "", "", "" x2
        if gGlobalsDict['TabsOrSpaces'] == 1:#TABS
            self.AddText('\t"", "Description.", "Wizard Images\\\\NeedPic.jpg",\\\n'
                         '\t"", "Description.", "Wizard Images\\\\NeedPic.jpg"\n')
        elif gGlobalsDict['TabsOrSpaces'] == 0:#Spaces
            indent1 = ' '*(gGlobalsDict['IndentSize'])
            self.AddText('%s"", "Description.", "Wizard Images\\\\NeedPic.jpg",\\\n' % indent1 +
                         '%s"", "Description.", "Wizard Images\\\\NeedPic.jpg"\n' % indent1)
        self.SetFocus()
    def OnEndSelect(self, event):
        self.AddText('EndSelect\n')
        self.SetFocus()
    def OnCase(self, event):
        if gGlobalsDict['TabsOrSpaces'] == 1:#TABS
            self.AddText('\tCase ""\n')
        elif gGlobalsDict['TabsOrSpaces'] == 0:#Spaces
            indent1 = ' '*(gGlobalsDict['IndentSize'])
            self.AddText('%sCase ""\n' %indent1)
        self.SetFocus()
    def OnBreak(self, event):
        if gGlobalsDict['TabsOrSpaces'] == 1:#TABS
            self.AddText('\tBreak\n')
        elif gGlobalsDict['TabsOrSpaces'] == 0:#Spaces
            indent1 = ' '*(gGlobalsDict['IndentSize'])
            self.AddText('%sBreak\n' %indent1)
        self.SetFocus()
    def OnSelectAll(self, event):
        self.AddText('SelectAll')
        self.SetFocus()
    def OnDeSelectAll(self, event):
        self.AddText('DeSelectAll')
        self.SetFocus()
    def OnSelectSubPackage(self, event):
        self.OnDeleteIfSelectedText(event)
        self.AddText('SelectSubPackage ""')
        self.CharLeft()
        self.SetFocus()
    def OnDeSelectSubPackage(self, event):
        self.OnDeleteIfSelectedText(event)
        self.AddText('DeSelectSubPackage ""')
        self.CharLeft()
        self.SetFocus()
    def OnSelectEspm(self, event):
        self.OnDeleteIfSelectedText(event)
        self.AddText('SelectEspm ""')
        self.CharLeft()
        self.SetFocus()
    def OnSelectAllEspms(self, event):
        self.AddText('SelectAllEspms')
        self.SetFocus()
    def OnDeSelectEspm(self, event):
        self.OnDeleteIfSelectedText(event)
        self.AddText('DeSelectEspm ""')
        self.CharLeft()
        self.SetFocus()
    def OnDeSelectAllEspms(self, event):
        self.AddText('DeSelectAllEspms')
        self.SetFocus()
    def OnRenameEspm(self, event):
        self.OnDeleteIfSelectedText(event)
        self.AddText('RenameEspm ""')
        self.CharLeft()
        self.SetFocus()
    def OnResetEspmName(self, event):
        self.OnDeleteIfSelectedText(event)
        self.AddText('ResetEspmName ""')
        self.CharLeft()
        self.SetFocus()
    def OnResetAllEspmNames(self, event):
        self.AddText('ResetAllEspmNames')
        self.SetFocus()



    def OnRMouseGestureMenu3(self, event):
        rightclickmenu = wx.Menu()

        p = wx.BITMAP_TYPE_PNG

        rcheader1 = wx.MenuItem(rightclickmenu, 0000, u'&R MGM 3', u'ContextMenu3')
        rcheader1.SetBackgroundColour('#000000')
        rightclickmenu.AppendItem(rcheader1)
        rcheader1.SetDisabledBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousebuttonright16.png'),p).ConvertToBitmap())
        rcheader1.Enable(False)

        submenu = wx.Menu()
        mgm1 = wx.MenuItem(rightclickmenu, 3001, u'&R MGM 1', u' Call Mouse Gesture Menu 1')
        mgm1.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm1)

        mgm2 = wx.MenuItem(rightclickmenu, 3002, u'&R MGM 2 Wizard', u' Call Mouse Gesture Menu 2')
        mgm2.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm2)

        mgm3 = wx.MenuItem(rightclickmenu, 3003, u'&R MGM 3 You Are Here!', u' Call Mouse Gesture Menu 3')
        mgm3.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'youarehere16.png'),p).ConvertToBitmap())
        mgm3.SetBackgroundColour('#F4FAB4')
        mgm3.Enable(False)
        submenu.AppendItem(mgm3)

        mgm4 = wx.MenuItem(rightclickmenu, 3004, u'&R MGM 4 Case', u' Call Mouse Gesture Menu 4')
        mgm4.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm4)

        mgm5 = wx.MenuItem(rightclickmenu, 3005, u'&R MGM 5', u' Call Mouse Gesture Menu 5')
        mgm5.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm5)

        mgm6 = wx.MenuItem(rightclickmenu, 3006, u'&R MGM 6 Conversion', u' Call Mouse Gesture Menu 6')
        mgm6.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm6)

        mgm7 = wx.MenuItem(rightclickmenu, 3007, u'&R MGM 7', u' Call Mouse Gesture Menu 7')
        mgm7.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm7)

        mgm8 = wx.MenuItem(rightclickmenu, 3008, u'&R MGM 8 Line Operations', u' Call Mouse Gesture Menu 8')
        mgm8.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm8)

        mgm9 = wx.MenuItem(rightclickmenu, 3009, u'&R MGM 9 Options', u' Call Mouse Gesture Menu 9')
        mgm9.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm9)
        rightclickmenu.AppendMenu(wx.NewId(), u'Mouse Gesture Menus', submenu)

        rightclickmenu.AppendSeparator()

        showcalltip = wx.MenuItem(rightclickmenu, 3097, u'&Show CallTip\tCtrl+Shift+Space', u' Show a calltip for the currently selected word.')
        showcalltip.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'showcalltip24.png',p).ConvertToBitmap())
        rightclickmenu.AppendItem(showcalltip)

        autocomplete = wx.MenuItem(rightclickmenu, 3098, u'&WordComplete Box\tCtrl+W', u' Ctrl+W opens the WordComplete box')
        autocomplete.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'wordcomplete24.png',p).ConvertToBitmap())
        rightclickmenu.AppendItem(autocomplete)

        autocomplete = wx.MenuItem(rightclickmenu, 3099, u'&AutoComplete Box\tCtrl+Space', u' Ctrl+Space opens the AutoComplete box')
        autocomplete.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'autocomplete24.png',p).ConvertToBitmap())
        rightclickmenu.AppendItem(autocomplete)

        #events
        wx.EVT_MENU(rightclickmenu, 3001, self.OnRMouseGestureMenu1)
        wx.EVT_MENU(rightclickmenu, 3002, self.OnRMouseGestureMenu2)
        wx.EVT_MENU(rightclickmenu, 3003, self.OnRMouseGestureMenu3)
        wx.EVT_MENU(rightclickmenu, 3004, self.OnRMouseGestureMenu4)
        wx.EVT_MENU(rightclickmenu, 3005, self.OnRMouseGestureMenuNone)
        wx.EVT_MENU(rightclickmenu, 3006, self.OnRMouseGestureMenu6)
        wx.EVT_MENU(rightclickmenu, 3007, self.OnRMouseGestureMenu7)
        wx.EVT_MENU(rightclickmenu, 3008, self.OnRMouseGestureMenu8)
        wx.EVT_MENU(rightclickmenu, 3009, self.OnRMouseGestureMenu9)

        wx.EVT_MENU(rightclickmenu, 3097, self.OnShowSelectedTextCallTip)
        wx.EVT_MENU(rightclickmenu, 3098, self.OnShowWordCompleteBox)
        wx.EVT_MENU(rightclickmenu, 3099, self.OnShowAutoCompleteBox)

        self.PopupMenu(rightclickmenu)
        rightclickmenu.Destroy()

    def OnShowSelectedTextCallTip(self, event):
        pos = self.GetCurrentPos()

        self.CallTipSetBackground('yellow')             #Set the background colour for the call tip.
        self.CallTipSetForeground('#666666')            #Set the foreground colour for the call tip.
        self.CallTipSetHighlight(2, 5)                  #Highlight a segment of the definition.(int start, int end)
        self.CallTipSetForegroundHighlight('#FF0000')   #Set the foreground colour for the highlighted part of the call tip.
        # self.CallTipPosAtStart()    #Retrieve the position where the caret was before displaying the call tip.
        # self.CallTipUseStyle(48)    #Enable use of STYLE_CALLTIP and set call tip tab size in pixels.
        # self.CallTipActive()        #Is there an active call tip? -> bool
        # self.CallTipCancel()        #Remove the call tip from the screen.
        # self.CallTipPosAtStart()    #Retrieve the position where the caret was before displaying the call tip.

        if gGlobalsDict['LoadSTCLexer'] == 'wizbainlexer':
            self.CallTipSetBackground('#D7DEEB')        #Set the background colour for the call tip.
            self.CallTipSetForeground('#666666')        #Set the foreground colour for the call tip.

            if   self.GetSelectedText() == 'SelectOne':         self.CallTipShow(pos, 'The SelectOne dialog gives you a list of options,\nwith the option to select one of them.')
            elif self.GetSelectedText() == 'SelectMany':        self.CallTipShow(pos, 'The SelectMany dialog gives you a list of options,\nwith the option to select one or more of them,\nor even none of them.')
            elif self.GetSelectedText() == 'EndSelect':         self.CallTipShow(pos, 'EndSelect')
            elif self.GetSelectedText() == 'SelectAll':         self.CallTipShow(pos, 'Cause all sub-packages, esps, and\nesms to be selected for installation.')
            elif self.GetSelectedText() == 'DeSelectAll':       self.CallTipShow(pos, 'Cause all sub-packages, esps, and\nesms to be de-selected from installation.')
            elif self.GetSelectedText() == 'SelectSubPackage':  self.CallTipShow(pos, 'Cause the specified sub-package\nto be selected for installation')
            elif self.GetSelectedText() == 'DeSelectSubPackage':self.CallTipShow(pos, 'Cause the specified sub-package\nto be de-selected from installation.')
            elif self.GetSelectedText() == 'If':                self.CallTipShow(pos, 'Begins the control block.')
            elif self.GetSelectedText() == 'Elif':              self.CallTipShow(pos, 'Elif')
            elif self.GetSelectedText() == 'Else':              self.CallTipShow(pos, 'Else')
            elif self.GetSelectedText() == 'EndIf':             self.CallTipShow(pos, 'Signals the end of the If control block.')
            elif self.GetSelectedText() == 'False':             self.CallTipShow(pos, 'False')
            elif self.GetSelectedText() == 'True':              self.CallTipShow(pos, 'True')
            elif self.GetSelectedText() == '|Default Character':self.CallTipShow(pos, '|Default Character')
            elif self.GetSelectedText() == '; Comment':         self.CallTipShow(pos, '; Comment')
            elif self.GetSelectedText() == 'DataFileExists':    self.CallTipShow(pos, 'Tests for the existance of a file in the Data directory.')
            elif self.GetSelectedText() == 'SelectEspm':        self.CallTipShow(pos, 'Cause the specified esp or esm\nto be selected for installation.')
            elif self.GetSelectedText() == 'SelectAllEspms':    self.CallTipShow(pos, 'Cause all esps and esms to\nbe selected for installation.')
            elif self.GetSelectedText() == 'DeSelectEspm':      self.CallTipShow(pos, 'Cause the specified esp or esm\nto be deselected from installation.')
            elif self.GetSelectedText() == 'DeSelectAllEspms':  self.CallTipShow(pos, 'Cause all esps and esms to be\nde-selected from installation.')
            elif self.GetSelectedText() == 'RenameEspm':        self.CallTipShow(pos, 'Change the installed name of an esp or esm.')
            elif self.GetSelectedText() == 'ResetEspmName':     self.CallTipShow(pos, 'Resets the name of an esp or esm\nback to its default name.')
            elif self.GetSelectedText() == 'ResetAllEspmNames': self.CallTipShow(pos, 'Resets the names of all the esps and\nesms back to their default names. ')
            elif self.GetSelectedText() == 'RequireVersions':   self.CallTipShow(pos, 'The RequireVersions dialog will show up if the wizard \nspecified minimum version requirements, and your \nsystem doesn\'t meet those requirements.')
            elif self.GetSelectedText() == 'Cancel':            self.CallTipShow(pos, 'The Cancel dialog will be shown if the wizard\ncancels execution for some reason.\nIf a reason is given, it will be displayed.')
            elif self.GetSelectedText() == 'Note':              self.CallTipShow(pos, 'Add a note to the user to be displayed\nat the end of the wizard, on the finish page.')
            elif self.GetSelectedText() == 'Return':            self.CallTipShow(pos, 'Signals completion of the wizard.\nThis will jump right to the finish page. ')
            elif self.GetSelectedText() == 'CompareObVersion':  self.CallTipShow(pos, 'CompareObVersion')
            elif self.GetSelectedText() == 'CompareOBSEVersion':self.CallTipShow(pos, 'CompareOBSEVersion')
            elif self.GetSelectedText() == 'CompareOBGEVersion':self.CallTipShow(pos, 'CompareOBGEVersion')
            elif self.GetSelectedText() == 'CompareWBVersion':  self.CallTipShow(pos, 'CompareWBVersion')
            elif self.GetSelectedText() == 'str':               self.CallTipShow(pos, 'Used to convert a value into a string,\nfor example when trying to concantenate\na integer or decimal to a string.')
            elif self.GetSelectedText() == 'int':               self.CallTipShow(pos, 'Used to convert a value to an integer,\nfor example converting a value held in a\nstring to a integer value. ')
            elif self.GetSelectedText() == 'float':             self.CallTipShow(pos, 'Used to convert a value to decimal, for\nexample converting a value held in a\nstring to a decimal value. ')
            elif self.GetSelectedText() == 'len':               self.CallTipShow(pos, 'Used to find the length of a string.')
            elif self.GetSelectedText() == 'lower':             self.CallTipShow(pos, 'lower')
            elif self.GetSelectedText() == 'For':               self.CallTipShow(pos, 'For')
            elif self.GetSelectedText() == 'EndFor':            self.CallTipShow(pos, 'EndFor')
            elif self.GetSelectedText() == 'While':             self.CallTipShow(pos, 'While')
            elif self.GetSelectedText() == 'EndWhile':          self.CallTipShow(pos, 'EndWhile')
            elif self.GetSelectedText() == 'Continue':          self.CallTipShow(pos, 'Continue')
            elif self.GetSelectedText() == 'GetEspmStatus':     self.CallTipShow(pos, 'Tests the current status of an esp or espm\nin the Data directory. This function takes esp/m\nghosting into account when testing the status.')
            else:
                pass

    def OnShowWordCompleteBox(self,event):
        text = self.GetText()
        replaceThisList = ['.','!','?',',',':',';',
                           '\'','"',
                           '/','\\',
                           '[',']','<','>','(',')','{','}',
                           '=','+','-',
                           '_','@','#','$','%','^','&','*','|','`','~',
                           '\n','\t']
        for char in replaceThisList:
            text = text.replace(char, ' ')
        words = list(set(text.split(' ')))

        # print words

        kw = words
        kw.sort()
        # No need to seperate lowercase words from capitalcase or uppercase words
        self.AutoCompSetIgnoreCase(False)
        self.AutoCompShow(0, ' '.join(kw))

    def OnShowAutoCompleteBox(self,event):
        '''Shows the AutoComplete Box in the editor.'''
        if gGlobalsDict['LoadSTCLexer'] == 'wizbainlexer':
            kw = keywordWIZBAIN.kwlist[:] + keywordWIZBAIN2.kwlist[:]
            # Optionally add more ...
            kw.append('__U__SePeRaToR__l__?')
            # Python sorts are case sensitive
            kw.sort()
            # So this needs to match
            self.AutoCompSetIgnoreCase(False)
            self.AutoCompSetChooseSingle(True) #Should a single item auto-completion list automatically choose the item.

            # Registered images are specified with appended '?type'
            for i in range(len(kw)):
                if kw[i] in keywordWIZBAIN.kwlist or keywordWIZBAIN2.kwlist:
                    kw[i] = kw[i] + '?5'
            self.AutoCompShow(0, ' '.join(kw))

    def OnRMouseGestureMenu4(self, event):
        rightclickmenu = wx.Menu()

        p = wx.BITMAP_TYPE_PNG

        rcheader1 = wx.MenuItem(rightclickmenu, 0000, u'&R MGM 4 Case', u'ContextMenu4')
        rcheader1.SetBackgroundColour('#000000')
        rightclickmenu.AppendItem(rcheader1)
        rcheader1.SetDisabledBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousebuttonright16.png'),p).ConvertToBitmap())
        rcheader1.Enable(False)

        submenu = wx.Menu()
        mgm1 = wx.MenuItem(rightclickmenu, 3001, u'&R MGM 1', u' Call Mouse Gesture Menu 1')
        mgm1.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm1)

        mgm2 = wx.MenuItem(rightclickmenu, 3002, u'&R MGM 2 Wizard', u' Call Mouse Gesture Menu 2')
        mgm2.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm2)

        mgm3 = wx.MenuItem(rightclickmenu, 3003, u'&R MGM 3', u' Call Mouse Gesture Menu 3')
        mgm3.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm3)

        mgm4 = wx.MenuItem(rightclickmenu, 3004, u'&R MGM 4 You Are Here!', u' Call Mouse Gesture Menu 4')
        mgm4.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'youarehere16.png'),p).ConvertToBitmap())
        mgm4.SetBackgroundColour('#F4FAB4')
        mgm4.Enable(False)
        submenu.AppendItem(mgm4)

        mgm5 = wx.MenuItem(rightclickmenu, 3005, u'&R MGM 5', u' Call Mouse Gesture Menu 5')
        mgm5.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm5)

        mgm6 = wx.MenuItem(rightclickmenu, 3006, u'&R MGM 6 Conversion', u' Call Mouse Gesture Menu 6')
        mgm6.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm6)

        mgm7 = wx.MenuItem(rightclickmenu, 3007, u'&R MGM 7', u' Call Mouse Gesture Menu 7')
        mgm7.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm7)

        mgm8 = wx.MenuItem(rightclickmenu, 3008, u'&R MGM 8 Line Operations', u' Call Mouse Gesture Menu 8')
        mgm8.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm8)

        mgm9 = wx.MenuItem(rightclickmenu, 3009, u'&R MGM 9 Options', u' Call Mouse Gesture Menu 9')
        mgm9.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm9)
        rightclickmenu.AppendMenu(wx.NewId(), u'Mouse Gesture Menus', submenu)

        rightclickmenu.AppendSeparator()


        uppercase = wx.MenuItem(rightclickmenu, 4001, '&UPPER CASE', ' Change Selected text to all UPPER CASE')
        uppercase.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'uppercase16.png'),p).ConvertToBitmap())
        rightclickmenu.AppendItem(uppercase)
        lowercase = wx.MenuItem(rightclickmenu, 4002, '&lower case', ' Change Selected text to all lower case')
        lowercase.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'lowercase16.png'),p).ConvertToBitmap())
        rightclickmenu.AppendItem(lowercase)
        invertcase = wx.MenuItem(rightclickmenu, 4003, '&iNVERT cASE', ' Invert Case of Selected text')
        invertcase.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'invertcase2416.png'),p).ConvertToBitmap())
        rightclickmenu.AppendItem(invertcase)
        capitalcase = wx.MenuItem(rightclickmenu, 4004, '&Capital Case', ' Change Selected text to all Capital Case(words)')
        capitalcase.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'capitalcase16.png'),p).ConvertToBitmap())
        rightclickmenu.AppendItem(capitalcase)





        #events
        wx.EVT_MENU(rightclickmenu, 4001, self.OnUPPERCASE)
        wx.EVT_MENU(rightclickmenu, 4002, self.Onlowercase)
        wx.EVT_MENU(rightclickmenu, 4003, self.OnInvertCase)
        wx.EVT_MENU(rightclickmenu, 4004, self.OnCapitalCase)

        wx.EVT_MENU(rightclickmenu, 3001, self.OnRMouseGestureMenu1)
        wx.EVT_MENU(rightclickmenu, 3002, self.OnRMouseGestureMenu2)
        wx.EVT_MENU(rightclickmenu, 3003, self.OnRMouseGestureMenu3)
        wx.EVT_MENU(rightclickmenu, 3004, self.OnRMouseGestureMenu4)
        wx.EVT_MENU(rightclickmenu, 3005, self.OnRMouseGestureMenuNone)
        wx.EVT_MENU(rightclickmenu, 3006, self.OnRMouseGestureMenu6)
        wx.EVT_MENU(rightclickmenu, 3007, self.OnRMouseGestureMenu7)
        wx.EVT_MENU(rightclickmenu, 3008, self.OnRMouseGestureMenu8)
        wx.EVT_MENU(rightclickmenu, 3009, self.OnRMouseGestureMenu9)

        self.PopupMenu(rightclickmenu)
        rightclickmenu.Destroy()

    def OnRMouseGestureMenu6(self, event):
        rightclickmenu = wx.Menu()

        p = wx.BITMAP_TYPE_PNG

        rcheader1 = wx.MenuItem(rightclickmenu, 0000, u'&R MGM 6', u'ContextMenu6')
        rcheader1.SetBackgroundColour('#000000')
        rightclickmenu.AppendItem(rcheader1)
        rcheader1.SetDisabledBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousebuttonright16.png'),p).ConvertToBitmap())
        rcheader1.Enable(False)

        submenu = wx.Menu()
        mgm1 = wx.MenuItem(rightclickmenu, 3001, u'&R MGM 1', u' Call Mouse Gesture Menu 1')
        mgm1.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm1)

        mgm2 = wx.MenuItem(rightclickmenu, 3002, u'&R MGM 2 Wizard', u' Call Mouse Gesture Menu 2')
        mgm2.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm2)

        mgm3 = wx.MenuItem(rightclickmenu, 3003, u'&R MGM 3', u' Call Mouse Gesture Menu 3')
        mgm3.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm3)

        mgm4 = wx.MenuItem(rightclickmenu, 3004, u'&R MGM 4 Case', u' Call Mouse Gesture Menu 4')
        mgm4.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm4)

        mgm5 = wx.MenuItem(rightclickmenu, 3005, u'&R MGM 5', u' Call Mouse Gesture Menu 5')
        mgm5.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm5)

        mgm6 = wx.MenuItem(rightclickmenu, 3006, u'&R MGM 6 You Are Here!', u' Call Mouse Gesture Menu 6')
        mgm6.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'youarehere16.png'),p).ConvertToBitmap())
        mgm6.SetBackgroundColour('#F4FAB4')
        mgm6.Enable(False)
        submenu.AppendItem(mgm6)

        mgm7 = wx.MenuItem(rightclickmenu, 3007, u'&R MGM 7', u' Call Mouse Gesture Menu 7')
        mgm7.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm7)

        mgm8 = wx.MenuItem(rightclickmenu, 3008, u'&R MGM 8 Line Operations', u' Call Mouse Gesture Menu 8')
        mgm8.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm8)

        mgm9 = wx.MenuItem(rightclickmenu, 3009, u'&R MGM 9 Options', u' Call Mouse Gesture Menu 9')
        mgm9.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm9)
        rightclickmenu.AppendMenu(wx.NewId(), u'Mouse Gesture Menus', submenu)

        rightclickmenu.AppendSeparator()

        txt2wizfiledrop = wx.MenuItem(rightclickmenu, 3101, u'& Txt2Wiz (FileDrop)', u' Txt2Wiz (FileDrop)')
        txt2wizfiledrop.SetBitmap(wx.Image(self.imgDir + os.sep + 'wizard.png',p).ConvertToBitmap())
        rightclickmenu.AppendItem(txt2wizfiledrop)

        txt2wiztextdrop = wx.MenuItem(rightclickmenu, 3102, u'& Txt2Wiz (TextDrop)', u' Txt2Wiz (TextDrop)')
        txt2wiztextdrop.SetBitmap(wx.Image(self.imgDir + os.sep + 'wizard.png',p).ConvertToBitmap())
        rightclickmenu.AppendItem(txt2wiztextdrop)

        hmmm = wx.MenuItem(rightclickmenu, 9999, u'&Needs Label && ID3', u' StatusText Description Here')
        hmmm.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'black16.png'),p).ConvertToBitmap())
        rightclickmenu.AppendItem(hmmm)

        hmmm = wx.MenuItem(rightclickmenu, 9999, u'&Needs Label && ID4', u' StatusText Description Here')
        hmmm.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'black16.png'),p).ConvertToBitmap())
        rightclickmenu.AppendItem(hmmm)

        hmmm = wx.MenuItem(rightclickmenu, 9999, u'&Needs Label && ID5', u' StatusText Description Here')
        hmmm.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'black16.png'),p).ConvertToBitmap())
        rightclickmenu.AppendItem(hmmm)

        hmmm = wx.MenuItem(rightclickmenu, 9999, u'&Needs Label && ID6', u' StatusText Description Here')
        hmmm.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'black16.png'),p).ConvertToBitmap())
        rightclickmenu.AppendItem(hmmm)

        #events
        wx.EVT_MENU(rightclickmenu, 3101, self.OnTextToWizardStringFileDropMiniFrame)
        wx.EVT_MENU(rightclickmenu, 3102, self.OnTextToWizardStringTextDropMiniFrame)

        wx.EVT_MENU(rightclickmenu, 3001, self.OnRMouseGestureMenu1)
        wx.EVT_MENU(rightclickmenu, 3002, self.OnRMouseGestureMenu2)
        wx.EVT_MENU(rightclickmenu, 3003, self.OnRMouseGestureMenu3)
        wx.EVT_MENU(rightclickmenu, 3004, self.OnRMouseGestureMenu4)
        wx.EVT_MENU(rightclickmenu, 3005, self.OnRMouseGestureMenuNone)
        wx.EVT_MENU(rightclickmenu, 3006, self.OnRMouseGestureMenu6)
        wx.EVT_MENU(rightclickmenu, 3007, self.OnRMouseGestureMenu7)
        wx.EVT_MENU(rightclickmenu, 3008, self.OnRMouseGestureMenu8)
        wx.EVT_MENU(rightclickmenu, 3009, self.OnRMouseGestureMenu9)

        self.PopupMenu(rightclickmenu)
        rightclickmenu.Destroy()

    def OnRMouseGestureMenu7(self, event):
        rightclickmenu = wx.Menu()

        p = wx.BITMAP_TYPE_PNG

        rcheader1 = wx.MenuItem(rightclickmenu, 0000, u'&R MGM 7', u'ContextMenu7')
        rcheader1.SetBackgroundColour('#000000')
        rightclickmenu.AppendItem(rcheader1)
        rcheader1.SetDisabledBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousebuttonright16.png'),p).ConvertToBitmap())
        rcheader1.Enable(False)

        submenu = wx.Menu()
        mgm1 = wx.MenuItem(rightclickmenu, 3001, u'&R MGM 1', u' Call Mouse Gesture Menu 1')
        mgm1.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm1)

        mgm2 = wx.MenuItem(rightclickmenu, 3002, u'&R MGM 2 Wizard', u' Call Mouse Gesture Menu 2')
        mgm2.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm2)

        mgm3 = wx.MenuItem(rightclickmenu, 3003, u'&R MGM 3', u' Call Mouse Gesture Menu 3')
        mgm3.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm3)

        mgm4 = wx.MenuItem(rightclickmenu, 3004, u'&R MGM 4 Case', u' Call Mouse Gesture Menu 4')
        mgm4.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm4)

        mgm5 = wx.MenuItem(rightclickmenu, 3005, u'&R MGM 5', u' Call Mouse Gesture Menu 5')
        mgm5.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm5)

        mgm6 = wx.MenuItem(rightclickmenu, 3006, u'&R MGM 6 Conversion', u' Call Mouse Gesture Menu 6')
        mgm6.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm6)

        mgm7 = wx.MenuItem(rightclickmenu, 3007, u'&R MGM 7 You Are Here!', u' Call Mouse Gesture Menu 7')
        mgm7.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'youarehere16.png'),p).ConvertToBitmap())
        mgm7.SetBackgroundColour('#F4FAB4')
        mgm7.Enable(False)
        submenu.AppendItem(mgm7)

        mgm8 = wx.MenuItem(rightclickmenu, 3008, u'&R MGM 8 Line Operations', u' Call Mouse Gesture Menu 8')
        mgm8.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm8)

        mgm9 = wx.MenuItem(rightclickmenu, 3009, u'&R MGM 9 Options', u' Call Mouse Gesture Menu 9')
        mgm9.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm9)
        rightclickmenu.AppendMenu(wx.NewId(), u'Mouse Gesture Menus', submenu)

        rightclickmenu.AppendSeparator()

        hmmm = wx.MenuItem(rightclickmenu, 9999, u'&Needs Label && ID1', u' StatusText Description Here')
        hmmm.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'black16.png'),p).ConvertToBitmap())
        rightclickmenu.AppendItem(hmmm)

        hmmm = wx.MenuItem(rightclickmenu, 9999, u'&Needs Label && ID2', u' StatusText Description Here')
        hmmm.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'black16.png'),p).ConvertToBitmap())
        rightclickmenu.AppendItem(hmmm)

        hmmm = wx.MenuItem(rightclickmenu, 9999, u'&Needs Label && ID3', u' StatusText Description Here')
        hmmm.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'black16.png'),p).ConvertToBitmap())
        rightclickmenu.AppendItem(hmmm)

        hmmm = wx.MenuItem(rightclickmenu, 9999, u'&Needs Label && ID4', u' StatusText Description Here')
        hmmm.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'black16.png'),p).ConvertToBitmap())
        rightclickmenu.AppendItem(hmmm)

        hmmm = wx.MenuItem(rightclickmenu, 9999, u'&Needs Label && ID5', u' StatusText Description Here')
        hmmm.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'black16.png'),p).ConvertToBitmap())
        rightclickmenu.AppendItem(hmmm)

        hmmm = wx.MenuItem(rightclickmenu, 9999, u'&Needs Label && ID6', u' StatusText Description Here')
        hmmm.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'black16.png'),p).ConvertToBitmap())
        rightclickmenu.AppendItem(hmmm)

        hmmm = wx.MenuItem(rightclickmenu, 9999, u'&Needs Label && ID7', u' StatusText Description Here')
        hmmm.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'black16.png'),p).ConvertToBitmap())
        rightclickmenu.AppendItem(hmmm)

        #events
        wx.EVT_MENU(rightclickmenu, 3001, self.OnRMouseGestureMenu1)
        wx.EVT_MENU(rightclickmenu, 3002, self.OnRMouseGestureMenu2)
        wx.EVT_MENU(rightclickmenu, 3003, self.OnRMouseGestureMenu3)
        wx.EVT_MENU(rightclickmenu, 3004, self.OnRMouseGestureMenu4)
        wx.EVT_MENU(rightclickmenu, 3005, self.OnRMouseGestureMenuNone)
        wx.EVT_MENU(rightclickmenu, 3006, self.OnRMouseGestureMenu6)
        wx.EVT_MENU(rightclickmenu, 3007, self.OnRMouseGestureMenu7)
        wx.EVT_MENU(rightclickmenu, 3008, self.OnRMouseGestureMenu8)
        wx.EVT_MENU(rightclickmenu, 3009, self.OnRMouseGestureMenu9)

        self.PopupMenu(rightclickmenu)
        rightclickmenu.Destroy()

    def OnRMouseGestureMenu8(self, event):
        rightclickmenu = wx.Menu()

        p = wx.BITMAP_TYPE_PNG

        rcheader1 = wx.MenuItem(rightclickmenu, 0000, u'&R MGM 8 Line Operations', u'ContextMenu8')
        rcheader1.SetBackgroundColour('#000000')
        rightclickmenu.AppendItem(rcheader1)
        rcheader1.SetDisabledBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousebuttonright16.png'),p).ConvertToBitmap())
        rcheader1.Enable(False)

        submenu = wx.Menu()
        mgm1 = wx.MenuItem(rightclickmenu, 3001, u'&R MGM 1', u' Call Mouse Gesture Menu 1')
        mgm1.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm1)

        mgm2 = wx.MenuItem(rightclickmenu, 3002, u'&R MGM 2 Wizard', u' Call Mouse Gesture Menu 2')
        mgm2.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm2)

        mgm3 = wx.MenuItem(rightclickmenu, 3003, u'&R MGM 3', u' Call Mouse Gesture Menu 3')
        mgm3.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm3)

        mgm4 = wx.MenuItem(rightclickmenu, 3004, u'&R MGM 4 Case', u' Call Mouse Gesture Menu 4')
        mgm4.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm4)

        mgm5 = wx.MenuItem(rightclickmenu, 3005, u'&R MGM 5', u' Call Mouse Gesture Menu 5')
        mgm5.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm5)

        mgm6 = wx.MenuItem(rightclickmenu, 3006, u'&R MGM 6 Conversion', u' Call Mouse Gesture Menu 6')
        mgm6.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm6)

        mgm7 = wx.MenuItem(rightclickmenu, 3007, u'&R MGM 7', u' Call Mouse Gesture Menu 7')
        mgm7.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm7)

        mgm8 = wx.MenuItem(rightclickmenu, 3008, u'&R MGM 8 You Are Here!', u' Call Mouse Gesture Menu 8')
        mgm8.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'youarehere16.png'),p).ConvertToBitmap())
        mgm8.SetBackgroundColour('#F4FAB4')
        mgm8.Enable(False)
        submenu.AppendItem(mgm8)

        mgm9 = wx.MenuItem(rightclickmenu, 3009, u'&R MGM 9 Options', u' Call Mouse Gesture Menu 9')
        mgm9.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm9)
        rightclickmenu.AppendMenu(wx.NewId(), u'Mouse Gesture Menus', submenu)

        rightclickmenu.AppendSeparator()

        newlinebefore = wx.MenuItem(rightclickmenu, 2101, u'&New Line Before', u' Insert a new line before the current line.')
        newlinebefore.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'newlinebefore16.png',p).ConvertToBitmap())
        rightclickmenu.AppendItem(newlinebefore)

        newlineafter = wx.MenuItem(rightclickmenu, 2102, u'&New Line After', u' Insert a new line after the current line.')
        newlineafter.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'newlineafter16.png',p).ConvertToBitmap())
        rightclickmenu.AppendItem(newlineafter)

        cutline = wx.MenuItem(rightclickmenu, 2103, u'&Cut Line', u' Cut the current line to the clipboard.')
        cutline.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'cutline16.png',p).ConvertToBitmap())
        rightclickmenu.AppendItem(cutline)

        copyline = wx.MenuItem(rightclickmenu, 2104, u'&Copy Line', u' Copy the current line to the clipboard.')
        copyline.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'copyline16.png',p).ConvertToBitmap())
        rightclickmenu.AppendItem(copyline)

        deleteline = wx.MenuItem(rightclickmenu, 2105, u'&Delete Line\tCtrl+L', u' Delete the current line.')
        deleteline.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'deleteline16.png',p).ConvertToBitmap())
        rightclickmenu.AppendItem(deleteline)

        deletelinecontents = wx.MenuItem(rightclickmenu, 2106, u'&Delete Line Contents', u' Delete the contents of the current line.')
        deletelinecontents.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'deleteline16.png',p).ConvertToBitmap())
        rightclickmenu.AppendItem(deletelinecontents)

        selectline = wx.MenuItem(rightclickmenu, 2107, u'&Select Line(without EOL)', u' Select the contents of the caret line without EOL chars.')
        selectline.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'selectline16.png',p).ConvertToBitmap())
        rightclickmenu.AppendItem(selectline)

        duplicateline = wx.MenuItem(rightclickmenu, 2108, u'&Duplicate Line', u' Duplicate the current line.')
        duplicateline.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'duplicateline16.png',p).ConvertToBitmap())
        rightclickmenu.AppendItem(duplicateline)

        duplicateselectionline = wx.MenuItem(rightclickmenu, 2109, u'&Duplicate Selection/Line\tCtrl+D', u' Duplicate the selection. If the selection is empty, it duplicates the line containing the caret.')
        duplicateselectionline.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'duplicateselectionline16.png',p).ConvertToBitmap())
        rightclickmenu.AppendItem(duplicateselectionline)

        duplicatelinentimes = wx.MenuItem(rightclickmenu, 2110, u'&Duplicate Line n Times', u' Duplicate the current line n times.')
        duplicatelinentimes.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'duplicateselectionline16.png',p).ConvertToBitmap())
        rightclickmenu.AppendItem(duplicatelinentimes)

        joinlines = wx.MenuItem(rightclickmenu, 2111, u'&Join Lines', u' Join the currently selected lines.')
        joinlines.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'joinlines16.png',p).ConvertToBitmap())
        rightclickmenu.AppendItem(joinlines)

        splitlines = wx.MenuItem(rightclickmenu, 2112, u'&Split Lines', u' Split the lines in the target into lines that are less wide than pixelWidth where possible.')
        splitlines.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'splitlines16.png',p).ConvertToBitmap())
        rightclickmenu.AppendItem(splitlines)

        switcheroolinetranspose = wx.MenuItem(rightclickmenu, 2113, u'&Line Transpose\tCtrl+T', u' Switcheroo the current line with the previous.')
        switcheroolinetranspose.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'linetranspose16.png',p).ConvertToBitmap())
        rightclickmenu.AppendItem(switcheroolinetranspose)

        movelineup = wx.MenuItem(rightclickmenu, 2114, u'&Move Line Up\tCtrl+Shift+Up', u' Move the current line up.')
        movelineup.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'arrowupbw16.png',p).ConvertToBitmap())
        rightclickmenu.AppendItem(movelineup)

        movelinedown = wx.MenuItem(rightclickmenu, 2115, u'&Move Line Down\tCtrl+Shift+Down', u' Move the current line down.')
        movelinedown.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'arrowdownbw16.png',p).ConvertToBitmap())
        rightclickmenu.AppendItem(movelinedown)

        appendselectedlineswithastring = wx.MenuItem(rightclickmenu, 2116, u'&Append Selected Line(s) with a string', u' Append Selected Line(s) with a string.')
        appendselectedlineswithastring.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'append16.png',p).ConvertToBitmap())
        rightclickmenu.AppendItem(appendselectedlineswithastring)

        removestringfromendoflines = wx.MenuItem(rightclickmenu, 2117, u'&Remove string from end of selected lines', u' Remove a user-defined string from the end of selected lines.')
        removestringfromendoflines.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'remove16.png',p).ConvertToBitmap())
        rightclickmenu.AppendItem(removestringfromendoflines)

        removestringfromstartoflines = wx.MenuItem(rightclickmenu, 2118, u'&Remove string from start of lines', u' Remove a user-defined string from the start of selected lines.')
        removestringfromstartoflines.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'remove16.png',p).ConvertToBitmap())
        rightclickmenu.AppendItem(removestringfromstartoflines)

        padwithspaces = wx.MenuItem(rightclickmenu, 2120, u'&Pad With Spaces(selected lines)', u' Pad selected lines with spaces to the longest column width')
        padwithspaces.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'padwithspaces16.png',p).ConvertToBitmap())
        rightclickmenu.AppendItem(padwithspaces)



        #events
        wx.EVT_MENU(rightclickmenu, 2101, self.OnNewLineBefore)
        wx.EVT_MENU(rightclickmenu, 2102, self.OnNewLineAfter)
        wx.EVT_MENU(rightclickmenu, 2103, self.OnLineCut)
        wx.EVT_MENU(rightclickmenu, 2104, self.OnLineCopy)
        wx.EVT_MENU(rightclickmenu, 2105, self.OnLineDelete)
        wx.EVT_MENU(rightclickmenu, 2106, self.OnDeleteLineContents)
        wx.EVT_MENU(rightclickmenu, 2107, self.OnLineSelect)
        wx.EVT_MENU(rightclickmenu, 2108, self.OnLineDuplicate)
        wx.EVT_MENU(rightclickmenu, 2109, self.OnDuplicateSelectionLine)
        wx.EVT_MENU(rightclickmenu, 2110, self.OnLineDuplicateNTimes)
        wx.EVT_MENU(rightclickmenu, 2111, self.OnLinesJoin)
        wx.EVT_MENU(rightclickmenu, 2112, self.OnLinesSplit)
        wx.EVT_MENU(rightclickmenu, 2113, self.OnLineTranspose)
        wx.EVT_MENU(rightclickmenu, 2114, self.OnMoveLineUp)
        wx.EVT_MENU(rightclickmenu, 2115, self.OnMoveLineDown)
        wx.EVT_MENU(rightclickmenu, 2116, self.OnAppendSelectedLinesWithAString)
        wx.EVT_MENU(rightclickmenu, 2117, self.OnRemoveStringFromEndOfSelectedLines)
        wx.EVT_MENU(rightclickmenu, 2118, self.OnRemoveStringFromStartOfSelectedLines)

        wx.EVT_MENU(rightclickmenu, 2120, self.OnPadWithSpacesSelectedLines)

        wx.EVT_MENU(rightclickmenu, 3001, self.OnRMouseGestureMenu1)
        wx.EVT_MENU(rightclickmenu, 3002, self.OnRMouseGestureMenu2)
        wx.EVT_MENU(rightclickmenu, 3003, self.OnRMouseGestureMenu3)
        wx.EVT_MENU(rightclickmenu, 3004, self.OnRMouseGestureMenu4)
        wx.EVT_MENU(rightclickmenu, 3005, self.OnRMouseGestureMenuNone)
        wx.EVT_MENU(rightclickmenu, 3006, self.OnRMouseGestureMenu6)
        wx.EVT_MENU(rightclickmenu, 3007, self.OnRMouseGestureMenu7)
        wx.EVT_MENU(rightclickmenu, 3008, self.OnRMouseGestureMenu8)
        wx.EVT_MENU(rightclickmenu, 3009, self.OnRMouseGestureMenu9)

        self.PopupMenu(rightclickmenu)
        rightclickmenu.Destroy()


    def OnNewLineBefore(self, event):
        ''' Insert a new line before the current line. '''
        self.HomeDisplay()
        self.CharLeft()
        self.NewLine()
        self.SetFocus()

    def OnNewLineAfter(self, event):
        ''' Insert a new line after the current line. '''
        self.LineEndDisplay()
        self.NewLine()
        self.SetFocus()

    def OnLineCut(self, event):
        ''' Cut the line containing the caret. '''
        self.LineCut()

    def OnLineCopy(self, event):
        ''' Copy the line containing the caret. '''
        self.LineCopy()

    def OnLineDelete(self, event):
        ''' Delete the line containing the caret. '''
        self.LineDelete()

    def OnDeleteLineContents(self, event):
        ''' Delete the contents of the line containing the caret, but not the line itself.'''
        self.OnLineSelect(event)
        self.DeleteBackNotLine()

    def OnLineSelect(self, event):
        ''' Select the contents of the caret line, but without the EOL char(s). '''
        linefrompos = self.LineFromPosition(self.GetCurrentPos())
        firstposcurline = self.PositionFromLine(linefrompos)
        lengthline = len(self.GetLine(linefrompos))
        if self.GetEOLMode() == 0: self.SetSelection(firstposcurline,firstposcurline+lengthline-2)#Minus 2 for Dos/Windows CRLF chars
        else: self.SetSelection(firstposcurline,firstposcurline+lengthline-1)#Minus 1 for CR or LF EOL char

    def OnLineDuplicate(self, event):
        ''' Duplicate the current line. '''
        self.LineDuplicate()

    def OnLineDuplicateNTimes(self, event):
        ''' Duplicate the current line n times. '''
        dialog = wx.TextEntryDialog(self, u'Example:\n\nDuplicate this line\nDuplicate this line\nDuplicate this line\netc...\n\nEnter the number of times you want to duplicate the current line.', u'Duplicate Line n Times', u'')
        if dialog.ShowModal() == wx.ID_OK:
            try:
                self.BeginUndoAction()
                n = dialog.GetValue()
                for i in range(0,int(n)):
                    self.LineDuplicate()
                self.EndUndoAction()
            except:
                wx.Bell()
                self.OnLineDuplicateNTimes(event)

    def OnDuplicateSelectionLine(self, event):
        ''' Duplicate the selection. If selection empty duplicate the line containing the caret. '''
        self.SelectionDuplicate()

    def OnLinesJoin(self, event):
        targettojoin = self.TargetFromSelection()
        self.LinesJoin()

    def OnLinesSplit(self, event):
        ''' Split the lines in the target into lines that are less wide than pixelWidth where possible. '''
        self.TargetFromSelection()
        self.LinesSplit(-1)

    def OnLineTranspose(self, event):
        ''' Switch the current line with the previous. '''
        self.BeginUndoAction()
        self.LineTranspose()
        self.EndUndoAction()

    def OnMoveLineUp(self, event):
        ''' Move the current line up. '''
        linenum = self.GetCurrentLine()
        if linenum > 0 :
            self.BeginUndoAction()
            self.LineTranspose()
            self.LineUp()
            self.EndUndoAction()

    def OnMoveLineDown(self, event):
        ''' Move the current line down. '''
        linenum = self.GetCurrentLine()
        if linenum < self.GetLineCount() - 1:
            self.BeginUndoAction()
            self.LineDown()
            self.LineTranspose()
            self.EndUndoAction()

    def OnAppendSelectedLinesWithAString(self, event):
        dialog = wx.TextEntryDialog(self, u'line1 Append A String\nline2 Append A String\nline3 Append A String\netc...', u'Append (selected lines) with a string', u' Append A String')
        if dialog.ShowModal() == wx.ID_OK:
            self.BeginUndoAction()
            appendselstring = dialog.GetValue()

            selstart = self.GetSelectionStart()
            selend = self.GetSelectionEnd()
            startline = self.LineFromPosition(selstart)
            endline = self.LineFromPosition(selend)
            for i in range(startline, endline+1):
                self.GotoPos(self.GetLineEndPosition(i))
                self.AddText(appendselstring)
            self.EndUndoAction()
        dialog.Destroy()

    def OnRemoveStringFromEndOfSelectedLines(self, event):
        dialog = wx.TextEntryDialog(self, u'ExampleString to remove:ing\n\nline(s) Remove A String\nbecomes\nline(s) Remove A Str\netc...\n\nNote: Does not strip trailing whitespace!', u'Remove String from end of Selected Lines', u' Remove End String')
        if dialog.ShowModal() == wx.ID_OK:
            self.BeginUndoAction()
            removeendselstring = dialog.GetValue()

            selstart = self.GetSelectionStart()
            selend = self.GetSelectionEnd()
            startline = self.LineFromPosition(selstart)
            endline = self.LineFromPosition(selend)
            for i in range(startline, endline+1):
                self.GotoPos(self.GetLineEndPosition(i))
                linestring = self.GetLine(i).rstrip('\n')
                if linestring.endswith(removeendselstring):
                    for i in range(0, len(removeendselstring)):
                        self.DeleteBack()
            self.EndUndoAction()
        dialog.Destroy()

    def OnRemoveStringFromStartOfSelectedLines(self, event):
        dialog = wx.TextEntryDialog(self, u'ExampleString to remove:Rem\n\nline(s) Remove A String\nbecomes\nline(s) ove A String\netc...\n\nNote: Leading indentation/whitespace is ignored!', u'Remove String from end of Selected Lines', u' Remove End String')
        if dialog.ShowModal() == wx.ID_OK:
            self.BeginUndoAction()
            removestartselstring = dialog.GetValue()

            selstart = self.GetSelectionStart()
            selend = self.GetSelectionEnd()
            startline = self.LineFromPosition(selstart)
            endline = self.LineFromPosition(selend)
            for i in range(startline, endline+1):
                self.GotoPos(self.GetLineIndentPosition(i))
                linestring = self.GetLine(i).lstrip()
                if linestring.startswith(removestartselstring):
                    for i in range(0, len(removestartselstring)):
                        self.CmdKeyExecute(wx.stc.STC_CMD_CLEAR)
            self.EndUndoAction()
        dialog.Destroy()

    def OnPadWithSpacesSelectedLines(self, event):
        ''' Pad selected lines with spaces to the longest column width. '''
        selstart = self.GetSelectionStart()
        selend = self.GetSelectionEnd()
        startline = self.LineFromPosition(selstart)
        endline = self.LineFromPosition(selend)

        longestcolumnsonaline = 0
        for i in range(startline, endline+1):
            lineendpos = self.GetLineEndPosition(i)
            columnsonline = self.GetColumn(lineendpos)
            if columnsonline > longestcolumnsonaline:
                longestcolumnsonaline = columnsonline

        self.BeginUndoAction()
        for i in range(startline, endline+1):
            lineendpos = self.GetLineEndPosition(i)
            self.GotoPos(lineendpos)
            while self.GetColumn(self.GetCurrentPos()) < longestcolumnsonaline:
                self.AddText(u' ')
        self.EndUndoAction()

    def OnRMouseGestureMenu9(self, event):
        rightclickmenu = wx.Menu()

        p = wx.BITMAP_TYPE_PNG

        rcheader1 = wx.MenuItem(rightclickmenu, 0000, u'&R MGM 9 Options', u'ContextMenu9')
        rcheader1.SetBackgroundColour('#000000')
        rightclickmenu.AppendItem(rcheader1)
        rcheader1.SetDisabledBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousebuttonright16.png'),p).ConvertToBitmap())
        rcheader1.Enable(False)

        submenu = wx.Menu()
        mgm1 = wx.MenuItem(rightclickmenu, 3001, u'&R MGM 1', u' Call Mouse Gesture Menu 1')
        mgm1.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm1)

        mgm2 = wx.MenuItem(rightclickmenu, 3002, u'&R MGM 2 Wizard', u' Call Mouse Gesture Menu 2')
        mgm2.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm2)

        mgm3 = wx.MenuItem(rightclickmenu, 3003, u'&R MGM 3', u' Call Mouse Gesture Menu 3')
        mgm3.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm3)

        mgm4 = wx.MenuItem(rightclickmenu, 3004, u'&R MGM 4 Case', u' Call Mouse Gesture Menu 4')
        mgm4.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm4)

        mgm5 = wx.MenuItem(rightclickmenu, 3005, u'&R MGM 5', u' Call Mouse Gesture Menu 5')
        mgm5.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm5)

        mgm6 = wx.MenuItem(rightclickmenu, 3006, u'&R MGM 6 Conversion', u' Call Mouse Gesture Menu 6')
        mgm6.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm6)

        mgm7 = wx.MenuItem(rightclickmenu, 3007, u'&R MGM 7', u' Call Mouse Gesture Menu 7')
        mgm7.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm7)

        mgm8 = wx.MenuItem(rightclickmenu, 3008, u'&R MGM 8 Line Operations', u' Call Mouse Gesture Menu 8')
        mgm8.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'mousegesturemenu16.png'),p).ConvertToBitmap())
        submenu.AppendItem(mgm8)

        mgm9 = wx.MenuItem(rightclickmenu, 3009, u'&R MGM 9 You Are Here!', u' Call Mouse Gesture Menu 9')
        mgm9.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'youarehere16.png'),p).ConvertToBitmap())
        mgm9.SetBackgroundColour('#F4FAB4')
        mgm9.Enable(False)
        submenu.AppendItem(mgm9)
        rightclickmenu.AppendMenu(wx.NewId(), u'Mouse Gesture Menus', submenu)

        rightclickmenu.AppendSeparator()

        togglewhitespace = wx.MenuItem(rightclickmenu, 9001, u'&Toggle Whitespace', u' Toggle Whitespace')
        togglewhitespace.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'showwhitespace16.png'),p).ConvertToBitmap())
        rightclickmenu.AppendItem(togglewhitespace)

        toggleindentguides = wx.MenuItem(rightclickmenu, 9002, u'&Toggle Indent Guides', u' Toggle Indent Guides On/Off')
        toggleindentguides.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'showindentationguide16.png'),p).ConvertToBitmap())
        rightclickmenu.AppendItem(toggleindentguides)

        togglewordwrap = wx.MenuItem(rightclickmenu, 9003, u'&Toggle Wordwrap', u' Toggle Wordwrap On/Off')
        togglewordwrap.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'wordwrap16.png'),p).ConvertToBitmap())
        rightclickmenu.AppendItem(togglewordwrap)

        highlightselectedline = wx.MenuItem(rightclickmenu, 9004, u'&Highlight Selected Line', u' Highlight Selected Line')
        highlightselectedline.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'highlightcurrentline16.png'),p).ConvertToBitmap())
        rightclickmenu.AppendItem(highlightselectedline)

        toggleeolview = wx.MenuItem(rightclickmenu, 9005, u'&Toggle EOL View', u' Toggle Show/Hide End of line characters ')
        toggleeolview.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'eollf16.png'),p).ConvertToBitmap())
        rightclickmenu.AppendItem(toggleeolview)

        hmmm = wx.MenuItem(rightclickmenu, 9999, u'&Needs Label && ID6', u' StatusText Description Here')
        hmmm.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'black16.png'),p).ConvertToBitmap())
        rightclickmenu.AppendItem(hmmm)

        hmmm = wx.MenuItem(rightclickmenu, 9999, u'&Needs Label && ID7', u' StatusText Description Here')
        hmmm.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'showlinenumbers16.png'),p).ConvertToBitmap())
        rightclickmenu.AppendItem(hmmm)

        hmmm = wx.MenuItem(rightclickmenu, 9999, u'&Needs Label && ID8', u' StatusText Description Here')
        hmmm.SetBitmap(wx.Image(self.imgstcDir + os.sep + (u'black16.png'),p).ConvertToBitmap())
        rightclickmenu.AppendItem(hmmm)

        rightclickmenu.AppendSeparator()

        submenu_themes = wx.Menu()

        self.themedefault = wx.MenuItem(rightclickmenu, 7901, u'&Default Theme', u' Default Theme', kind = wx.ITEM_CHECK)
        self.themedefault.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'check16.png',p).ConvertToBitmap())
        submenu_themes.AppendItem(self.themedefault)
        if gGlobalsDict['ThemeOnStartup'] == 'Default': self.themedefault.Check(True)

        self.themeconsole = wx.MenuItem(rightclickmenu, 7902, u'&Console', u' Console Theme', kind = wx.ITEM_CHECK)
        self.themeconsole.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'check16.png',p).ConvertToBitmap())
        submenu_themes.AppendItem(self.themeconsole)
        if gGlobalsDict['ThemeOnStartup'] == 'Console': self.themeconsole.Check(True)

        self.themeobsidian = wx.MenuItem(rightclickmenu, 7903, u'&Obsidian', u' Obsidian Theme', kind = wx.ITEM_CHECK)
        self.themeobsidian.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'check16.png',p).ConvertToBitmap())
        submenu_themes.AppendItem(self.themeobsidian)
        if gGlobalsDict['ThemeOnStartup'] == 'Obsidian': self.themeobsidian.Check(True)

        self.themezenburn = wx.MenuItem(rightclickmenu, 7904, u'&Zenburn', u' Zenburn Theme', kind = wx.ITEM_CHECK)
        self.themezenburn.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'check16.png',p).ConvertToBitmap())
        submenu_themes.AppendItem(self.themezenburn)
        if gGlobalsDict['ThemeOnStartup'] == 'Zenburn': self.themezenburn.Check(True)

        self.thememonokai = wx.MenuItem(rightclickmenu, 7905, u'&Monokai', u' Monokai Theme', kind = wx.ITEM_CHECK)
        self.thememonokai.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'check16.png',p).ConvertToBitmap())
        submenu_themes.AppendItem(self.thememonokai)
        if gGlobalsDict['ThemeOnStartup'] == 'Monokai': self.thememonokai.Check(True)

        self.themedeepspace = wx.MenuItem(rightclickmenu, 7906, u'&Deep Space', u' Deep Space Theme', kind = wx.ITEM_CHECK)
        self.themedeepspace.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'check16.png',p).ConvertToBitmap())
        submenu_themes.AppendItem(self.themedeepspace)
        if gGlobalsDict['ThemeOnStartup'] == 'DeepSpace': self.themedeepspace.Check(True)

        self.themegreensideup = wx.MenuItem(rightclickmenu, 7907, u'&Green Side Up', u' Green Side Up Theme', kind = wx.ITEM_CHECK)
        self.themegreensideup.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'check16.png',p).ConvertToBitmap())
        submenu_themes.AppendItem(self.themegreensideup)
        if gGlobalsDict['ThemeOnStartup'] == 'GreenSideUp': self.themegreensideup.Check(True)

        self.themetwilight = wx.MenuItem(rightclickmenu, 7908, u'&Twilight', u' Twilight Theme', kind = wx.ITEM_CHECK)
        self.themetwilight.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'check16.png',p).ConvertToBitmap())
        submenu_themes.AppendItem(self.themetwilight)
        if gGlobalsDict['ThemeOnStartup'] == 'Twilight': self.themetwilight.Check(True)

        self.themeulipad = wx.MenuItem(rightclickmenu, 7909, u'&UliPad', u' UliPad Theme', kind = wx.ITEM_CHECK)
        self.themeulipad.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'check16.png',p).ConvertToBitmap())
        submenu_themes.AppendItem(self.themeulipad)
        if gGlobalsDict['ThemeOnStartup'] == 'Ulipad': self.themeulipad.Check(True)

        self.themehellokitty = wx.MenuItem(rightclickmenu, 7910, u'&Hello Kitty', u' Hello Kitty Theme', kind = wx.ITEM_CHECK)
        self.themehellokitty.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'check16.png',p).ConvertToBitmap())
        submenu_themes.AppendItem(self.themehellokitty)
        if gGlobalsDict['ThemeOnStartup'] == 'HelloKitty': self.themehellokitty.Check(True)

        self.themevibrantink = wx.MenuItem(rightclickmenu, 7911, u'&Vibrant Ink', u' Vibrant Ink Theme', kind = wx.ITEM_CHECK)
        self.themevibrantink.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'check16.png',p).ConvertToBitmap())
        submenu_themes.AppendItem(self.themevibrantink)
        if gGlobalsDict['ThemeOnStartup'] == 'VibrantInk': self.themevibrantink.Check(True)

        self.themebirdsofparidise = wx.MenuItem(rightclickmenu, 7912, u'&Birds of Paridise', u' Birds of Paridise Theme', kind = wx.ITEM_CHECK)
        self.themebirdsofparidise.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'check16.png',p).ConvertToBitmap())
        submenu_themes.AppendItem(self.themebirdsofparidise)
        if gGlobalsDict['ThemeOnStartup'] == 'BirdsOfParidise': self.themebirdsofparidise.Check(True)

        self.themeblacklight = wx.MenuItem(rightclickmenu, 7913, u'&BlackLight', u' BlackLight Theme', kind = wx.ITEM_CHECK)
        self.themeblacklight.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'check16.png',p).ConvertToBitmap())
        submenu_themes.AppendItem(self.themeblacklight)
        if gGlobalsDict['ThemeOnStartup'] == 'BlackLight': self.themeblacklight.Check(True)

        self.themenotebook = wx.MenuItem(rightclickmenu, 7914, u'&Notebook', u' Notebook Theme', kind = wx.ITEM_CHECK)
        self.themenotebook.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'check16.png',p).ConvertToBitmap())
        submenu_themes.AppendItem(self.themenotebook)
        if gGlobalsDict['ThemeOnStartup'] == 'Notebook': self.themenotebook.Check(True)

        submenu_themes.AppendSeparator()

        toggleeditortheme = wx.MenuItem(rightclickmenu, 7930, u'&Toggle Editor Themes\tF12', u' Toggle thru the various editor themes.')
        toggleeditortheme.SetBitmap(wx.Image(self.imgstcDir + os.sep + u'toggletheme24.png',p).ConvertToBitmap())
        submenu_themes.AppendItem(toggleeditortheme)

        rightclickmenu.AppendMenu(7900, u'Themes', submenu_themes)

        #events
        wx.EVT_MENU(rightclickmenu, 7901, self.OnDefaultTheme)
        wx.EVT_MENU(rightclickmenu, 7902, self.OnConsoleTheme)
        wx.EVT_MENU(rightclickmenu, 7903, self.OnObsidianTheme)
        wx.EVT_MENU(rightclickmenu, 7904, self.OnZenburnTheme)
        wx.EVT_MENU(rightclickmenu, 7905, self.OnMonokaiTheme)
        wx.EVT_MENU(rightclickmenu, 7906, self.OnDeepSpaceTheme)
        wx.EVT_MENU(rightclickmenu, 7907, self.OnGreenSideUpTheme)
        wx.EVT_MENU(rightclickmenu, 7908, self.OnTwilightTheme)
        wx.EVT_MENU(rightclickmenu, 7909, self.OnUliPadTheme)
        wx.EVT_MENU(rightclickmenu, 7910, self.OnHelloKittyTheme)
        wx.EVT_MENU(rightclickmenu, 7911, self.OnVibrantInkTheme)
        wx.EVT_MENU(rightclickmenu, 7912, self.OnBirdsOfParidiseTheme)
        wx.EVT_MENU(rightclickmenu, 7913, self.OnBlackLightTheme)
        wx.EVT_MENU(rightclickmenu, 7914, self.OnNotebookTheme)
        wx.EVT_MENU(rightclickmenu, 7930, self.OnToggleEditorThemes)

        wx.EVT_MENU(rightclickmenu, 9001, self.OnViewWhitespace)
        wx.EVT_MENU(rightclickmenu, 9002, self.OnShowIndentationGuides)
        wx.EVT_MENU(rightclickmenu, 9003, self.OnWordwrap)
        wx.EVT_MENU(rightclickmenu, 9004, self.OnHighlightSelectedLine)
        wx.EVT_MENU(rightclickmenu, 9005, self.OnShowEOL)

        wx.EVT_MENU(rightclickmenu, 3001, self.OnRMouseGestureMenu1)
        wx.EVT_MENU(rightclickmenu, 3002, self.OnRMouseGestureMenu2)
        wx.EVT_MENU(rightclickmenu, 3003, self.OnRMouseGestureMenu3)
        wx.EVT_MENU(rightclickmenu, 3004, self.OnRMouseGestureMenu4)
        wx.EVT_MENU(rightclickmenu, 3005, self.OnRMouseGestureMenuNone)
        wx.EVT_MENU(rightclickmenu, 3006, self.OnRMouseGestureMenu6)
        wx.EVT_MENU(rightclickmenu, 3007, self.OnRMouseGestureMenu7)
        wx.EVT_MENU(rightclickmenu, 3008, self.OnRMouseGestureMenu8)
        wx.EVT_MENU(rightclickmenu, 3009, self.OnRMouseGestureMenu9)

        self.PopupMenu(rightclickmenu)
        rightclickmenu.Destroy()

    def OnViewWhitespace(self, event):
        if   self.GetViewWhiteSpace() == 0: self.SetViewWhiteSpace(1)#0,1,or, 2
        elif self.GetViewWhiteSpace() == 1: self.SetViewWhiteSpace(2)
        elif self.GetViewWhiteSpace() == 2: self.SetViewWhiteSpace(0)

    def OnShowIndentationGuides(self, event):
        '''Toggle the indentation guides in the editor On/Off'''
        if self.GetIndentationGuides() == True: self.SetIndentationGuides(False)
        else: self.SetIndentationGuides(True)

    def OnWordwrap(self, event):
        '''Toggle Wordwrapping of the document in the editor On/Off'''
        if self.GetWrapMode() == True: self.SetWrapMode(False)
        else: self.SetWrapMode(True)

    def OnHighlightSelectedLine(self, event):
        '''Toggle highlighting the currently selected line(the one with the caret) in the editor On/Off'''
        if self.GetCaretLineVisible() == True: self.SetCaretLineVisible(False)
        else: self.SetCaretLineVisible(True)

    def OnShowEOL(self, event):
        ''' Toggle Show/Hide End of line characters '''
        if self.GetViewEOL() == 1: self.SetViewEOL(False)
        elif self.GetViewEOL() == 0: self.SetViewEOL(True)

    def OnSetFolderMarginStyle(self, event):#Called after STC is initialised MainWindow Initial Startup. Not sure why but calling it here in the class causes the fold symbols to not work quite properly at startup...
        if   gGlobalsDict['ThemeOnStartup'] == 'Default':         Color1 = '#000000'; Color2 = '#32CC99'#medium aquamarine
        elif gGlobalsDict['ThemeOnStartup'] == 'Console':         Color1 = '#BBBBBB'; Color2 = '#000000'
        elif gGlobalsDict['ThemeOnStartup'] == 'Obsidian':        Color1 = '#293134'; Color2 = '#66747B'
        elif gGlobalsDict['ThemeOnStartup'] == 'Zenburn':         Color1 = '#DCDCCC'; Color2 = '#3F3F3F'
        elif gGlobalsDict['ThemeOnStartup'] == 'Monokai':         Color1 = '#272822'; Color2 = '#75715E'
        elif gGlobalsDict['ThemeOnStartup'] == 'DeepSpace':       Color1 = '#0D0D0D'; Color2 = '#483C45'
        elif gGlobalsDict['ThemeOnStartup'] == 'GreenSideUp':     Color1 = '#12362B'; Color2 = '#FFFFFF'
        elif gGlobalsDict['ThemeOnStartup'] == 'Twilight':        Color1 = '#2E3436'; Color2 = '#F9EE98'
        elif gGlobalsDict['ThemeOnStartup'] == 'UliPad':          Color1 = '#FFFFFF'; Color2 = '#F0804F'
        elif gGlobalsDict['ThemeOnStartup'] == 'HelloKitty':      Color1 = '#FF0000'; Color2 = '#FFFFFF'
        elif gGlobalsDict['ThemeOnStartup'] == 'VibrantInk':      Color1 = '#333333'; Color2 = '#999999'
        elif gGlobalsDict['ThemeOnStartup'] == 'BirdsOfParidise': Color1 = '#423230'; Color2 = '#D9D458'
        elif gGlobalsDict['ThemeOnStartup'] == 'BlackLight':      Color1 = '#FF7800'; Color2 = '#535AE9'
        elif gGlobalsDict['ThemeOnStartup'] == 'Notebook':        Color1 = '#000000'; Color2 = '#A0D6E2'

        elif gGlobalsDict['FolderMarginStyle'] == 1: self.OnFolderMarginStyle1(event, Color1, Color2)
        elif gGlobalsDict['FolderMarginStyle'] == 2: self.OnFolderMarginStyle2(event, Color1, Color2)
        elif gGlobalsDict['FolderMarginStyle'] == 5: self.OnFolderMarginStyle5(event, Color1, Color2)
        elif gGlobalsDict['FolderMarginStyle'] == 6: self.OnFolderMarginStyle6(event, Color1, Color2)

        if   gGlobalsDict['ThemeOnStartup'] == 'Default':         Color1 = '#32CC99'; Color2 = '#000000'
        elif gGlobalsDict['ThemeOnStartup'] == 'Console':         Color1 = '#000000'; Color2 = '#BBBBBB'
        elif gGlobalsDict['ThemeOnStartup'] == 'Obsidian':        Color1 = '#293134'; Color2 = '#66747B'
        elif gGlobalsDict['ThemeOnStartup'] == 'Zenburn':         Color1 = '#DCDCCC'; Color2 = '#3F3F3F'
        elif gGlobalsDict['ThemeOnStartup'] == 'Monokai':         Color1 = '#75715E'; Color2 = '#272822'
        elif gGlobalsDict['ThemeOnStartup'] == 'DeepSpace':       Color1 = '#483C45'; Color2 = '#0D0D0D'
        elif gGlobalsDict['ThemeOnStartup'] == 'GreenSideUp':     Color1 = '#FFFFFF'; Color2 = '#12362B'
        elif gGlobalsDict['ThemeOnStartup'] == 'Twilight':        Color1 = '#F9EE98'; Color2 = '#2E3436'
        elif gGlobalsDict['ThemeOnStartup'] == 'UliPad':          Color1 = '#F0804F'; Color2 = '#FFFFFF'
        elif gGlobalsDict['ThemeOnStartup'] == 'HelloKitty':      Color1 = '#FFFFFF'; Color2 = '#FF0000'
        elif gGlobalsDict['ThemeOnStartup'] == 'VibrantInk':      Color1 = '#999999'; Color2 = '#333333'
        elif gGlobalsDict['ThemeOnStartup'] == 'BirdsOfParidise': Color1 = '#D9D458'; Color2 = '#423230'
        elif gGlobalsDict['ThemeOnStartup'] == 'BlackLight':      Color1 = '#535AE9'; Color2 = '#FF7800'
        elif gGlobalsDict['ThemeOnStartup'] == 'Notebook':        Color1 = '#A0D6E2'; Color2 = '#000000'

        if   gGlobalsDict['FolderMarginStyle'] == 3: self.OnFolderMarginStyle3(event, Color1, Color2)
        elif gGlobalsDict['FolderMarginStyle'] == 4: self.OnFolderMarginStyle4(event, Color1, Color2)

    def OnFolderMarginStyle1(self, event, Color1, Color2):
        gGlobalsDict['FolderMarginStyle'] = 1
        # Arrow pointing right for contracted folders, arrow pointing down for expanded
        self.MarkerDefine(stc.STC_MARKNUM_FOLDEROPEN,    stc.STC_MARK_ARROWDOWN, Color1 , Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDER,        stc.STC_MARK_ARROW,     Color1 , Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDERSUB,     stc.STC_MARK_EMPTY,     Color1 , Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDERTAIL,    stc.STC_MARK_EMPTY,     Color1 , Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDEREND,     stc.STC_MARK_EMPTY,     Color1 , Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDEROPENMID, stc.STC_MARK_EMPTY,     Color1 , Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDERMIDTAIL, stc.STC_MARK_EMPTY,     Color1 , Color2)
    def OnFolderMarginStyle2(self, event, Color1, Color2):
        gGlobalsDict['FolderMarginStyle'] = 2
        # Plus for contracted folders, minus for expanded
        self.MarkerDefine(stc.STC_MARKNUM_FOLDEROPEN,    stc.STC_MARK_MINUS, Color1 , Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDER,        stc.STC_MARK_PLUS,  Color1 , Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDERSUB,     stc.STC_MARK_EMPTY, Color1 , Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDERTAIL,    stc.STC_MARK_EMPTY, Color1 , Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDEREND,     stc.STC_MARK_EMPTY, Color1 , Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDEROPENMID, stc.STC_MARK_EMPTY, Color1 , Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDERMIDTAIL, stc.STC_MARK_EMPTY, Color1 , Color2)
    def OnFolderMarginStyle3(self, event, Color1, Color2):
        gGlobalsDict['FolderMarginStyle'] = 3
        # Like a flattened tree control using circular headers and curved joins
        self.MarkerDefine(stc.STC_MARKNUM_FOLDEROPEN,    stc.STC_MARK_CIRCLEMINUS,          Color1, Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDER,        stc.STC_MARK_CIRCLEPLUS,           Color1, Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDERSUB,     stc.STC_MARK_VLINE,                Color1, Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDERTAIL,    stc.STC_MARK_LCORNERCURVE,         Color1, Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDEREND,     stc.STC_MARK_CIRCLEPLUSCONNECTED,  Color1, Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDEROPENMID, stc.STC_MARK_CIRCLEMINUSCONNECTED, Color1, Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDERMIDTAIL, stc.STC_MARK_TCORNERCURVE,         Color1, Color2)
    def OnFolderMarginStyle4(self, event, Color1, Color2):
        gGlobalsDict['FolderMarginStyle'] = 4
        # Like a flattened tree control using square headers
        self.MarkerDefine(stc.STC_MARKNUM_FOLDEROPEN,    stc.STC_MARK_BOXMINUS,          Color1, Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDER,        stc.STC_MARK_BOXPLUS,           Color1, Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDERSUB,     stc.STC_MARK_VLINE,             Color1, Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDERTAIL,    stc.STC_MARK_LCORNER,           Color1, Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDEREND,     stc.STC_MARK_BOXPLUSCONNECTED,  Color1, Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDEROPENMID, stc.STC_MARK_BOXMINUSCONNECTED, Color1, Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDERMIDTAIL, stc.STC_MARK_TCORNER,           Color1, Color2)
    def OnFolderMarginStyle5(self, event, Color1, Color2):
        gGlobalsDict['FolderMarginStyle'] = 5
        # Arrows >>> pointing right for contracted folders, dotdotdot ... for expanded
        self.MarkerDefine(stc.STC_MARKNUM_FOLDEROPEN,    stc.STC_MARK_ARROWS,    Color1 , Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDER,        stc.STC_MARK_DOTDOTDOT, Color1 , Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDERSUB,     stc.STC_MARK_EMPTY,     Color1 , Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDERTAIL,    stc.STC_MARK_EMPTY,     Color1 , Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDEREND,     stc.STC_MARK_EMPTY,     Color1 , Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDEROPENMID, stc.STC_MARK_EMPTY,     Color1 , Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDERMIDTAIL, stc.STC_MARK_EMPTY,     Color1 , Color2)
    def OnFolderMarginStyle6(self, event, Color1, Color2):
        gGlobalsDict['FolderMarginStyle'] = 6
        # Arrows >>> pointing right for contracted folders, dotdotdot ... for expanded
        self.MarkerDefine(stc.STC_MARKNUM_FOLDEROPEN,    stc.STC_MARK_SHORTARROW, Color1 , Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDER,        stc.STC_MARK_CIRCLE,     Color1 , Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDERSUB,     stc.STC_MARK_EMPTY,      Color1 , Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDERTAIL,    stc.STC_MARK_EMPTY,      Color1 , Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDEREND,     stc.STC_MARK_EMPTY,      Color1 , Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDEROPENMID, stc.STC_MARK_EMPTY,      Color1 , Color2)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDERMIDTAIL, stc.STC_MARK_EMPTY,      Color1 , Color2)

    def OnSetTheme(self, event):
        if   gGlobalsDict['ThemeOnStartup'] == 'Default':         self.OnDefaultTheme(event)
        elif gGlobalsDict['ThemeOnStartup'] == 'Console':         self.OnConsoleTheme(event)
        elif gGlobalsDict['ThemeOnStartup'] == 'Obsidian':        self.OnObsidianTheme(event)
        elif gGlobalsDict['ThemeOnStartup'] == 'Zenburn':         self.OnZenburnTheme(event)
        elif gGlobalsDict['ThemeOnStartup'] == 'Monokai':         self.OnMonokaiTheme(event)
        elif gGlobalsDict['ThemeOnStartup'] == 'DeepSpace':       self.OnDeepSpaceTheme(event)
        elif gGlobalsDict['ThemeOnStartup'] == 'GreenSideUp':     self.OnGreenSideUpTheme(event)
        elif gGlobalsDict['ThemeOnStartup'] == 'Twilight':        self.OnTwilightTheme(event)
        elif gGlobalsDict['ThemeOnStartup'] == 'UliPad':          self.OnUliPadTheme(event)
        elif gGlobalsDict['ThemeOnStartup'] == 'HelloKitty':      self.OnHelloKittyTheme(event)
        elif gGlobalsDict['ThemeOnStartup'] == 'VibrantInk':      self.OnVibrantInkTheme(event)
        elif gGlobalsDict['ThemeOnStartup'] == 'BirdsOfParidise': self.OnBirdsOfParidiseTheme(event)
        elif gGlobalsDict['ThemeOnStartup'] == 'BlackLight':      self.OnBlackLightTheme(event)
        elif gGlobalsDict['ThemeOnStartup'] == 'Notebook':        self.OnNotebookTheme(event)
        else:
            print ('ThemeOnStartup ERROR!!!!!!!!!!!!\nOnSetTheme')

    def OnToggleEditorThemes(self, event):
        if   gGlobalsDict['ThemeOnStartup'] == 'Default':         self.OnConsoleTheme(event)
        elif gGlobalsDict['ThemeOnStartup'] == 'Console':         self.OnObsidianTheme(event)
        elif gGlobalsDict['ThemeOnStartup'] == 'Obsidian':        self.OnZenburnTheme(event)
        elif gGlobalsDict['ThemeOnStartup'] == 'Zenburn':         self.OnMonokaiTheme(event)
        elif gGlobalsDict['ThemeOnStartup'] == 'Monokai':         self.OnDeepSpaceTheme(event)
        elif gGlobalsDict['ThemeOnStartup'] == 'DeepSpace':       self.OnGreenSideUpTheme(event)
        elif gGlobalsDict['ThemeOnStartup'] == 'GreenSideUp':     self.OnTwilightTheme(event)
        elif gGlobalsDict['ThemeOnStartup'] == 'Twilight':        self.OnUliPadTheme(event)
        elif gGlobalsDict['ThemeOnStartup'] == 'UliPad':          self.OnHelloKittyTheme(event)
        elif gGlobalsDict['ThemeOnStartup'] == 'HelloKitty':      self.OnVibrantInkTheme(event)
        elif gGlobalsDict['ThemeOnStartup'] == 'VibrantInk':      self.OnBirdsOfParidiseTheme(event)
        elif gGlobalsDict['ThemeOnStartup'] == 'BirdsOfParidise': self.OnBlackLightTheme(event)
        elif gGlobalsDict['ThemeOnStartup'] == 'BlackLight':      self.OnNotebookTheme(event)
        elif gGlobalsDict['ThemeOnStartup'] == 'Notebook':        self.OnDefaultTheme(event)

    def OnDefaultTheme(self, event):
        gGlobalsDict['ThemeOnStartup'] = 'Default'

        self.StyleSetSpec(stc.STC_STYLE_DEFAULT,     'fore:#000000,back:#FFFFFF,face:%(mono)s,size:%(size)d' % faces)#Always call this twice. before and after StyleClearAll()
        self.ClearDocumentStyle()
        self.StyleClearAll()
        self.SetCaretLineBackground('#D7DEEB')
        self.SetCaretForeground('#0000FF')

        self.rmousegesture.SetGesturePen('Black', 5)

        self.SetFoldMarginHiColour(True, '#FFFFFF')
        self.SetFoldMarginColour(True, '#E0E0E0')  #Set the colours used as a chequerboard pattern in the fold margin #Sometimes Visually, this is glitchy looking when moving the window with colors other than default.

        self.StyleSetSpec(stc.STC_STYLE_DEFAULT,     'fore:#000000,back:#FFFFFF,face:%(mono)s,size:%(size)d' % faces)
        self.StyleSetSpec(stc.STC_STYLE_INDENTGUIDE, 'fore:#33FF33,back:#FF0000')
        self.StyleSetSpec(stc.STC_STYLE_LINENUMBER,  'fore:#000000,back:#99AA99,face:%(mono)s,size:%(size2)d' % faces)
        self.StyleSetSpec(stc.STC_STYLE_CONTROLCHAR, 'fore:#000000,back:#FFFFFF')
        self.StyleSetSpec(stc.STC_STYLE_BRACELIGHT,  'fore:#FF0000,back:#ACACFF,bold')
        self.StyleSetSpec(stc.STC_STYLE_BRACEBAD,    'fore:#000000,back:#FF0000,bold')

        self.SetWhitespaceForeground(True, '#000000')
        self.SetWhitespaceBackground(False,'#FFFFFF')

        self.SetSelForeground(False, '#000000')
        self.SetSelBackground(True,  '#C0C0C0')

        # print ('LoadSTCLexer : ', gGlobalsDict['LoadSTCLexer'])
        if gGlobalsDict['LoadSTCLexer'] == 'pythonlexer' or gGlobalsDict['LoadSTCLexer'] == 'wizbainlexer':
            # Make the Python styles ...
            self.StyleSetSpec(stc.STC_P_DEFAULT,        'fore:#000000,back:#FFFFFF')
            self.StyleSetSpec(stc.STC_P_COMMENTLINE,    'fore:#007F00,back:#EAFFE9')
            self.StyleSetSpec(stc.STC_P_NUMBER,         'fore:#FF0000,back:#FFFFFF')
            self.StyleSetSpec(stc.STC_P_STRING,         'fore:#FF8000,back:#FFFFFF')
            self.StyleSetSpec(stc.STC_P_CHARACTER,      'fore:#FF8000,back:#FFFFFF')
            self.StyleSetSpec(stc.STC_P_WORD,           'fore:#FF0000,back:#FFFFFF')
            self.StyleSetSpec(stc.STC_P_WORD2,          'fore:#6000FF,back:#FFFFFF')
            self.StyleSetSpec(stc.STC_P_TRIPLE,         'fore:#000000,back:#FFF7EE')
            self.StyleSetSpec(stc.STC_P_TRIPLEDOUBLE,   'fore:#FF8000,back:#FFF7EE')
            self.StyleSetSpec(stc.STC_P_CLASSNAME,      'fore:#0000FF,back:#FFFFFF,bold,underline')
            self.StyleSetSpec(stc.STC_P_DEFNAME,        'fore:#007F7F,back:#FFFFFF,bold')
            self.StyleSetSpec(stc.STC_P_OPERATOR,       'fore:#000000,back:#FFFFFF')
            self.StyleSetSpec(stc.STC_P_IDENTIFIER,     'fore:#000000,back:#FFFFFF')
            self.StyleSetSpec(stc.STC_P_COMMENTBLOCK,   'fore:#7F7F7F,back:#F8FFF8')
            self.StyleSetSpec(stc.STC_P_STRINGEOL,      'fore:#000000,back:#E0C0E0,eol')
            self.StyleSetSpec(stc.STC_P_DECORATOR,      'fore:#000000,back:#FFFFFF')

            self.StyleSetHotSpot(stc.STC_P_WORD, True) #This keeps the hotspots active when moused over
            self.StyleSetHotSpot(stc.STC_P_WORD2, True)

        self.Colourise(0, self.GetLength())
        self.OnSetFolderMarginStyle(event)
        for i in range(0,stc.STC_INDIC_MAX + 1): self.IndicatorSetForeground(i,'#FF0000')
        # print('Default Theme')

    def OnConsoleTheme(self, event):
        gGlobalsDict['ThemeOnStartup'] = 'Console'

        self.StyleSetSpec(stc.STC_STYLE_DEFAULT,     'fore:#BBBBBB,back:#000000,face:%(mono)s,size:%(size)d' % faces)
        self.ClearDocumentStyle()
        self.StyleClearAll()
        self.SetCaretLineBackground('#333333')
        self.SetCaretForeground('#AAB716')

        self.rmousegesture.SetGesturePen('White', 5)

        self.SetFoldMarginHiColour(True, '#000000')
        self.SetFoldMarginColour(True, '#222222')

        self.StyleSetSpec(stc.STC_STYLE_DEFAULT,     'fore:#BBBBBB,back:#000000,face:%(mono)s,size:%(size)d' % faces)
        self.StyleSetSpec(stc.STC_STYLE_INDENTGUIDE, 'fore:#AAAAAA,back:#000000')
        self.StyleSetSpec(stc.STC_STYLE_LINENUMBER,  'fore:#BBBBBB,back:#222222,bold,face:%(mono)s,size:%(size2)d' % faces)
        # self.StyleSetSpec(stc.STC_STYLE_CONTROLCHAR, 'fore:#000000,back:#FFFFFF,face:%(mono)s' % faces)
        self.StyleSetSpec(stc.STC_STYLE_BRACELIGHT,  'fore:#FF0000,back:#0000FF,bold')
        self.StyleSetSpec(stc.STC_STYLE_BRACEBAD,    'fore:#000000,back:#FF0000,bold')

        self.SetWhitespaceForeground(True, '#BBBBBB')
        self.SetWhitespaceBackground(False,'#FFFFFF')

        self.SetSelForeground(False, '#43BBE2')
        self.SetSelBackground(True,  '#444444')

        if gGlobalsDict['LoadSTCLexer'] == 'pythonlexer' or gGlobalsDict['LoadSTCLexer'] == 'wizbainlexer':
            # Python styles
            self.StyleSetSpec(stc.STC_P_DEFAULT,        'fore:#BBBBBB,back:#000000')
            self.StyleSetSpec(stc.STC_P_COMMENTLINE,    'fore:#007F00,back:#000000')
            self.StyleSetSpec(stc.STC_P_NUMBER,         'fore:#FF0000,back:#000000')
            self.StyleSetSpec(stc.STC_P_STRING,         'fore:#FF8000,back:#000000')
            self.StyleSetSpec(stc.STC_P_CHARACTER,      'fore:#FF8000,back:#000000')
            self.StyleSetSpec(stc.STC_P_WORD,           'fore:#FF0000,back:#000000')
            self.StyleSetSpec(stc.STC_P_WORD2,          'fore:#6000FF,back:#000000')
            self.StyleSetSpec(stc.STC_P_TRIPLE,         'fore:#FFBB19,back:#332505')
            self.StyleSetSpec(stc.STC_P_TRIPLEDOUBLE,   'fore:#FFBB19,back:#000000')
            self.StyleSetSpec(stc.STC_P_CLASSNAME,      'fore:#0000FF,back:#000000,bold,underline')
            self.StyleSetSpec(stc.STC_P_DEFNAME,        'fore:#007F7F,back:#000000,bold')
            self.StyleSetSpec(stc.STC_P_OPERATOR,       'fore:#BBBBBB,back:#000000,bold')
            self.StyleSetSpec(stc.STC_P_IDENTIFIER,     'fore:#BBBBBB,back:#000000')
            self.StyleSetSpec(stc.STC_P_COMMENTBLOCK,   'fore:#7F7F7F,back:#000000')
            self.StyleSetSpec(stc.STC_P_STRINGEOL,      'fore:#BBBBBB,back:#000000,eol')
            self.StyleSetSpec(stc.STC_P_DECORATOR,      'fore:#BBBBBB,back:#000000')

            self.StyleSetHotSpot(stc.STC_P_WORD, True)
            self.StyleSetHotSpot(stc.STC_P_WORD2, True)

        self.Colourise(0, self.GetLength())
        self.OnSetFolderMarginStyle(event)
        for i in range(0,stc.STC_INDIC_MAX + 1): self.IndicatorSetForeground(i,'#FF0000')
        # print('Console Theme')

    def OnObsidianTheme(self, event):
        gGlobalsDict['ThemeOnStartup'] = 'Obsidian'

        self.StyleSetSpec(stc.STC_STYLE_DEFAULT,       'fore:#E0E2E4,back:#293134,face:%(mono)s,size:%(size)d' % faces)
        self.ClearDocumentStyle()
        self.StyleClearAll()
        self.SetCaretLineBackground('#2F393C')
        self.SetCaretForeground('#C1CBD2')

        self.rmousegesture.SetGesturePen('Black', 5)

        self.SetFoldMarginHiColour(True, '#3F4B4E')
        self.SetFoldMarginColour(True, '#293134')

        self.StyleSetSpec(stc.STC_STYLE_DEFAULT,       'fore:#E0E2E4,back:#293134,face:%(mono)s,size:%(size)d' % faces)
        self.StyleSetSpec(stc.STC_STYLE_INDENTGUIDE,   'fore:#394448,back:#293134')
        self.StyleSetSpec(stc.STC_STYLE_LINENUMBER,    'fore:#81969A,back:#3F4B4E,bold,face:%(mono)s,size:%(size2)d' % faces)
        # self.StyleSetSpec(stc.STC_STYLE_CONTROLCHAR, 'fore:#000000,back:#FFFFFF,face:%(mono)s' % faces)
        self.StyleSetSpec(stc.STC_STYLE_BRACELIGHT,    'fore:#F3DB2E,back:#293134,bold')
        self.StyleSetSpec(stc.STC_STYLE_BRACEBAD,      'fore:#FB0000,back:#293134,bold')

        self.SetWhitespaceForeground(True, '#343F43')
        self.SetWhitespaceBackground(False,'#293134')

        self.SetSelForeground(False, '#C00000')
        self.SetSelBackground(True,  '#404E51')

        if gGlobalsDict['LoadSTCLexer'] == 'pythonlexer' or gGlobalsDict['LoadSTCLexer'] == 'wizbainlexer':
            # Python styles
            self.StyleSetSpec(stc.STC_P_DEFAULT,        'fore:#E0E2E4,back:#293134')
            self.StyleSetSpec(stc.STC_P_COMMENTLINE,    'fore:#66747B,back:#293134')
            self.StyleSetSpec(stc.STC_P_NUMBER,         'fore:#FFCD22,back:#293134')
            self.StyleSetSpec(stc.STC_P_STRING,         'fore:#EC7600,back:#293134')
            self.StyleSetSpec(stc.STC_P_CHARACTER,      'fore:#FF8409,back:#293134')
            self.StyleSetSpec(stc.STC_P_WORD,           'fore:#C7BA63,back:#293134')
            self.StyleSetSpec(stc.STC_P_WORD2,          'fore:#93C763,back:#293134')
            self.StyleSetSpec(stc.STC_P_TRIPLE,         'fore:#66747B,back:#293134')
            self.StyleSetSpec(stc.STC_P_TRIPLEDOUBLE,   'fore:#66747B,back:#293134')
            self.StyleSetSpec(stc.STC_P_CLASSNAME,      'fore:#A082BD,back:#293134,bold,underline')
            self.StyleSetSpec(stc.STC_P_DEFNAME,        'fore:#678CB1,back:#293134,bold')
            self.StyleSetSpec(stc.STC_P_OPERATOR,       'fore:#E8E2B7,back:#293134,bold')
            self.StyleSetSpec(stc.STC_P_IDENTIFIER,     'fore:#E0E2E4,back:#293134')
            self.StyleSetSpec(stc.STC_P_COMMENTBLOCK,   'fore:#66747B,back:#293134')
            self.StyleSetSpec(stc.STC_P_STRINGEOL,      'fore:#E0E2E4,back:#293134,eol')
            self.StyleSetSpec(stc.STC_P_DECORATOR,      'fore:#BBBBBB,back:#000000')

            self.StyleSetHotSpot(stc.STC_P_WORD, True)
            self.StyleSetHotSpot(stc.STC_P_WORD2, True)

        self.Colourise(0, self.GetLength())
        self.OnSetFolderMarginStyle(event)
        for i in range(0,stc.STC_INDIC_MAX + 1): self.IndicatorSetForeground(i,'#FF0000')
        # print('Obsidian Theme')

    def OnZenburnTheme(self, event):
        gGlobalsDict['ThemeOnStartup'] = 'Zenburn'

        self.StyleSetSpec(stc.STC_STYLE_DEFAULT,       'fore:#DCDCCC,back:#3F3F3F,face:%(mono)s,size:%(size)d' % faces)
        self.ClearDocumentStyle()
        self.StyleClearAll()
        self.SetCaretLineBackground('#101010')
        self.SetCaretForeground('#8FAF9F')

        self.rmousegesture.SetGesturePen('Black', 5)

        self.SetFoldMarginHiColour(True, '#3F3F3F')
        self.SetFoldMarginColour(True, '#8A8A8A')

        self.StyleSetSpec(stc.STC_STYLE_DEFAULT,       'fore:#DCDCCC,back:#3F3F3F,face:%(mono)s,size:%(size)d' % faces)
        self.StyleSetSpec(stc.STC_STYLE_INDENTGUIDE,   'fore:#4F5F5F,back:#3F3F3F')
        self.StyleSetSpec(stc.STC_STYLE_LINENUMBER,    'fore:#8A8A8A,back:#535353,bold,face:%(mono)s,size:%(size2)d' % faces)
        # self.StyleSetSpec(stc.STC_STYLE_CONTROLCHAR, 'fore:#000000,back:#FFFFFF,face:%(mono)s' % faces)
        self.StyleSetSpec(stc.STC_STYLE_BRACELIGHT,    'fore:#F0F9F9,back:#3F3F3F,bold')
        self.StyleSetSpec(stc.STC_STYLE_BRACEBAD,      'fore:#F09F9F,back:#3F3F3F,bold')

        self.SetWhitespaceForeground(True, '#5F5F5F')
        self.SetWhitespaceBackground(False,'#3F3F3F')

        self.SetSelForeground(False, '#C00000')
        self.SetSelBackground(True,  '#585858')

        if gGlobalsDict['LoadSTCLexer'] == 'pythonlexer' or gGlobalsDict['LoadSTCLexer'] == 'wizbainlexer':
            # Python styles
            self.StyleSetSpec(stc.STC_P_DEFAULT,        'fore:#DCDCCC,back:#3F3F3F')
            self.StyleSetSpec(stc.STC_P_COMMENTLINE,    'fore:#7F9F7F,back:#3F3F3F')
            self.StyleSetSpec(stc.STC_P_NUMBER,         'fore:#8CD0D3,back:#3F3F3F')
            self.StyleSetSpec(stc.STC_P_STRING,         'fore:#CC9393,back:#3F3F3F')
            self.StyleSetSpec(stc.STC_P_CHARACTER,      'fore:#DCA3A3,back:#3F3F3F')
            self.StyleSetSpec(stc.STC_P_WORD,           'fore:#DFC47D,back:#3F3F3F')
            self.StyleSetSpec(stc.STC_P_WORD2,          'fore:#DFC47D,back:#3F3F3F')
            self.StyleSetSpec(stc.STC_P_TRIPLE,         'fore:#7F9F7F,back:#3F3F3F')
            self.StyleSetSpec(stc.STC_P_TRIPLEDOUBLE,   'fore:#7F9F7F,back:#3F3F3F')
            self.StyleSetSpec(stc.STC_P_CLASSNAME,      'fore:#DCDCCC,back:#3F3F3F,bold,underline')
            self.StyleSetSpec(stc.STC_P_DEFNAME,        'fore:#CEDF99,back:#3F3F3F,bold')
            self.StyleSetSpec(stc.STC_P_OPERATOR,       'fore:#9F9D6D,back:#3F3F3F,bold')
            self.StyleSetSpec(stc.STC_P_IDENTIFIER,     'fore:#DCDCCC,back:#3F3F3F')
            self.StyleSetSpec(stc.STC_P_COMMENTBLOCK,   'fore:#7F9F7F,back:#3F3F3F')
            self.StyleSetSpec(stc.STC_P_STRINGEOL,      'fore:#CC9393,back:#3F3F3F,eol')
            self.StyleSetSpec(stc.STC_P_DECORATOR,      'fore:#BBBBBB,back:#000000')

            self.StyleSetHotSpot(stc.STC_P_WORD, True)
            self.StyleSetHotSpot(stc.STC_P_WORD2, True)

        self.Colourise(0, self.GetLength())
        self.OnSetFolderMarginStyle(event)
        for i in range(0,stc.STC_INDIC_MAX + 1): self.IndicatorSetForeground(i,'#FF0000')
        # print('Zenburn Theme')

    def OnMonokaiTheme(self, event):
        gGlobalsDict['ThemeOnStartup'] = 'Monokai'

        self.StyleSetSpec(stc.STC_STYLE_DEFAULT,       'fore:#F8F8F2,back:#272822,face:%(mono)s,size:%(size)d' % faces)
        self.ClearDocumentStyle()
        self.StyleClearAll()
        self.SetCaretLineBackground('#101010')
        self.SetCaretForeground('#8FAF9F')

        self.rmousegesture.SetGesturePen('Black', 5)

        self.SetFoldMarginHiColour(True, '#E6DB74')
        self.SetFoldMarginColour(True, '#888888')

        self.StyleSetSpec(stc.STC_STYLE_DEFAULT,       'fore:#F8F8F2,back:#272822,face:%(mono)s,size:%(size)d' % faces)
        self.StyleSetSpec(stc.STC_STYLE_INDENTGUIDE,   'fore:#888A85,back:#272822')
        self.StyleSetSpec(stc.STC_STYLE_LINENUMBER,    'fore:#EEEEEC,back:#2D2E27,bold,face:%(mono)s,size:%(size2)d' % faces)
        # self.StyleSetSpec(stc.STC_STYLE_CONTROLCHAR, 'fore:#000000,back:#FFFFFF,face:%(mono)s' % faces)
        self.StyleSetSpec(stc.STC_STYLE_BRACELIGHT,    'fore:#FCE94F,back:#272822,bold')
        self.StyleSetSpec(stc.STC_STYLE_BRACEBAD,      'fore:#EF2929,back:#272822,bold')

        self.SetWhitespaceForeground(True, '#75715E')
        self.SetWhitespaceBackground(False,'#272822')

        self.SetSelForeground(False, '#8000FF')
        self.SetSelBackground(True,  '#49483E')

        if gGlobalsDict['LoadSTCLexer'] == 'pythonlexer' or gGlobalsDict['LoadSTCLexer'] == 'wizbainlexer':
            # Python styles
            self.StyleSetSpec(stc.STC_P_DEFAULT,        'fore:#F8F8F2,back:#272822')
            self.StyleSetSpec(stc.STC_P_COMMENTLINE,    'fore:#75715E,back:#272822')
            self.StyleSetSpec(stc.STC_P_NUMBER,         'fore:#AE81FF,back:#272822,size:%(size)d' % faces)
            self.StyleSetSpec(stc.STC_P_STRING,         'fore:#E6DB74,back:#272822')
            self.StyleSetSpec(stc.STC_P_CHARACTER,      'fore:#E6DB74,back:#272822')
            self.StyleSetSpec(stc.STC_P_WORD,           'fore:#66D9EF,back:#272822')
            self.StyleSetSpec(stc.STC_P_WORD2,          'fore:#F92672,back:#272822')
            self.StyleSetSpec(stc.STC_P_TRIPLE,         'fore:#E6DB74,back:#272822')
            self.StyleSetSpec(stc.STC_P_TRIPLEDOUBLE,   'fore:#E6DB74,back:#272822')
            self.StyleSetSpec(stc.STC_P_CLASSNAME,      'fore:#F8F8F2,back:#272822,bold,underline')
            self.StyleSetSpec(stc.STC_P_DEFNAME,        'fore:#A6E22E,back:#272822,bold')
            self.StyleSetSpec(stc.STC_P_OPERATOR,       'fore:#FD7620,back:#272822,bold')
            self.StyleSetSpec(stc.STC_P_IDENTIFIER,     'fore:#FFFFFF,back:#272822')
            self.StyleSetSpec(stc.STC_P_COMMENTBLOCK,   'fore:#75715E,back:#272822')
            self.StyleSetSpec(stc.STC_P_STRINGEOL,      'fore:#E6DB74,back:#F92672,eol')
            self.StyleSetSpec(stc.STC_P_DECORATOR,      'fore:#BBBBBB,back:#000000')

            self.StyleSetHotSpot(stc.STC_P_WORD, True)
            self.StyleSetHotSpot(stc.STC_P_WORD2, True)

        self.Colourise(0, self.GetLength())
        self.OnSetFolderMarginStyle(event)
        for i in range(0,stc.STC_INDIC_MAX + 1): self.IndicatorSetForeground(i,'#FF0000')
        # print('Monokai Theme')

    def OnDeepSpaceTheme(self, event):
        gGlobalsDict['ThemeOnStartup'] = 'DeepSpace'

        self.StyleSetSpec(stc.STC_STYLE_DEFAULT,       'fore:#FFFFFF,back:#000000,face:%(mono)s,size:%(size)d' % faces)
        self.ClearDocumentStyle()
        self.StyleClearAll()
        self.SetCaretLineBackground('#101010')
        self.SetCaretForeground('#8FAF9F')

        self.rmousegesture.SetGesturePen('White', 5)

        self.SetFoldMarginHiColour(True, '#805978')
        self.SetFoldMarginColour(True, '#888888')

        self.StyleSetSpec(stc.STC_STYLE_DEFAULT,       'fore:#FFFFFF,back:#0D0D0D,face:%(mono)s,size:%(size)d' % faces)
        self.StyleSetSpec(stc.STC_STYLE_INDENTGUIDE,   'fore:#888A85,back:#0D0D0D')
        self.StyleSetSpec(stc.STC_STYLE_LINENUMBER,    'fore:#75796E,back:#0D0D0D,bold,face:%(mono)s,size:%(size2)d' % faces)
        # self.StyleSetSpec(stc.STC_STYLE_CONTROLCHAR,   'fore:#1EFF00,back:#1EFF00,face:%(mono)s' % faces)
        self.StyleSetSpec(stc.STC_STYLE_BRACELIGHT,    'fore:#6EA65A,back:#0D0D0D,bold')
        self.StyleSetSpec(stc.STC_STYLE_BRACEBAD,      'fore:#EF2929,back:#0D0D0D,bold')

        self.SetWhitespaceForeground(True, '#805978')
        self.SetWhitespaceBackground(False,'#0D0D0D')

        self.SetSelForeground(False, '#8000FF')
        self.SetSelBackground(True,  '#26061E')

        if gGlobalsDict['LoadSTCLexer'] == 'pythonlexer' or gGlobalsDict['LoadSTCLexer'] == 'wizbainlexer':
            # Python styles
            self.StyleSetSpec(stc.STC_P_DEFAULT,        'fore:#F8F8F2,back:#0D0D0D')
            self.StyleSetSpec(stc.STC_P_COMMENTLINE,    'fore:#483C45,back:#0D0D0D')
            self.StyleSetSpec(stc.STC_P_NUMBER,         'fore:#A8885A,back:#0D0D0D')
            self.StyleSetSpec(stc.STC_P_STRING,         'fore:#805978,back:#0D0D0D')
            self.StyleSetSpec(stc.STC_P_CHARACTER,      'fore:#805978,back:#0D0D0D')
            self.StyleSetSpec(stc.STC_P_WORD,           'fore:#9EBF60,back:#0D0D0D')
            self.StyleSetSpec(stc.STC_P_WORD2,          'fore:#566F39,back:#0D0D0D')
            self.StyleSetSpec(stc.STC_P_TRIPLE,         'fore:#805978,back:#0D0D0D')
            self.StyleSetSpec(stc.STC_P_TRIPLEDOUBLE,   'fore:#805978,back:#0D0D0D')
            self.StyleSetSpec(stc.STC_P_CLASSNAME,      'fore:#6078BF,back:#0D0D0D,bold,underline')
            self.StyleSetSpec(stc.STC_P_DEFNAME,        'fore:#6078BF,back:#0D0D0D,bold')
            self.StyleSetSpec(stc.STC_P_OPERATOR,       'fore:#596380,back:#0D0D0D,bold')
            self.StyleSetSpec(stc.STC_P_IDENTIFIER,     'fore:#BBBBBB,back:#0D0D0D')
            self.StyleSetSpec(stc.STC_P_COMMENTBLOCK,   'fore:#483C45,back:#0D0D0D')
            self.StyleSetSpec(stc.STC_P_STRINGEOL,      'fore:#FF00FF,back:#5F0047,eol')
            self.StyleSetSpec(stc.STC_P_DECORATOR,      'fore:#BBBBBB,back:#0D0D0D')

            self.StyleSetHotSpot(stc.STC_P_WORD, True)
            self.StyleSetHotSpot(stc.STC_P_WORD2, True)

        self.Colourise(0, self.GetLength())
        self.OnSetFolderMarginStyle(event)
        for i in range(0,stc.STC_INDIC_MAX + 1): self.IndicatorSetForeground(i,'#FF00FF')
        # print('Deep Space Theme')

    def OnGreenSideUpTheme(self, event):
        gGlobalsDict['ThemeOnStartup'] = 'GreenSideUp'

        self.StyleSetSpec(stc.STC_STYLE_DEFAULT,       'fore:#00FF00,back:#000000,face:%(mono)s,size:%(size)d' % faces)
        self.ClearDocumentStyle()
        self.StyleClearAll()
        self.SetCaretLineBackground('#657868')
        self.SetCaretForeground('#8FAF9F')

        self.rmousegesture.SetGesturePen('#8000FF', 5)

        self.SetFoldMarginHiColour(True, '#00FF00')
        self.SetFoldMarginColour(True, '#888888')

        self.StyleSetSpec(stc.STC_STYLE_DEFAULT,       'fore:#00FF00,back:#000000,face:%(mono)s,size:%(size)d' % faces)
        self.StyleSetSpec(stc.STC_STYLE_INDENTGUIDE,   'fore:#548045,back:#000000')
        self.StyleSetSpec(stc.STC_STYLE_LINENUMBER,    'fore:#00FF0A,back:#111111,bold,face:%(mono)s,size:%(size2)d' % faces)
        # self.StyleSetSpec(stc.STC_STYLE_CONTROLCHAR,   'fore:#1EFF00,back:#1EFF00,face:%(mono)s' % faces)
        self.StyleSetSpec(stc.STC_STYLE_BRACELIGHT,    'fore:#6EA65A,back:#000000,bold')
        self.StyleSetSpec(stc.STC_STYLE_BRACEBAD,      'fore:#EF2929,back:#000000,bold')

        self.SetWhitespaceForeground(True, '#8AC392')
        self.SetWhitespaceBackground(False,'#000000')

        self.SetSelForeground(True, '#8000FF')
        self.SetSelBackground(True, '#333333')

        if gGlobalsDict['LoadSTCLexer'] == 'pythonlexer' or gGlobalsDict['LoadSTCLexer'] == 'wizbainlexer':
            # Python styles
            self.StyleSetSpec(stc.STC_P_DEFAULT,        'fore:#BBBBBB,back:#000000')
            self.StyleSetSpec(stc.STC_P_COMMENTLINE,    'fore:#00AA00,back:#3B5930')
            self.StyleSetSpec(stc.STC_P_NUMBER,         'fore:#479D1C,back:#000000')
            self.StyleSetSpec(stc.STC_P_STRING,         'fore:#50E064,back:#000000')
            self.StyleSetSpec(stc.STC_P_CHARACTER,      'fore:#50E064,back:#000000')
            self.StyleSetSpec(stc.STC_P_WORD,           'fore:#3B5930,back:#000000,bold')
            self.StyleSetSpec(stc.STC_P_WORD2,          'fore:#3B5930,back:#000000,bold')
            self.StyleSetSpec(stc.STC_P_TRIPLE,         'fore:#50E064,back:#000000')
            self.StyleSetSpec(stc.STC_P_TRIPLEDOUBLE,   'fore:#50E064,back:#000000')
            self.StyleSetSpec(stc.STC_P_CLASSNAME,      'fore:#0B6518,back:#000000,bold,underline')
            self.StyleSetSpec(stc.STC_P_DEFNAME,        'fore:#0B6518,back:#000000,bold')
            self.StyleSetSpec(stc.STC_P_OPERATOR,       'fore:#5BBF69,back:#000000,bold')
            self.StyleSetSpec(stc.STC_P_IDENTIFIER,     'fore:#00FF00,back:#000000')
            self.StyleSetSpec(stc.STC_P_COMMENTBLOCK,   'fore:#00AA00,back:#3B5930' % faces)
            self.StyleSetSpec(stc.STC_P_STRINGEOL,      'fore:#000000,back:#00FF00,eol' % faces)#
            self.StyleSetSpec(stc.STC_P_DECORATOR,      'fore:#BBBBBB,back:#000000' % faces)

            self.StyleSetHotSpot(stc.STC_P_WORD, True)
            self.StyleSetHotSpot(stc.STC_P_WORD2, True)

        self.Colourise(0, self.GetLength())
        self.OnSetFolderMarginStyle(event)
        for i in range(0,stc.STC_INDIC_MAX + 1): self.IndicatorSetForeground(i,'#8000FF')
        # print('Green Side Up Theme')

    def OnTwilightTheme(self, event):
        gGlobalsDict['ThemeOnStartup'] = 'Twilight'

        self.StyleSetSpec(stc.STC_STYLE_DEFAULT,       'fore:#FFFFFF,back:#141414,face:%(mono)s,size:%(size)d' % faces)
        self.ClearDocumentStyle()
        self.StyleClearAll()
        self.SetCaretLineBackground('#292929')
        self.SetCaretForeground('#A7A7A7')

        self.rmousegesture.SetGesturePen('White', 5)

        self.SetFoldMarginHiColour(True, '#8F9D6A')
        self.SetFoldMarginColour(True, '#888888')

        self.StyleSetSpec(stc.STC_STYLE_DEFAULT,       'fore:#FFFFFF,back:#141414,face:%(mono)s,size:%(size)d' % faces)
        self.StyleSetSpec(stc.STC_STYLE_INDENTGUIDE,   'fore:#888A85,back:#141414')
        self.StyleSetSpec(stc.STC_STYLE_LINENUMBER,    'fore:#EEEEEC,back:#2E3436,bold,face:%(mono)s,size:%(size2)d' % faces)
        # self.StyleSetSpec(stc.STC_STYLE_CONTROLCHAR,   'fore:#1EFF00,back:#1EFF00,face:%(mono)s' % faces)
        self.StyleSetSpec(stc.STC_STYLE_BRACELIGHT,    'fore:#6EA65A,back:#141414,bold')
        self.StyleSetSpec(stc.STC_STYLE_BRACEBAD,      'fore:#EF2929,back:#141414,bold')

        self.SetWhitespaceForeground(True, '#FCAF3E')
        self.SetWhitespaceBackground(False,'#141414')

        self.SetSelForeground(False, '#8000FF')
        self.SetSelBackground(True,  '#3E3E3E')

        if gGlobalsDict['LoadSTCLexer'] == 'pythonlexer' or gGlobalsDict['LoadSTCLexer'] == 'wizbainlexer':
            # Python styles
            self.StyleSetSpec(stc.STC_P_DEFAULT,        'fore:#F8F8F8,back:#141414')
            self.StyleSetSpec(stc.STC_P_COMMENTLINE,    'fore:#5F5A60,back:#141414')
            self.StyleSetSpec(stc.STC_P_NUMBER,         'fore:#7587A6,back:#141414')
            self.StyleSetSpec(stc.STC_P_STRING,         'fore:#8F9D6A,back:#141414')
            self.StyleSetSpec(stc.STC_P_CHARACTER,      'fore:#8F9D6A,back:#141414')
            self.StyleSetSpec(stc.STC_P_WORD,           'fore:#F9EE98,back:#141414')
            self.StyleSetSpec(stc.STC_P_WORD2,          'fore:#CDA869,back:#141414')
            self.StyleSetSpec(stc.STC_P_TRIPLE,         'fore:#8F9D6A,back:#141414')
            self.StyleSetSpec(stc.STC_P_TRIPLEDOUBLE,   'fore:#8F9D6A,back:#141414')
            self.StyleSetSpec(stc.STC_P_CLASSNAME,      'fore:#9B703F,back:#141414,bold,underline')
            self.StyleSetSpec(stc.STC_P_DEFNAME,        'fore:#9B703F,back:#141414,bold')
            self.StyleSetSpec(stc.STC_P_OPERATOR,       'fore:#CDA869,back:#141414,bold')
            self.StyleSetSpec(stc.STC_P_IDENTIFIER,     'fore:#F8F8F8,back:#141414')
            self.StyleSetSpec(stc.STC_P_COMMENTBLOCK,   'fore:#5F5A60,back:#141414')
            self.StyleSetSpec(stc.STC_P_STRINGEOL,      'fore:#8F9D6A,back:#452645,eol')
            self.StyleSetSpec(stc.STC_P_DECORATOR,      'fore:#BBBBBB,back:#141414')

            self.StyleSetHotSpot(stc.STC_P_WORD, True)
            self.StyleSetHotSpot(stc.STC_P_WORD2, True)

        self.Colourise(0, self.GetLength())
        self.OnSetFolderMarginStyle(event)
        for i in range(0,stc.STC_INDIC_MAX + 1): self.IndicatorSetForeground(i,'#4526DD')
        # print('Twilight Theme')

    def OnUliPadTheme(self, event):
        gGlobalsDict['ThemeOnStartup'] = 'UliPad'

        self.StyleSetSpec(stc.STC_STYLE_DEFAULT,       'fore:#FFFFFF,back:#112435,face:%(mono)s,size:%(size)d' % faces)
        self.ClearDocumentStyle()
        self.StyleClearAll()
        self.SetCaretLineBackground('#413FFF')
        self.SetCaretForeground('#FF0000')

        self.rmousegesture.SetGesturePen('Black', 5)

        self.SetFoldMarginHiColour(True, '#3476A3')
        self.SetFoldMarginColour(True, '#FFFFFF')

        self.StyleSetSpec(stc.STC_STYLE_DEFAULT,       'fore:#FFFFFF,back:#112435,face:%(mono)s,size:%(size)d' % faces)
        self.StyleSetSpec(stc.STC_STYLE_INDENTGUIDE,   'fore:#888A85,back:#112435')
        self.StyleSetSpec(stc.STC_STYLE_LINENUMBER,    'fore:#FFFFFF,back:#1F4661,bold,face:%(mono)s,size:%(size2)d' % faces)
        # self.StyleSetSpec(stc.STC_STYLE_CONTROLCHAR,   'fore:#1EFF00,back:#1EFF00,face:%(mono)s' % faces)
        self.StyleSetSpec(stc.STC_STYLE_BRACELIGHT,    'fore:#FF0000,back:#112435,bold')
        self.StyleSetSpec(stc.STC_STYLE_BRACEBAD,      'fore:#FFFFFF,back:#112435,bold')

        self.SetWhitespaceForeground(True, '#8DB0D3')
        self.SetWhitespaceBackground(False,'#112435')

        self.SetSelForeground(False, '#8000FF')
        self.SetSelBackground(True,  '#2E9F27')

        if gGlobalsDict['LoadSTCLexer'] == 'pythonlexer' or gGlobalsDict['LoadSTCLexer'] == 'wizbainlexer':
            # Python styles
            self.StyleSetSpec(stc.STC_P_DEFAULT,        'fore:#8DB0D3,back:#112435')
            self.StyleSetSpec(stc.STC_P_COMMENTLINE,    'fore:#00CFCB,back:#112435')
            self.StyleSetSpec(stc.STC_P_NUMBER,         'fore:#FF00FF,back:#112435')
            self.StyleSetSpec(stc.STC_P_STRING,         'fore:#00FF80,back:#112435')
            self.StyleSetSpec(stc.STC_P_CHARACTER,      'fore:#E19618,back:#112435')
            self.StyleSetSpec(stc.STC_P_WORD,           'fore:#FFFF00,back:#112435')
            self.StyleSetSpec(stc.STC_P_WORD2,          'fore:#FFFF00,back:#112435')
            self.StyleSetSpec(stc.STC_P_TRIPLE,         'fore:#00FF80,back:#112435')
            self.StyleSetSpec(stc.STC_P_TRIPLEDOUBLE,   'fore:#00FF80,back:#112435')
            self.StyleSetSpec(stc.STC_P_CLASSNAME,      'fore:#BBFF4F,back:#112435,bold,underline')
            self.StyleSetSpec(stc.STC_P_DEFNAME,        'fore:#8DAF57,back:#112435,bold')
            self.StyleSetSpec(stc.STC_P_OPERATOR,       'fore:#F0804F,back:#112435,bold')
            self.StyleSetSpec(stc.STC_P_IDENTIFIER,     'fore:#8DB0D3,back:#112435')
            self.StyleSetSpec(stc.STC_P_COMMENTBLOCK,   'fore:#00CFCB,back:#112435')
            self.StyleSetSpec(stc.STC_P_STRINGEOL,      'fore:#FF6F82,back:#E0C0E0,eol')
            self.StyleSetSpec(stc.STC_P_DECORATOR,      'fore:#BBBBBB,back:#112435')

            self.StyleSetHotSpot(stc.STC_P_WORD, True)
            self.StyleSetHotSpot(stc.STC_P_WORD2, True)

        self.Colourise(0, self.GetLength())
        self.OnSetFolderMarginStyle(event)
        for i in range(0,stc.STC_INDIC_MAX + 1): self.IndicatorSetForeground(i,'#FF0000')
        # print('UliPad Theme')

    def OnHelloKittyTheme(self, event):
        gGlobalsDict['ThemeOnStartup'] = 'HelloKitty'

        self.StyleSetSpec(stc.STC_STYLE_DEFAULT,     'fore:#000000,back:#FFB0FF,face:%(mono)s,size:%(size)d' % faces)
        self.ClearDocumentStyle()
        self.StyleClearAll()
        self.SetCaretLineBackground('#FF80C0')
        self.SetCaretForeground('#372017')

        self.rmousegesture.SetGesturePen('Black', 5)

        self.SetFoldMarginHiColour(True, '#FF80C0')
        self.SetFoldMarginColour(True, '#FF80C0')

        self.StyleSetSpec(stc.STC_STYLE_DEFAULT,     'fore:#000000,back:#FFB0FF,face:%(mono)s,size:%(size)d' % faces)
        self.StyleSetSpec(stc.STC_STYLE_INDENTGUIDE, 'fore:#C0C0C0,back:#FFB0FF')
        self.StyleSetSpec(stc.STC_STYLE_LINENUMBER,  'fore:#FFFFFF,back:#FF80FF,face:%(mono)s,size:%(size2)d' % faces)
        # self.StyleSetSpec(stc.STC_STYLE_CONTROLCHAR, 'fore:#000000,back:#FFFFFF')
        self.StyleSetSpec(stc.STC_STYLE_BRACELIGHT,  'fore:#FF0000,back:#FFB0FF,bold')
        self.StyleSetSpec(stc.STC_STYLE_BRACEBAD,    'fore:#800000,back:#FFB0FF,bold')

        self.SetWhitespaceForeground(True, '#FFB56A')
        self.SetWhitespaceBackground(False,'#FFFFFF')

        self.SetSelForeground(False, '#FFD5FF')
        self.SetSelBackground(True,  '#FFD5FF')

        if gGlobalsDict['LoadSTCLexer'] == 'pythonlexer' or gGlobalsDict['LoadSTCLexer'] == 'wizbainlexer':
            #Python Styles
            self.StyleSetSpec(stc.STC_P_DEFAULT,        'fore:#000000,back:#FFB0FF')
            self.StyleSetSpec(stc.STC_P_COMMENTLINE,    'fore:#008000,back:#FFB0FF')
            self.StyleSetSpec(stc.STC_P_NUMBER,         'fore:#FF0000,back:#FFB0FF')
            self.StyleSetSpec(stc.STC_P_STRING,         'fore:#808080,back:#FFB0FF')
            self.StyleSetSpec(stc.STC_P_CHARACTER,      'fore:#808080,back:#FFB0FF')
            self.StyleSetSpec(stc.STC_P_WORD,           'fore:#0000FF,back:#FFB0FF,bold')
            self.StyleSetSpec(stc.STC_P_WORD2,          'fore:#0000FF,back:#FFB0FF,bold')
            self.StyleSetSpec(stc.STC_P_TRIPLE,         'fore:#FF8000,back:#FFB0FF')
            self.StyleSetSpec(stc.STC_P_TRIPLEDOUBLE,   'fore:#000000,back:#FFB0FF')
            self.StyleSetSpec(stc.STC_P_CLASSNAME,      'fore:#000000,back:#FFB0FF,bold,underline')
            self.StyleSetSpec(stc.STC_P_DEFNAME,        'fore:#FF00FF,back:#FFB0FF,bold')
            self.StyleSetSpec(stc.STC_P_OPERATOR,       'fore:#000080,back:#FFB0FF,bold')
            self.StyleSetSpec(stc.STC_P_IDENTIFIER,     'fore:#000000,back:#FFB0FF')
            self.StyleSetSpec(stc.STC_P_COMMENTBLOCK,   'fore:#008000,back:#FFB0FF')
            self.StyleSetSpec(stc.STC_P_STRINGEOL,      'fore:#FFFF00,back:#E0C0E0,eol')
            self.StyleSetSpec(stc.STC_P_DECORATOR,      'fore:#000000,back:#FFB0FF')

            self.StyleSetHotSpot(stc.STC_P_WORD, True)
            self.StyleSetHotSpot(stc.STC_P_WORD2, True)

        self.Colourise(0, self.GetLength())
        self.OnSetFolderMarginStyle(event)
        for i in range(0,stc.STC_INDIC_MAX + 1): self.IndicatorSetForeground(i,'#FF0000')
        # print('Hello Kitty Theme')

    def OnVibrantInkTheme(self, event):
        gGlobalsDict['ThemeOnStartup'] = 'VibrantInk'

        self.StyleSetSpec(stc.STC_STYLE_DEFAULT,     'fore:#FFFFFF,back:#000000,face:%(mono)s,size:%(size)d' % faces)
        self.ClearDocumentStyle()
        self.StyleClearAll()
        self.SetCaretLineBackground('#333333')
        self.SetCaretForeground('#FFFFFF')

        self.rmousegesture.SetGesturePen('White', 5)

        self.SetFoldMarginHiColour(True, '#111111')
        self.SetFoldMarginColour(True, '#222222')

        self.StyleSetSpec(stc.STC_STYLE_DEFAULT,     'fore:#FFFFFF,back:#000000,face:%(mono)s,size:%(size)d' % faces)
        self.StyleSetSpec(stc.STC_STYLE_INDENTGUIDE, 'fore:#C0C0C0,back:#000000')
        self.StyleSetSpec(stc.STC_STYLE_LINENUMBER,  'fore:#E4E4E4,back:#333333,face:%(mono)s,size:%(size2)d' % faces)
        self.StyleSetSpec(stc.STC_STYLE_CONTROLCHAR, 'fore:#FFFFFF,back:#000000')
        self.StyleSetSpec(stc.STC_STYLE_BRACELIGHT,  'fore:#99CC99,back:#000000,bold')
        self.StyleSetSpec(stc.STC_STYLE_BRACEBAD,    'fore:#CCFF33,back:#000000,bold')

        self.SetWhitespaceForeground(True, '#FF8080')
        self.SetWhitespaceBackground(False,'#000000')

        self.SetSelForeground(False, '#8000FF')
        self.SetSelBackground(True,  '#6699CC')

        if gGlobalsDict['LoadSTCLexer'] == 'pythonlexer' or gGlobalsDict['LoadSTCLexer'] == 'wizbainlexer':
            #Python Styles
            self.StyleSetSpec(stc.STC_P_DEFAULT,        'fore:#FFFFFF,back:#000000')
            self.StyleSetSpec(stc.STC_P_COMMENTLINE,    'fore:#9933CC,back:#000000')
            self.StyleSetSpec(stc.STC_P_NUMBER,         'fore:#99CC99,back:#000000')
            self.StyleSetSpec(stc.STC_P_STRING,         'fore:#66FF00,back:#000000')
            self.StyleSetSpec(stc.STC_P_CHARACTER,      'fore:#66FF00,back:#000000')
            self.StyleSetSpec(stc.STC_P_WORD,           'fore:#FF6600,back:#000000,bold')
            self.StyleSetSpec(stc.STC_P_WORD2,          'fore:#FF6600,back:#000000,bold')
            self.StyleSetSpec(stc.STC_P_TRIPLE,         'fore:#FF8000,back:#000000')
            self.StyleSetSpec(stc.STC_P_TRIPLEDOUBLE,   'fore:#FFFFFF,back:#000000')
            self.StyleSetSpec(stc.STC_P_CLASSNAME,      'fore:#FFFFFF,back:#000000,bold,underline')
            self.StyleSetSpec(stc.STC_P_DEFNAME,        'fore:#FF00FF,back:#000000,bold')
            self.StyleSetSpec(stc.STC_P_OPERATOR,       'fore:#FFCC00,back:#000000,bold')
            self.StyleSetSpec(stc.STC_P_IDENTIFIER,     'fore:#FFFFFF,back:#000000')
            self.StyleSetSpec(stc.STC_P_COMMENTBLOCK,   'fore:#9933CC,back:#000000')
            self.StyleSetSpec(stc.STC_P_STRINGEOL,      'fore:#FFFF00,back:#000000,eol')
            self.StyleSetSpec(stc.STC_P_DECORATOR,      'fore:#FFFFFF,back:#000000')

            self.StyleSetHotSpot(stc.STC_P_WORD, True)
            self.StyleSetHotSpot(stc.STC_P_WORD2, True)

        self.Colourise(0, self.GetLength())
        self.OnSetFolderMarginStyle(event)
        for i in range(0,stc.STC_INDIC_MAX + 1): self.IndicatorSetForeground(i,'#FF0000')
        # print('Vibrant Ink Theme')

    def OnBirdsOfParidiseTheme(self, event):
        gGlobalsDict['ThemeOnStartup'] = 'BirdsOfParidise'

        self.StyleSetSpec(stc.STC_STYLE_DEFAULT,     'fore:#E6E1C4,back:#423230,face:%(mono)s,size:%(size)d' % faces)
        self.ClearDocumentStyle()
        self.StyleClearAll()
        self.SetCaretLineBackground('#292119')
        self.SetCaretForeground('#FFFFFF')

        self.rmousegesture.SetGesturePen('Black', 5)

        self.SetFoldMarginHiColour(True, '#FFFFFF')
        self.SetFoldMarginColour(True, '#E6E1C4')

        self.StyleSetSpec(stc.STC_STYLE_DEFAULT,     'fore:#E6E1C4,back:#423230,face:%(mono)s,size:%(size)d' % faces)
        self.StyleSetSpec(stc.STC_STYLE_INDENTGUIDE, 'fore:#C0C0C0,back:#423230')
        self.StyleSetSpec(stc.STC_STYLE_LINENUMBER,  'fore:#E6E1C4,back:#4A3937,face:%(mono)s,size:%(size2)d' % faces)
        # self.StyleSetSpec(stc.STC_STYLE_CONTROLCHAR, 'fore:#FFFFFF,back:#423230')
        self.StyleSetSpec(stc.STC_STYLE_BRACELIGHT,  'fore:#99CC99,back:#423230,bold')
        self.StyleSetSpec(stc.STC_STYLE_BRACEBAD,    'fore:#FF0000,back:#FFFFFF,bold')

        self.SetWhitespaceForeground(True, '#5E4A31')
        self.SetWhitespaceBackground(False,'#000000')

        self.SetSelForeground(False, '#8000FF')
        self.SetSelBackground(True,  '#393126')

        if gGlobalsDict['LoadSTCLexer'] == 'pythonlexer' or gGlobalsDict['LoadSTCLexer'] == 'wizbainlexer':
            #Python Styles
            self.StyleSetSpec(stc.STC_P_DEFAULT,        'fore:#E6E1C4,back:#423230')
            self.StyleSetSpec(stc.STC_P_COMMENTLINE,    'fore:#6B4A31,back:#423230,bold,italic')
            self.StyleSetSpec(stc.STC_P_NUMBER,         'fore:#6A99BB,back:#423230')
            self.StyleSetSpec(stc.STC_P_STRING,         'fore:#D9D458,back:#423230')
            self.StyleSetSpec(stc.STC_P_CHARACTER,      'fore:#D9D458,back:#423230')
            self.StyleSetSpec(stc.STC_P_WORD,           'fore:#EF5A31,back:#423230,bold')
            self.StyleSetSpec(stc.STC_P_WORD2,          'fore:#EF5A31,back:#423230,bold')
            self.StyleSetSpec(stc.STC_P_TRIPLE,         'fore:#E6E1C4,back:#423230')
            self.StyleSetSpec(stc.STC_P_TRIPLEDOUBLE,   'fore:#E6E1C4,back:#423230')
            self.StyleSetSpec(stc.STC_P_CLASSNAME,      'fore:#EFA431,back:#423230,bold')
            self.StyleSetSpec(stc.STC_P_DEFNAME,        'fore:#78AC9C,back:#423230,bold')
            self.StyleSetSpec(stc.STC_P_OPERATOR,       'fore:#E6E1C4,back:#423230,bold')
            self.StyleSetSpec(stc.STC_P_IDENTIFIER,     'fore:#E6E1C4,back:#423230')
            self.StyleSetSpec(stc.STC_P_COMMENTBLOCK,   'fore:#6B4A31,back:#423230,bold,italic')
            self.StyleSetSpec(stc.STC_P_STRINGEOL,      'fore:#D94C30,back:#EFA431,bold,eol')
            self.StyleSetSpec(stc.STC_P_DECORATOR,      'fore:#FFFFFF,back:#423230')

            self.StyleSetHotSpot(stc.STC_P_WORD, True)
            self.StyleSetHotSpot(stc.STC_P_WORD2, True)

        self.Colourise(0, self.GetLength())
        self.OnSetFolderMarginStyle(event)
        for i in range(0,stc.STC_INDIC_MAX + 1): self.IndicatorSetForeground(i,'#FF0000')
        # print('Birds of Paridise Theme')

    def OnBlackLightTheme(self, event):
        gGlobalsDict['ThemeOnStartup'] = 'BlackLight'

        self.StyleSetSpec(stc.STC_STYLE_DEFAULT,     'fore:#DDDDDD,back:#000000,face:%(mono)s,size:%(size)d' % faces)
        self.ClearDocumentStyle()
        self.StyleClearAll()
        self.SetCaretLineBackground('#131D2E')
        self.SetCaretForeground('#FFFFFF')

        self.rmousegesture.SetGesturePen('#24276E', 5)

        self.SetFoldMarginHiColour(True, '#535AE9')
        self.SetFoldMarginColour(True, '#24276E')

        self.StyleSetSpec(stc.STC_STYLE_DEFAULT,     'fore:#DDDDDD,back:#000000,face:%(mono)s,size:%(size)d' % faces)
        self.StyleSetSpec(stc.STC_STYLE_INDENTGUIDE, 'fore:#3F5456,back:#000000')
        self.StyleSetSpec(stc.STC_STYLE_LINENUMBER,  'fore:#296050,back:#000000,bold,face:%(mono)s,size:%(size2)d' % faces)
        # self.StyleSetSpec(stc.STC_STYLE_CONTROLCHAR, 'fore:#FFFFFF,back:#000000')
        self.StyleSetSpec(stc.STC_STYLE_BRACELIGHT,  'fore:#99CC99,back:#000000,bold')
        self.StyleSetSpec(stc.STC_STYLE_BRACEBAD,    'fore:#FF0000,back:#000000,bold')

        self.SetWhitespaceForeground(True, '#3F5456')
        self.SetWhitespaceBackground(False,'#000000')

        self.SetSelForeground(True,  '#535AE9')
        self.SetSelBackground(True,  '#24276E')

        if gGlobalsDict['LoadSTCLexer'] == 'pythonlexer' or gGlobalsDict['LoadSTCLexer'] == 'wizbainlexer':
            #Python Styles
            self.StyleSetSpec(stc.STC_P_DEFAULT,        'fore:#E6E1C4,back:#000000')
            self.StyleSetSpec(stc.STC_P_COMMENTLINE,    'fore:#3F5456,back:#000000,bold,italic')
            self.StyleSetSpec(stc.STC_P_NUMBER,         'fore:#6A99BB,back:#000000')
            self.StyleSetSpec(stc.STC_P_STRING,         'fore:#81D9A6,back:#296050')
            self.StyleSetSpec(stc.STC_P_CHARACTER,      'fore:#81D9A6,back:#296050')
            self.StyleSetSpec(stc.STC_P_WORD,           'fore:#EB4D8E,back:#000000,bold')
            self.StyleSetSpec(stc.STC_P_WORD2,          'fore:#B8DB6F,back:#000000,bold')
            self.StyleSetSpec(stc.STC_P_TRIPLE,         'fore:#535AE9,back:#000000')
            self.StyleSetSpec(stc.STC_P_TRIPLEDOUBLE,   'fore:#535AE9,back:#000000')
            self.StyleSetSpec(stc.STC_P_CLASSNAME,      'fore:#3F99AA,back:#000000,bold')
            self.StyleSetSpec(stc.STC_P_DEFNAME,        'fore:#3F99AA,back:#000000,bold')
            self.StyleSetSpec(stc.STC_P_OPERATOR,       'fore:#787767,back:#000000,bold')
            self.StyleSetSpec(stc.STC_P_IDENTIFIER,     'fore:#DDDDDD,back:#000000')
            self.StyleSetSpec(stc.STC_P_COMMENTBLOCK,   'fore:#3F5456,back:#000000,bold,italic')
            self.StyleSetSpec(stc.STC_P_STRINGEOL,      'fore:#5E4DFF,back:#BAFF4D,bold,eol')
            self.StyleSetSpec(stc.STC_P_DECORATOR,      'fore:#594851,back:#000000')

            self.StyleSetHotSpot(stc.STC_P_WORD, True)
            self.StyleSetHotSpot(stc.STC_P_WORD2, True)

        self.Colourise(0, self.GetLength())
        self.OnSetFolderMarginStyle(event)
        for i in range(0,stc.STC_INDIC_MAX + 1): self.IndicatorSetForeground(i,'#535AE9')
        # print('BlackLight Theme')

    def OnNotebookTheme(self, event):
        gGlobalsDict['ThemeOnStartup'] = 'Notebook'

        self.StyleSetSpec(stc.STC_STYLE_DEFAULT,     'fore:#000000,back:#CAC2AD,face:%(mono)s,size:%(size)d' % faces)
        self.ClearDocumentStyle()
        self.StyleClearAll()
        self.SetCaretLineBackground('#BBB09C')
        self.SetCaretLineBackAlpha(gGlobalsDict['CaretLineBackgroundAlpha'])
        self.SetCaretForeground('#7C7563')

        self.rmousegesture.SetGesturePen('Black', 5)

        self.SetFoldMarginHiColour(True, '#BBB39E')
        self.SetFoldMarginColour(True, '#CAC2AD')

        self.StyleSetSpec(stc.STC_STYLE_DEFAULT,     'fore:#000000,back:#CAC2AD,face:%(mono)s,size:%(size)d' % faces)
        self.StyleSetSpec(stc.STC_STYLE_INDENTGUIDE, 'fore:#7C7563,back:#CAC2AD')
        self.StyleSetSpec(stc.STC_STYLE_LINENUMBER,  'fore:#000000,back:#CAC2AD,face:%(mono)s,size:%(size2)d' % faces)
        # self.StyleSetSpec(stc.STC_STYLE_CONTROLCHAR, 'fore:#0000FF,back:#CAC2AD')
        self.StyleSetSpec(stc.STC_STYLE_BRACELIGHT,  'fore:#265729,back:#99CC99,bold')
        self.StyleSetSpec(stc.STC_STYLE_BRACEBAD,    'fore:#FF0000,back:#CAC2AD,bold')

        self.SetWhitespaceForeground(True, '#7C7563')
        self.SetWhitespaceBackground(False,'#000000')

        self.SetSelForeground(True, '#000000')
        self.SetSelBackground(True,  '#9A9384')

        if gGlobalsDict['LoadSTCLexer'] == 'pythonlexer' or gGlobalsDict['LoadSTCLexer'] == 'wizbainlexer':
            #Python Styles
            self.StyleSetSpec(stc.STC_P_DEFAULT,        'fore:#E6E1C4,back:#CAC2AD')
            self.StyleSetSpec(stc.STC_P_COMMENTLINE,    'fore:#000000,back:#B0EE65,bold')
            self.StyleSetSpec(stc.STC_P_NUMBER,         'fore:#000000,back:#B1A0E2')
            self.StyleSetSpec(stc.STC_P_STRING,         'fore:#000000,back:#E2D855')
            self.StyleSetSpec(stc.STC_P_CHARACTER,      'fore:#000000,back:#E2D855')
            self.StyleSetSpec(stc.STC_P_WORD,           'fore:#000000,back:#BBB09C,bold')
            self.StyleSetSpec(stc.STC_P_WORD2,          'fore:#000000,back:#E2C4A0,bold')
            self.StyleSetSpec(stc.STC_P_TRIPLE,         'fore:#7C7563,back:#CAC2AD')
            self.StyleSetSpec(stc.STC_P_TRIPLEDOUBLE,   'fore:#7C7563,back:#CAC2AD')
            self.StyleSetSpec(stc.STC_P_CLASSNAME,      'fore:#000000,back:#DFA0AB,bold,underline')
            self.StyleSetSpec(stc.STC_P_DEFNAME,        'fore:#000000,back:#A0D6E2')
            self.StyleSetSpec(stc.STC_P_OPERATOR,       'fore:#7C7563,back:#CAC2AD,bold')
            self.StyleSetSpec(stc.STC_P_IDENTIFIER,     'fore:#000000,back:#CAC2AD')
            self.StyleSetSpec(stc.STC_P_COMMENTBLOCK,   'fore:#000000,back:#B0EE65,bold')
            self.StyleSetSpec(stc.STC_P_STRINGEOL,      'fore:#E2A0A0,back:#D94C30,bold,eol')
            self.StyleSetSpec(stc.STC_P_DECORATOR,      'fore:#000000,back:#888888')

            self.StyleSetHotSpot(stc.STC_P_WORD, True)
            self.StyleSetHotSpot(stc.STC_P_WORD2, True)

        self.Colourise(0, self.GetLength())
        self.OnSetFolderMarginStyle(event)
        for i in range(0,stc.STC_INDIC_MAX + 1): self.IndicatorSetForeground(i,'#FF0000')
        # print('Notebook Theme')



#------------------------------------------------------------------------------
class InstallersPanel(SashTankPanel):
    """Panel for InstallersTank."""
    mainMenu = Links()
    itemMenu = Links()
    espmMenu = Links()
    subsMenu = Links()

    def __init__(self,parent):
        """Initialize."""
        global gInstallers
        gInstallers = self
        data = bosh.InstallersData()
        SashTankPanel.__init__(self,data,parent)
        left,right = self.left,self.right
        splitterStyle = wx.NO_BORDER|wx.SP_LIVE_UPDATE|wx.FULL_REPAINT_ON_RESIZE
        commentsSplitter = wx.gizmos.ThinSplitterWindow(right, style=splitterStyle)
        subSplitter = wx.gizmos.ThinSplitterWindow(commentsSplitter, style=splitterStyle)
        checkListSplitter = wx.gizmos.ThinSplitterWindow(subSplitter, style=splitterStyle)
        #--Refreshing
        self.refreshed = False
        self.refreshing = False
        self.frameActivated = False
        self.fullRefresh = False
        #--Contents
        self.gList = InstallersList(left,data,
            installercons, InstallersPanel.mainMenu, InstallersPanel.itemMenu,
            details=self, style=wx.LC_REPORT)
        self.gList.SetSizeHints(100,100)
        #--Package
        self.gPackage = wx.TextCtrl(right,wx.ID_ANY,style=wx.TE_READONLY|wx.NO_BORDER)
        self.gPackage.SetBackgroundColour(self.GetBackgroundColour())
        #--Info Tabs
        self.gNotebook = wx.Notebook(subSplitter,style=wx.NB_MULTILINE)
        self.gNotebook.SetSizeHints(100,100)
        self.infoPages = []
        infoTitles = (
            ('gGeneral',_(u'General')),
            ('gMatched',_(u'Matched')),
            ('gMissing',_(u'Missing')),
            ('gMismatched',_(u'Mismatched')),
            ('gConflicts',_(u'Conflicts')),
            ('gUnderrides',_(u'Underridden')),
            ('gDirty',_(u'Dirty')),
            ('gSkipped',_(u'Skipped')),
            )
        for name,title in infoTitles:
            gPage = wx.TextCtrl(self.gNotebook,wx.ID_ANY,style=wx.TE_MULTILINE|wx.TE_READONLY|wx.HSCROLL,name=name)
            self.gNotebook.AddPage(gPage,title)
            self.infoPages.append([gPage,False])
        self.gNotebook.SetSelection(settings['bash.installers.page'])
        self.gNotebook.Bind(wx.EVT_NOTEBOOK_PAGE_CHANGED,self.OnShowInfoPage)
        #--Sub-Installers
        subPackagesPanel = wx.Panel(checkListSplitter)
        subPackagesLabel = staticText(subPackagesPanel, _(u'Sub-Packages'))
        self.gSubList = wx.CheckListBox(subPackagesPanel, style=wx.LB_EXTENDED)
        self.gSubList.Bind(wx.EVT_CHECKLISTBOX,self.OnCheckSubItem)
        self.gSubList.Bind(wx.EVT_RIGHT_UP,self.SubsSelectionMenu)
        #--Espms
        espmsPanel = wx.Panel(checkListSplitter)
        espmsLabel = staticText(espmsPanel, _(u'Esp/m Filter'))
        self.espms = []
        self.gEspmList = wx.CheckListBox(espmsPanel, style=wx.LB_EXTENDED)
        self.gEspmList.Bind(wx.EVT_CHECKLISTBOX,self.OnCheckEspmItem)
        self.gEspmList.Bind(wx.EVT_RIGHT_UP,self.SelectionMenu)
        #--Comments
        commentsPanel = wx.Panel(commentsSplitter)
        self.commentsLabel = staticText(commentsPanel, _(u'Comments / WizBAIN Editor'))
        ## self.gComments = wx.TextCtrl(commentsPanel, wx.ID_ANY, style=wx.TE_MULTILINE)
        self.gComments = WizBAINStyledTextCtrl(commentsPanel, wx.ID_ANY)
        #--Splitter settings
        checkListSplitter.SetMinimumPaneSize(50)
        checkListSplitter.SplitVertically(subPackagesPanel, espmsPanel)
        checkListSplitter.SetSashGravity(0.5)
        subSplitter.SetMinimumPaneSize(50)
        subSplitter.SplitHorizontally(self.gNotebook, checkListSplitter)
        subSplitter.SetSashGravity(0.5)
        commentsHeight = self.gPackage.GetSize()[1]
        commentsSplitter.SetMinimumPaneSize(commentsHeight)
        commentsSplitter.SplitHorizontally(subSplitter, commentsPanel)
        commentsSplitter.SetSashGravity(1.0)
        #--Layout
        subPackagesSizer = vSizer(subPackagesLabel, (self.gSubList,1,wx.EXPAND,2))
        subPackagesSizer.SetSizeHints(subPackagesPanel)
        subPackagesPanel.SetSizer(subPackagesSizer)
        espmsSizer = vSizer(espmsLabel, (self.gEspmList,1,wx.EXPAND,2))
        espmsSizer.SetSizeHints(espmsPanel)
        espmsPanel.SetSizer(espmsSizer)
        commentsSizer = vSizer(self.commentsLabel, (self.gComments,1,wx.EXPAND,2))
        commentsSizer.SetSizeHints(commentsPanel)
        commentsPanel.SetSizer(commentsSizer)
        rightSizer = vSizer(
            (self.gPackage,0,wx.GROW|wx.TOP|wx.LEFT,2),
            (commentsSplitter,1,wx.EXPAND,2))
        rightSizer.SetSizeHints(right)
        right.SetSizer(rightSizer)
        wx.LayoutAlgorithm().LayoutWindow(self, right)
        commentsSplitterSavedSashPos = settings.get('bash.installers.commentsSplitterSashPos', 0)
        # restore saved comments text box size
        if 0 == commentsSplitterSavedSashPos:
            commentsSplitter.SetSashPosition(-commentsHeight)
        else:
            commentsSplitter.SetSashPosition(commentsSplitterSavedSashPos)
        #--Events
        self.Bind(wx.EVT_SIZE,self.OnSize)
        commentsSplitter.Bind(wx.EVT_SPLITTER_SASH_POS_CHANGED, self._OnCommentsSplitterSashPosChanged)

    def RefreshUIColors(self):
        """Update any controls using custom colors."""
        self.gList.RefreshUI()

    def OnShow(self):
        """Panel is shown. Update self.data."""
        if settings.get('bash.installers.isFirstRun',True):
            settings['bash.installers.isFirstRun'] = False
            message = (_(u'Do you want to enable Installers?')
                       + u'\n\n\t' +
                       _(u'If you do, Bash will first need to initialize some data. This can take on the order of five minutes if there are many mods installed.')
                       + u'\n\n\t' +
                       _(u"If not, you can enable it at any time by right-clicking the column header menu and selecting 'Enabled'.")
                       )
            settings['bash.installers.enabled'] = balt.askYes(self,fill(message,80),self.data.title)
        if not settings['bash.installers.enabled']: return
        if self.refreshing: return
        data = self.gList.data
        if settings.get('bash.installers.updatedCRCs',True):
            settings['bash.installers.updatedCRCs'] = False
            self.refreshed = False
        if self.frameActivated and data.extractOmodsNeeded():
            self.refreshing = True
            try:
                with balt.Progress(_(u'Extracting OMODs...'),u'\n'+u' '*60) as progress:
                    dirInstallers = bosh.dirs['installers']
                    dirInstallersJoin = dirInstallers.join
                    omods = [dirInstallersJoin(x) for x in dirInstallers.list() if x.cext == u'.omod']
                    progress.setFull(max(len(omods),1))
                    for i,omod in enumerate(omods):
                        progress(i,x.stail)
                        outDir = dirInstallersJoin(omod.body)
                        num = 0
                        while outDir.exists():
                            outDir = dirInstallersJoin(u'%s%s' % (omod.sbody,num))
                            num += 1
                        try:
                            bosh.OmodFile(omod).extractToProject(outDir,SubProgress(progress,i))
                            omod.remove()
                        except:
                            deprint(_(u"Error extracting OMOD '%s':") % omod.stail,traceback=True)
                            # Ensures we don't infinitely refresh if moving the omod fails
                            data.failedOmods.add(omod.body)
                            outDir.rmtree(omod.sbody)
                            omod.moveTo(dirInstallersJoin(u'Bash',u'Failed OMODs',omod.body))
            finally:
                self.refreshing = False
        if not self.refreshed or (self.frameActivated and data.refreshInstallersNeeded()):
            self.refreshing = True
            with balt.Progress(_(u'Refreshing Installers...'),u'\n'+u' '*60, abort=True) as progress:
                try:
                    what = ('DISC','IC')[self.refreshed]
                    if data.refresh(progress,what,self.fullRefresh):
                        self.gList.RefreshUI()
                    self.fullRefresh = False
                    self.frameActivated = False
                    self.refreshing = False
                    self.refreshed = True
                except CancelError:
                    # User canceled the refresh
                    self.refreshing = False
                    self.refreshed = True
        elif self.frameActivated and data.refreshConvertersNeeded():
            self.refreshing = True
            with balt.Progress(_(u'Refreshing Converters...'),u'\n'+u' '*60) as progress:
                try:
                    if data.refresh(progress,'C',self.fullRefresh):
                        self.gList.RefreshUI()
                    self.fullRefresh = False
                    self.frameActivated = False
                    self.refreshing = False
                except CancelError:
                    # User canceled the refresh
                    self.refreshing = False
        if bosh.inisettings['AutoSizeListColumns']:
            for i in xrange(self.gList.gList.GetColumnCount()):
                self.gList.gList.SetColumnWidth(i, -bosh.inisettings['AutoSizeListColumns'])
        changed = bosh.trackedInfos.refresh()
        if changed:
            # Some tracked files changed, update the ui
            data = self.data.data_sizeCrcDate
            refresh = False
            for file in changed:
                path = file.relpath(bosh.dirs['mods'])
                if file.exists():
                    data[path] = (file.size,file.crc,file.mtime)
                    refresh = True
                else:
                    if data.get(path,None) is not None:
                        data.pop(path,None)
                        refresh = True
            if refresh:
                self.data.refreshStatus()
                self.RefreshUIMods()
        self.SetStatusCount()

    def OnShowInfoPage(self,event):
        """A specific info page has been selected."""
        if event.GetId() == self.gNotebook.GetId():
            index = event.GetSelection()
            gPage,initialized = self.infoPages[index]
            if self.detailsItem and not initialized:
                self.RefreshInfoPage(index,self.data[self.detailsItem])
            event.Skip()

    def SetStatusCount(self):
        """Sets status bar count field."""
        active = len([x for x in self.data.itervalues() if x.isActive])
        text = _(u'Packages:')+u' %d/%d' % (active,len(self.data.data))
        statusBar.SetStatusText(text,2)

    def _OnCommentsSplitterSashPosChanged(self, event):
        # ignore spurious events caused by invisible layout adjustments during initialization
        if not self.refreshed: return
        # save new comments text box size
        splitter = event.GetEventObject()
        sashPos = splitter.GetSashPosition() - splitter.GetSize()[1]
        settings['bash.installers.commentsSplitterSashPos'] = sashPos

    #--Details view (if it exists)
    def SaveDetails(self):
        """Saves details if they need saving."""
        settings['bash.installers.page'] = self.gNotebook.GetSelection()
        if not self.detailsItem: return
        if self.detailsItem not in self.data: return
        ## if not self.gComments.IsModified(): return
        if not self.gComments.GetModify(): return
        installer = self.data[self.detailsItem]
        ## installer.comments = self.gComments.GetValue()
        self.gComments.ConvertEOLs(2)#Unix. LF. Fix for Mixed EOL problem
        installer.comments = self.gComments.GetTextUTF8()
        self.data.setChanged()

    def RefreshUIMods(self):
        """Refresh UI plus refresh mods state."""
        self.gList.RefreshUI()
        if bosh.modInfos.refresh(doAutoGroup=True):
            del bosh.modInfos.mtimesReset[:]
            bosh.modInfos.autoGrouped.clear()
            modList.RefreshUI('ALL')
        if iniList is not None:
            if bosh.iniInfos.refresh():
                #iniList->INIPanel.splitter.left->INIPanel.splitter->INIPanel
                iniList.GetParent().GetParent().GetParent().RefreshUI('ALL')
            else:
                iniList.GetParent().GetParent().GetParent().RefreshUI('TARGETS')

    def RefreshDetails(self,item=None):
        """Refreshes detail view associated with data from item."""
        if item not in self.data: item = None
        self.SaveDetails() #--Save previous details
        self.detailsItem = item
        del self.espms[:]
        if item:
            installer = self.data[item]
            #--Name
            self.gPackage.SetValue(item.s)
            #--Info Pages
            currentIndex = self.gNotebook.GetSelection()
            for index,(gPage,state) in enumerate(self.infoPages):
                self.infoPages[index][1] = False
                if (index == currentIndex): self.RefreshInfoPage(index,installer)
                else: gPage.SetValue(u'')
            #--Sub-Packages
            self.gSubList.Clear()
            if len(installer.subNames) <= 2:
                self.gSubList.Clear()
            else:
                balt.setCheckListItems(self.gSubList, [x.replace(u'&',u'&&') for x in installer.subNames[1:]], installer.subActives[1:])
            #--Espms
            if not installer.espms:
                self.gEspmList.Clear()
            else:
                names = self.espms = sorted(installer.espms)
                names.sort(key=lambda x: x.cext != u'.esm')
                balt.setCheckListItems(self.gEspmList, [[u'',u'*'][installer.isEspmRenamed(x.s)]+x.s.replace(u'&',u'&&') for x in names],
                    [x not in installer.espmNots for x in names])
            #--Comments
            ## self.gComments.SetValue(installer.comments)
            try:
                self.gComments.SetText(installer.comments)
            except:
                self.gComments.SetTextUTF8(installer.comments)
            self.gComments.ConvertEOLs(2)#Unix. LF. Fix for Mixed EOL problem
            self.gComments.EmptyUndoBuffer()
        else:
            self.gPackage.SetValue(u'')
            for index,(gPage,state) in enumerate(self.infoPages):
                self.infoPages[index][1] = True
                gPage.SetValue(u'')
            self.gSubList.Clear()
            self.gEspmList.Clear()
            ## self.gComments.SetValue(u'')
            try:
                self.gComments.SetText(u'')
            except:
                self.gComments.SetTextUTF8(u'')
            self.gComments.ConvertEOLs(2)#Unix. LF. Fix for Mixed EOL problem
            self.gComments.EmptyUndoBuffer()

    def RefreshInfoPage(self,index,installer):
        """Refreshes notebook page."""
        gPage,initialized = self.infoPages[index]
        if initialized: return
        else: self.infoPages[index][1] = True
        pageName = gPage.GetName()
        sNone = _(u'[None]')
        def sortKey(file):
            dirFile = file.lower().rsplit(u'\\',1)
            if len(dirFile) == 1: dirFile.insert(0,u'')
            return dirFile
        def dumpFiles(installer,files,default=u'',header=u'',isPath=False):
            if files:
                buff = StringIO.StringIO()
                if isPath: files = [x.s for x in files]
                else: files = list(files)
                sortKeys = dict((x,sortKey(x)) for x in files)
                files.sort(key=lambda x: sortKeys[x])
                if header: buff.write(header+u'\n')
                for file in files:
                    oldName = installer.getEspmName(file)
                    buff.write(oldName)
                    if oldName != file:
                        buff.write(u' -> ')
                        buff.write(file)
                    buff.write(u'\n')
                return buff.getvalue()
            elif header:
                return header+u'\n'
            else:
                return u''
        if pageName == 'gGeneral':
            info = _(u'== Overview')+u'\n'
            info += _(u'Type: ')
            if isinstance(installer,bosh.InstallerProject):
                info += _(u'Project')
            elif isinstance(installer,bosh.InstallerMarker):
                info += _(u'Marker')
            elif isinstance(installer,bosh.InstallerArchive):
                info += _(u'Archive')
            else:
                info += _(u'Unrecognized')
            info += u'\n'
            if isinstance(installer,bosh.InstallerMarker):
                info += _(u'Structure: N/A')+u'\n'
            elif installer.type == 1:
                info += _(u'Structure: Simple')+u'\n'
            elif installer.type == 2:
                if len(installer.subNames) == 2:
                    info += _(u'Structure: Complex/Simple')+u'\n'
                else:
                    info += _(u'Structure: Complex')+u'\n'
            elif installer.type < 0:
                info += _(u'Structure: Corrupt/Incomplete')+u'\n'
            else:
                info += _(u'Structure: Unrecognized')+u'\n'
            nConfigured = len(installer.data_sizeCrc)
            nMissing = len(installer.missingFiles)
            nMismatched = len(installer.mismatchedFiles)
            if isinstance(installer,bosh.InstallerProject):
                info += _(u'Size:')+u' %s KB\n' % formatInteger(installer.size/1024)
            elif isinstance(installer,bosh.InstallerMarker):
                info += _(u'Size:')+u' N/A\n'
            elif isinstance(installer,bosh.InstallerArchive):
                if installer.isSolid:
                    if installer.blockSize:
                        sSolid = _(u'Solid, Block Size: %d MB') % installer.blockSize
                    elif installer.blockSize is None:
                        sSolid = _(u'Solid, Block Size: Unknown')
                    else:
                        sSolid = _(u'Solid, Block Size: 7z Default')
                else:
                    sSolid = _(u'Non-solid')
                info += _(u'Size: %s KB (%s)') % (formatInteger(installer.size/1024),sSolid) + u'\n'
            else:
                info += _(u'Size: Unrecognized')+u'\n'
            info += (_(u'Modified:')+u' %s\n' % formatDate(installer.modified),
                     _(u'Modified:')+u' N/A\n',)[isinstance(installer,bosh.InstallerMarker)]
            info += (_(u'Data CRC:')+u' %08X\n' % (installer.crc),
                     _(u'Data CRC:')+u' N/A\n',)[isinstance(installer,bosh.InstallerMarker)]
            info += (_(u'Files:')+u' %s\n' % formatInteger(len(installer.fileSizeCrcs)),
                     _(u'Files:')+u' N/A\n',)[isinstance(installer,bosh.InstallerMarker)]
            info += (_(u'Configured:')+u' %s (%s KB)\n' % (
                formatInteger(nConfigured), formatInteger(installer.unSize/1024)),
                     _(u'Configured:')+u' N/A\n',)[isinstance(installer,bosh.InstallerMarker)]
            info += (_(u'  Matched:')+u' %s\n' % formatInteger(nConfigured-nMissing-nMismatched),
                     _(u'  Matched:')+u' N/A\n',)[isinstance(installer,bosh.InstallerMarker)]
            info += (_(u'  Missing:')+u' %s\n' % formatInteger(nMissing),
                     _(u'  Missing:')+u' N/A\n',)[isinstance(installer,bosh.InstallerMarker)]
            info += (_(u'  Conflicts:')+u' %s\n' % formatInteger(nMismatched),
                     _(u'  Conflicts:')+u' N/A\n',)[isinstance(installer,bosh.InstallerMarker)]
            info += '\n'
            #--Infoboxes
            gPage.SetValue(info+dumpFiles(installer,installer.data_sizeCrc,sNone,
                _(u'== Configured Files'),isPath=True))
        elif pageName == 'gMatched':
            gPage.SetValue(dumpFiles(installer,set(installer.data_sizeCrc)
                - installer.missingFiles - installer.mismatchedFiles,isPath=True))
        elif pageName == 'gMissing':
            gPage.SetValue(dumpFiles(installer,installer.missingFiles,isPath=True))
        elif pageName == 'gMismatched':
            gPage.SetValue(dumpFiles(installer,installer.mismatchedFiles,sNone,isPath=True))
        elif pageName == 'gConflicts':
            gPage.SetValue(self.data.getConflictReport(installer,'OVER'))
        elif pageName == 'gUnderrides':
            gPage.SetValue(self.data.getConflictReport(installer,'UNDER'))
        elif pageName == 'gDirty':
            gPage.SetValue(dumpFiles(installer,installer.dirty_sizeCrc,isPath=True))
        elif pageName == 'gSkipped':
            gPage.SetValue(u'\n'.join((
                dumpFiles(installer,installer.skipExtFiles,sNone,_(u'== Skipped (Extension)')),
                dumpFiles(installer,installer.skipDirFiles,sNone,_(u'== Skipped (Dir)')),
                )) or sNone)

    #--Config
    def refreshCurrent(self,installer):
        """Refreshes current item while retaining scroll positions."""
        installer.refreshDataSizeCrc()
        installer.refreshStatus(self.data)

        # Save scroll bar positions, because gList.RefreshUI will
        subScrollPos  = self.gSubList.GetScrollPos(wx.VERTICAL)
        espmScrollPos = self.gEspmList.GetScrollPos(wx.VERTICAL)
        subIndices = self.gSubList.GetSelections()

        self.gList.RefreshUI(self.detailsItem)
        for subIndex in subIndices:
            self.gSubList.SetSelection(subIndex)

        # Reset the scroll bars back to their original position
        subScroll = subScrollPos - self.gSubList.GetScrollPos(wx.VERTICAL)
        self.gSubList.ScrollLines(subScroll)

        espmScroll = espmScrollPos - self.gEspmList.GetScrollPos(wx.VERTICAL)
        self.gEspmList.ScrollLines(espmScroll)

    def OnCheckSubItem(self,event):
        """Handle check/uncheck of item."""
        installer = self.data[self.detailsItem]
        index = event.GetSelection()
        self.gSubList.SetSelection(index)
        for index in range(self.gSubList.GetCount()):
            installer.subActives[index+1] = self.gSubList.IsChecked(index)
        if not wx.GetKeyState(wx.WXK_SHIFT):
            self.refreshCurrent(installer)

    def SelectionMenu(self,event):
        """Handle right click in espm list."""
        x = event.GetX()
        y = event.GetY()
        selected = self.gEspmList.HitTest((x,y))
        self.gEspmList.SetSelection(selected)
        #--Show/Destroy Menu
        InstallersPanel.espmMenu.PopupMenu(self,bashFrame,selected)

    def SubsSelectionMenu(self,event):
        """Handle right click in espm list."""
        x = event.GetX()
        y = event.GetY()
        selected = self.gSubList.HitTest((x,y))
        self.gSubList.SetSelection(selected)
        #--Show/Destroy Menu
        InstallersPanel.subsMenu.PopupMenu(self,bashFrame,selected)

    def OnCheckEspmItem(self,event):
        """Handle check/uncheck of item."""
        installer = self.data[self.detailsItem]
        espmNots = installer.espmNots
        index = event.GetSelection()
        name = self.gEspmList.GetString(index).replace('&&','&')
        if name[0] == u'*':
            name = name[1:]
        espm = GPath(name)
        if self.gEspmList.IsChecked(index):
            espmNots.discard(espm)
        else:
            espmNots.add(espm)
        self.gEspmList.SetSelection(index)    # so that (un)checking also selects (moves the highlight)
        if not wx.GetKeyState(wx.WXK_SHIFT):
            self.refreshCurrent(installer)

#------------------------------------------------------------------------------
class ScreensList(List):
    #--Class Data
    mainMenu = Links() #--Column menu
    itemMenu = Links() #--Single item menu

    def __init__(self,parent):
        #--Columns
        self.colsKey = 'bash.screens.cols'
        self.colAligns = settings['bash.screens.colAligns']
        self.colNames = settings['bash.colNames']
        self.colReverse = settings.getChanged('bash.screens.colReverse')
        self.colWidths = settings['bash.screens.colWidths']
        #--Data/Items
        self.data = bosh.screensData = bosh.ScreensData()
        self.sort = settings['bash.screens.sort']
        #--Links
        self.mainMenu = ScreensList.mainMenu
        self.itemMenu = ScreensList.itemMenu
        #--Parent init
        List.__init__(self,parent,-1,ctrlStyle=(wx.LC_REPORT|wx.SUNKEN_BORDER|wx.LC_EDIT_LABELS))
        #--Events
        wx.EVT_LIST_ITEM_SELECTED(self,self.listId,self.OnItemSelected)
        self.list.Bind(wx.EVT_CHAR, self.OnChar)
        self.list.Bind(wx.EVT_KEY_UP, self.OnKeyUp)
        self.list.Bind(wx.EVT_LIST_BEGIN_LABEL_EDIT, self.OnBeginEditLabel)
        self.list.Bind(wx.EVT_LIST_END_LABEL_EDIT, self.OnEditLabel)
        self.list.Bind(wx.EVT_LEFT_DCLICK, self.OnDoubleClick)

    def OnDoubleClick(self,event):
        """Double click a screeshot"""
        (hitItem,hitFlag) = self.list.HitTest(event.GetPosition())
        if hitItem < 0: return
        item = self.items[hitItem]
        bosh.screensData.dir.join(item).start()

    def OnBeginEditLabel(self,event):
        """Start renaming screenshots"""
        item = self.items[event.GetIndex()]
        # Change the selection to not include the extension
        editbox = self.list.GetEditControl()
        to = len(GPath(event.GetLabel()).sbody)
        editbox.SetSelection(0,to)

    def OnEditLabel(self, event):
        """Renamed a screenshot"""
        if event.IsEditCancelled(): return

        newName = event.GetLabel()

        selected = self.GetSelected()
        rePattern = re.compile(ur'^([^\\/]+?)(\d*)((\.(jpg|jpeg|png|tif|bmp))+)$',re.I|re.U)
        maPattern = rePattern.match(newName)
        if not maPattern:
            balt.showError(self,_(u'Bad extension or file root: ')+newName)
            event.Veto()
            return
        root,numStr = maPattern.groups()[:2]
        #--Rename each screenshot, keeping the old extension
        numLen = len(numStr)
        num = int(numStr or 0)
        screensDir = bosh.screensData.dir
        with balt.BusyCursor():
            newselected = []
            for file in selected:
                newName = GPath(root+numStr+file.ext)
                newselected.append(newName)
                newPath = screensDir.join(newName)
                oldPath = screensDir.join(file)
                if not newPath.exists():
                    oldPath.moveTo(newPath)
                num += 1
                numStr = unicode(num)
                numStr = u'0'*(numLen-len(numStr))+numStr
            bosh.screensData.refresh()
            self.RefreshUI()
            #--Reselected the renamed items
            for file in newselected:
                index = self.list.FindItem(0,file.s)
                if index != -1:
                    self.list.SetItemState(index,wx.LIST_STATE_SELECTED,wx.LIST_STATE_SELECTED)
            event.Veto()

    def RefreshUI(self,files='ALL',detail='SAME'):
        """Refreshes UI for specified files."""
        #--Details
        if detail == 'SAME':
            selected = set(self.GetSelected())
        else:
            selected = set([detail])
        #--Populate
        if files == 'ALL':
            self.PopulateItems(selected=selected)
        elif isinstance(files,StringTypes):
            self.PopulateItem(files,selected=selected)
        else: #--Iterable
            for file in files:
                self.PopulateItem(file,selected=selected)
        bashFrame.SetStatusCount()

    #--Populate Item
    def PopulateItem(self,itemDex,mode=0,selected=set()):
        #--String name of item?
        if not isinstance(itemDex,int):
            itemDex = self.items.index(itemDex)
        fileName = GPath(self.items[itemDex])
        fileInfo = self.data[fileName]
        cols = self.cols
        for colDex in range(self.numCols):
            col = cols[colDex]
            if col == 'File':
                value = fileName.s
            elif col == 'Modified':
                value = formatDate(fileInfo[1])
            else:
                value = u'-'
            if mode and (colDex == 0):
                self.list.InsertStringItem(itemDex, value)
            else:
                self.list.SetStringItem(itemDex, colDex, value)
        #--Image
        #--Selection State
        if fileName in selected:
            self.list.SetItemState(itemDex,wx.LIST_STATE_SELECTED,wx.LIST_STATE_SELECTED)
        else:
            self.list.SetItemState(itemDex,0,wx.LIST_STATE_SELECTED)

    #--Sort Items
    def SortItems(self,col=None,reverse=-2):
        (col, reverse) = self.GetSortSettings(col,reverse)
        settings['bash.screens.sort'] = col
        data = self.data
        #--Start with sort by name
        self.items.sort()
        if col == 'File':
            pass #--Done by default
        elif col == 'Modified':
            self.items.sort(key=lambda a: data[a][1])
        else:
            raise BashError(u'Unrecognized sort key: '+col)
        #--Ascending
        if reverse: self.items.reverse()

    #--Events ---------------------------------------------
    def OnChar(self,event):
        """Char event: Activate selected items, select all items"""
        ##F2
        if event.GetKeyCode() == wx.WXK_F2:
            selected = self.GetSelected()
            if len(selected) > 0:
                index = self.list.FindItem(0,selected[0].s)
                if index != -1:
                    self.list.EditLabel(index)
        ##Delete
        elif event.GetKeyCode() in (wx.WXK_DELETE,wx.WXK_NUMPAD_DELETE):
            with balt.BusyCursor():
                self.DeleteSelected()
            self.RefreshUI()
        ##Enter
        elif event.GetKeyCode() in (wx.WXK_RETURN,wx.WXK_NUMPAD_ENTER):
            screensDir = bosh.screensData.dir
            for file in self.GetSelected():
                file = screensDir.join(file)
                if file.exists():
                    file.start()
        event.Skip()

    def OnKeyUp(self,event):
        """Char event: Activate selected items, select all items"""
        ##Ctrl-A
        if event.CmdDown() and event.GetKeyCode() == ord('A'):
            self.SelectAll()
        event.Skip()

    #--Column Resize
    def OnColumnResize(self,event):
        super(ScreensList,self).OnColumnResize(event)
        settings.setChanged('bash.screens.colWidths')

    def OnItemSelected(self,event=None):
        fileName = self.items[event.m_itemIndex]
        filePath = bosh.screensData.dir.join(fileName)
        bitmap = wx.Bitmap(filePath.s) if filePath.exists() else None
        self.picture.SetBitmap(bitmap)

#------------------------------------------------------------------------------
class ScreensPanel(NotebookPanel):
    """Screenshots tab."""
    def __init__(self,parent):
        """Initialize."""
        wx.Panel.__init__(self, parent, -1)
        #--Left
        sashPos = settings.get('bash.screens.sashPos',120)
        left = self.left = leftSash(self,defaultSize=(sashPos,100),onSashDrag=self.OnSashDrag)
        right = self.right =  wx.Panel(self,style=wx.NO_BORDER)
        #--Contents
        global screensList
        screensList = ScreensList(left)
        screensList.SetSizeHints(100,100)
        screensList.picture = balt.Picture(right,256,192,background=colors['screens.bkgd.image'])
        self.list = screensList
        #--Events
        self.Bind(wx.EVT_SIZE,self.OnSize)
        #--Layout
        right.SetSizer(hSizer((screensList.picture,1,wx.GROW)))
        wx.LayoutAlgorithm().LayoutWindow(self, right)

    def RefreshUIColors(self):
        screensList.picture.SetBackground(colors['screens.bkgd.image'])

    def SetStatusCount(self):
        """Sets status bar count field."""
        text = _(u'Screens:')+u' %d' % (len(screensList.data.data),)
        statusBar.SetStatusText(text,2)

    def OnSashDrag(self,event):
        """Handle sash moved."""
        wMin,wMax = 80,self.GetSizeTuple()[0]-80
        sashPos = max(wMin,min(wMax,event.GetDragRect().width))
        self.left.SetDefaultSize((sashPos,10))
        wx.LayoutAlgorithm().LayoutWindow(self, self.right)
        screensList.picture.Refresh()
        settings['bash.screens.sashPos'] = sashPos

    def OnSize(self,event=None):
        wx.LayoutAlgorithm().LayoutWindow(self, self.right)

    def OnShow(self):
        """Panel is shown. Update self.data."""
        if bosh.screensData.refresh():
            screensList.RefreshUI()
            #self.Refresh()
        self.SetStatusCount()

#------------------------------------------------------------------------------
class BSAList(List):
    #--Class Data
    mainMenu = Links() #--Column menu
    itemMenu = Links() #--Single item menu

    def __init__(self,parent):
        #--Columns
        self.cols = settings['bash.BSAs.cols']
        self.colAligns = settings['bash.BSAs.colAligns']
        self.colNames = settings['bash.colNames']
        self.colReverse = settings.getChanged('bash.BSAs.colReverse')
        self.colWidths = settings['bash.BSAs.colWidths']
        #--Data/Items
        self.data = data = bosh.BSAInfos
        self.details = None #--Set by panel
        self.sort = settings['bash.BSAs.sort']
        #--Links
        self.mainMenu = BSAList.mainMenu
        self.itemMenu = BSAList.itemMenu
        #--Parent init
        List.__init__(self,parent,-1,ctrlStyle=(wx.LC_REPORT|wx.SUNKEN_BORDER))
        #--Image List
        checkboxesIL = self.checkboxes.GetImageList()
        self.list.SetImageList(checkboxesIL,wx.IMAGE_LIST_SMALL)
        #--Events
        self.list.Bind(wx.EVT_CHAR, self.OnChar)
        wx.EVT_LIST_ITEM_SELECTED(self,self.listId,self.OnItemSelected)
        #--ScrollPos
        self.list.ScrollLines(settings.get('bash.BSAs.scrollPos',0))
        self.vScrollPos = self.list.GetScrollPos(wx.VERTICAL)

    def RefreshUI(self,files='ALL',detail='SAME'):
        """Refreshes UI for specified files."""
        #--Details
        if detail == 'SAME':
            selected = set(self.GetSelected())
        else:
            selected = set([detail])
        #--Populate
        if files == 'ALL':
            self.PopulateItems(selected=selected)
        elif isinstance(files,bolt.Path):
            self.PopulateItem(files,selected=selected)
        else: #--Iterable
            for file in files:
                self.PopulateItem(file,selected=selected)
        BSADetails.SetFile(detail)
        bashFrame.SetStatusCount()

    #--Populate Item
    def PopulateItem(self,itemDex,mode=0,selected=set()):
        #--String name of item?
        if not isinstance(itemDex,int):
            itemDex = self.items.index(itemDex)
        fileName = GPath(self.items[itemDex])
        fileInfo = self.data[fileName]
        cols = self.cols
        for colDex in range(self.numCols):
            col = cols[colDex]
            if col == 'File':
                value = fileName.s
            elif col == 'Modified':
                value = formatDate(fileInfo.mtime)
            elif col == 'Size':
                value = formatInteger(fileInfo.size/1024)+u' KB'
            else:
                value = u'-'
            if mode and (colDex == 0):
                self.list.InsertStringItem(itemDex, value)
            else:
                self.list.SetStringItem(itemDex, colDex, value)
        #--Image
        #status = fileInfo.getStatus()
        on = fileName.cext == u'.bsa'
        #self.list.SetItemImage(itemDex,self.checkboxes.Get(status,on))
        #--Selection State
        if fileName in selected:
            self.list.SetItemState(itemDex,wx.LIST_STATE_SELECTED,wx.LIST_STATE_SELECTED)
        else:
            self.list.SetItemState(itemDex,0,wx.LIST_STATE_SELECTED)

    #--Sort Items
    def SortItems(self,col=None,reverse=-2):
        (col, reverse) = self.GetSortSettings(col,reverse)
        settings['bash.BSAs.sort'] = col
        data = self.data
        #--Start with sort by name
        self.items.sort()
        if col == 'File':
            pass #--Done by default
        elif col == 'Modified':
            self.items.sort(key=lambda a: data[a].mtime)
        elif col == 'Size':
            self.items.sort(key=lambda a: data[a].size)
        else:
            raise BashError(u'Unrecognized sort key: '+col)
        #--Ascending
        if reverse: self.items.reverse()

    #--Events ---------------------------------------------
    def OnChar(self,event):
        """Char event: Reordering."""
        if event.GetKeyCode() in (wx.WXK_DELETE,wx.WXK_NUMPAD_DELETE):
            self.DeleteSelected()
        event.Skip()

    #--Column Resize
    def OnColumnResize(self,event):
        super(BSAList,self).OnColumnResize(event)
        settings.setChanged('bash.BSAs.colWidths')

    #--Event: Left Down
    def OnLeftDown(self,event):
        (hitItem,hitFlag) = self.list.HitTest((event.GetX(),event.GetY()))
        if hitFlag == wx.LIST_HITTEST_ONITEMICON:
            fileName = GPath(self.items[hitItem])
            newEnabled = not self.data.isEnabled(fileName)
            newName = self.data.enable(fileName,newEnabled)
            if newName != fileName: self.RefreshUI()
        #--Pass Event onward
        event.Skip()

    def OnItemSelected(self,event=None):
        BSAName = self.items[event.m_itemIndex]
        self.details.SetFile(BSAName)

#------------------------------------------------------------------------------
class BSADetails(wx.Window):
    """BSAfile details panel."""
    def __init__(self,parent):
        """Initialize."""
        wx.Window.__init__(self, parent, -1, style=wx.TAB_TRAVERSAL)
        readOnlyColour = self.GetBackgroundColour()
        #--Singleton
        global BSADetails
        BSADetails = self
        #--Data
        self.BSAInfo = None
        self.edited = False
        textWidth = 200
        #--File Name
        id = self.fileId = wx.NewId()
        self.file = wx.TextCtrl(self,id,u'',size=(textWidth,-1))
        self.file.SetMaxLength(256)
        wx.EVT_KILL_FOCUS(self.file,self.OnEditFile)
        wx.EVT_TEXT(self.file,id,self.OnTextEdit)

        #--BSA Info
        self.gInfo = wx.TextCtrl(self,wx.ID_ANY,u'',size=(textWidth,100),style=wx.TE_MULTILINE)
        self.gInfo.SetMaxLength(2048)
        self.gInfo.Bind(wx.EVT_TEXT,self.OnInfoEdit)
        #--Save/Cancel
        self.save = button(self,id=wx.ID_SAVE,onClick=self.DoSave)
        self.cancel = button(self,id=wx.ID_CANCEL,onClick=self.DoCancel)
        self.save.Disable()
        self.cancel.Disable()
        #--Layout
        sizer = vSizer(
            (staticText(self,_(u'File:')),0,wx.TOP,4),
            (self.file,0,wx.EXPAND|wx.TOP,4),
            (hSizer(
                spacer,
                self.save,
                (self.cancel,0,wx.LEFT,4),
                ),0,wx.EXPAND|wx.TOP,4),
            (self.gInfo,0,wx.TOP,4),
            )
        self.SetSizer(sizer)

    def SetFile(self,fileName='SAME'):
        """Set file to be viewed."""
        #--Reset?
        if fileName == 'SAME':
            if not self.BSAInfo or self.BSAInfo.name not in bosh.BSAInfos:
                fileName = None
            else:
                fileName = self.BSAInfo.name
        #--Null fileName?
        if not fileName:
            BSAInfo = self.BSAInfo = None
            self.fileStr = ''
        #--Valid fileName?
        else:
            BSAInfo = self.BSAInfo = bosh.BSAInfos[fileName]
            #--Remember values for edit checks
            self.fileStr = BSAInfo.name.s
        #--Set Fields
        self.file.SetValue(self.fileStr)
        #--Edit State
        self.edited = 0
        self.save.Disable()
        self.cancel.Disable()
        #--Info Box
        self.gInfo.DiscardEdits()
        if fileName:
            self.gInfo.SetValue(bosh.BSAInfos.table.getItem(fileName,'info',_(u'Notes: ')))
        else:
            self.gInfo.SetValue(_(u'Notes: '))

    def SetEdited(self):
        """Mark as edited."""
        self.edited = True
        self.save.Enable()
        self.cancel.Enable()

    def OnInfoEdit(self,event):
        """Info field was edited."""
        if self.BSAInfo and self.gInfo.IsModified():
            bosh.BSAInfos.table.setItem(self.BSAInfo.name,'info',self.gInfo.GetValue())

    def OnTextEdit(self,event):
        """Event: Editing file or save name text."""
        if self.BSAInfo and not self.edited:
            if self.fileStr != self.file.GetValue():
                self.SetEdited()
        event.Skip()

    def OnEditFile(self,event):
        """Event: Finished editing file name."""
        if not self.BSAInfo: return
        #--Changed?
        fileStr = self.file.GetValue()
        if fileStr == self.fileStr: return
        #--Extension Changed?
        if self.fileStr[-4:].lower() != u'.bsa':
            balt.showError(self,_(u'Incorrect file extension: ')+fileStr[-3:])
            self.file.SetValue(self.fileStr)
        #--Else file exists?
        elif self.BSAInfo.dir.join(fileStr).exists():
            balt.showError(self,_(u'File %s already exists.') % fileStr)
            self.file.SetValue(self.fileStr)
        #--Okay?
        else:
            self.fileStr = fileStr
            self.SetEdited()

    def DoSave(self,event):
        """Event: Clicked Save button."""
        BSAInfo = self.BSAInfo
        #--Change Tests
        changeName = (self.fileStr != BSAInfo.name)
        #changeMasters = self.masters.edited
        #--Backup
        BSAInfo.makeBackup()
        prevMTime = BSAInfo.mtime
        #--Change Name?
        if changeName:
            (oldName,newName) = (BSAInfo.name,GPath(self.fileStr.strip()))
            BSAList.items[BSAList.items.index(oldName)] = newName
            bosh.BSAInfos.rename(oldName,newName)
        #--Done
        try:
            bosh.BSAInfos.refreshFile(BSAInfo.name)
            self.SetFile(self.BSAInfo.name)
        except bosh.FileError:
            balt.showError(self,_(u'File corrupted on save!'))
            self.SetFile(None)
        self.SetFile(self.BSAInfo.name)
        BSAList.RefreshUI(BSAInfo.name)

    def DoCancel(self,event):
        """Event: Clicked cancel button."""
        self.SetFile(self.BSAInfo.name)

#------------------------------------------------------------------------------
class BSAPanel(NotebookPanel):
    """BSA info tab."""
    def __init__(self,parent):
        wx.Panel.__init__(self, parent, wx.ID_ANY)
        global BSAList
        BSAList = BSAList(self)
        self.BSADetails = BSADetails(self)
        BSAList.details = self.BSADetails
        #--Events
        wx.EVT_SIZE(self,self.OnSize)
        #--Layout
        sizer = hSizer(
            (BSAList,1,wx.GROW),
            ((4,-1),0),
            (self.BSADetails,0,wx.EXPAND))
        self.SetSizer(sizer)
        self.BSADetails.Fit()

    def SetStatusCount(self):
        """Sets mod count in last field."""
        text = _(u'BSAs:')+u' %d' % (len(bosh.BSAInfos.data))
        statusBar.SetStatusText(text,2)

    def OnSize(self,event=None):
        wx.Window.Layout(self)
        BSAList.Layout()
        self.BSADetails.Layout()

    def OnCloseWindow(self):
        """To be called when containing frame is closing. Use for saving data, scrollpos, etc."""
        table = bosh.BSAInfos.table
        for BSAName in table.keys():
            if BSAName not in bosh.BSAInfos:
                del table[BSAName]
        table.save()
        bosh.BSAInfos.profiles.save()
        settings['bash.BSAs.scrollPos'] = BSAList.vScrollPos

#------------------------------------------------------------------------------
class MessageList(List):
    #--Class Data
    mainMenu = Links() #--Column menu
    itemMenu = Links() #--Single item menu

    def __init__(self,parent):
        #--Columns
        self.colsKey = 'bash.messages.cols'
        self.colAligns = settings['bash.messages.colAligns']
        self.colNames = settings['bash.colNames']
        self.colReverse = settings.getChanged('bash.messages.colReverse')
        self.colWidths = settings['bash.messages.colWidths']
        #--Data/Items
        self.data = bosh.messages = bosh.Messages()
        self.data.refresh()
        self.sort = settings['bash.messages.sort']
        #--Links
        self.mainMenu = MessageList.mainMenu
        self.itemMenu = MessageList.itemMenu
        #--Other
        self.gText = None
        self.searchResults = None
        #--Parent init
        List.__init__(self,parent,wx.ID_ANY,ctrlStyle=(wx.LC_REPORT|wx.SUNKEN_BORDER))
        #--Events
        wx.EVT_LIST_ITEM_SELECTED(self,self.listId,self.OnItemSelected)
        self.list.Bind(wx.EVT_KEY_UP, self.OnKeyUp)

    def GetItems(self):
        """Set and return self.items."""
        if self.searchResults != None:
            self.items = list(self.searchResults)
        else:
            self.items = self.data.keys()
        return self.items

    def RefreshUI(self,files='ALL',detail='SAME'):
        """Refreshes UI for specified files."""
        #--Details
        if detail == 'SAME':
            selected = set(self.GetSelected())
        else:
            selected = set([detail])
        #--Populate
        if files == 'ALL':
            self.PopulateItems(selected=selected)
        elif isinstance(files,StringTypes):
            self.PopulateItem(files,selected=selected)
        else: #--Iterable
            for file in files:
                self.PopulateItem(file,selected=selected)
        bashFrame.SetStatusCount()

    #--Populate Item
    def PopulateItem(self,itemDex,mode=0,selected=set()):
        #--String name of item?
        if not isinstance(itemDex,int):
            itemDex = self.items.index(itemDex)
        item = self.items[itemDex]
        subject,author,date = self.data[item][:3]
        cols = self.cols
        for colDex in range(self.numCols):
            col = cols[colDex]
            if col == 'Subject':
                value = subject
            elif col == 'Author':
                value = author
            elif col == 'Date':
                value = formatDate(date)
            else:
                value = u'-'
            if mode and (colDex == 0):
                self.list.InsertStringItem(itemDex, value)
            else:
                self.list.SetStringItem(itemDex, colDex, value)
        #--Image
        #--Selection State
        if item in selected:
            self.list.SetItemState(itemDex,wx.LIST_STATE_SELECTED,wx.LIST_STATE_SELECTED)
        else:
            self.list.SetItemState(itemDex,0,wx.LIST_STATE_SELECTED)

    #--Sort Items
    def SortItems(self,col=None,reverse=-2):
        (col, reverse) = self.GetSortSettings(col,reverse)
        settings['bash.messages.sort'] = col
        data = self.data
        #--Start with sort by date
        self.items.sort(key=lambda a: data[a][2])
        if col == 'Subject':
            reNoRe = re.compile(u'^Re: *',re.U)
            self.items.sort(key=lambda a: reNoRe.sub(u'',data[a][0]))
        elif col == 'Author':
            self.items.sort(key=lambda a: data[a][1])
        elif col == 'Date':
            pass #--Default sort
        else:
            raise BashError(u'Unrecognized sort key: '+col)
        #--Ascending
        if reverse: self.items.reverse()

    #--Events ---------------------------------------------
    def OnKeyUp(self,event):
        """Char event: Activate selected items, select all items"""
        ##Ctrl-A
        if event.CmdDown() and event.GetKeyCode() == ord('A'):
            self.SelectAll()
        event.Skip()

    #--Column Resize
    def OnColumnResize(self,event):
        super(MessageList,self).OnColumnResize(event)
        settings.setChanged('bash.messages.colWidths')

    def OnItemSelected(self,event=None):
        keys = self.GetSelected()
        path = bosh.dirs['saveBase'].join(u'Messages.html')
        bosh.messages.writeText(path,*keys)
        self.gText.Navigate(path.s,0x2) #--0x2: Clear History

#------------------------------------------------------------------------------
class MessagePanel(NotebookPanel):
    """Messages tab."""
    def __init__(self,parent):
        """Initialize."""
        import wx.lib.iewin
        wx.Panel.__init__(self, parent, -1)
        #--Left
        sashPos = settings.get('bash.messages.sashPos',120)
        gTop = self.gTop =  topSash(self,defaultSize=(100,sashPos),onSashDrag=self.OnSashDrag)
        gBottom = self.gBottom =  wx.Panel(self,style=wx.NO_BORDER)
        #--Contents
        global gMessageList
        gMessageList = MessageList(gTop)
        gMessageList.SetSizeHints(100,100)
        gMessageList.gText = wx.lib.iewin.IEHtmlWindow(gBottom, wx.ID_ANY, style = wx.NO_FULL_REPAINT_ON_RESIZE)
        self.list = gMessageList
        #--Search
        gSearchBox = self.gSearchBox = wx.TextCtrl(gBottom,wx.ID_ANY,u'',style=wx.TE_PROCESS_ENTER)
        gSearchButton = button(gBottom,_(u'Search'),onClick=self.DoSearch)
        gClearButton = button(gBottom,_(u'Clear'),onClick=self.DoClear)
        #--Events
        #--Following line should use EVT_COMMAND_TEXT_ENTER, but that seems broken.
        gSearchBox.Bind(wx.EVT_CHAR,self.OnSearchChar)
        self.Bind(wx.EVT_SIZE,self.OnSize)
        #--Layout
        gTop.SetSizer(hSizer(
            (gMessageList,1,wx.GROW)))
        gBottom.SetSizer(vSizer(
            (gMessageList.gText,1,wx.GROW),
            (hSizer(
                (gSearchBox,1,wx.GROW),
                (gSearchButton,0,wx.LEFT,4),
                (gClearButton,0,wx.LEFT,4),
                ),0,wx.GROW|wx.TOP,4),
            ))
        wx.LayoutAlgorithm().LayoutWindow(self, gTop)
        wx.LayoutAlgorithm().LayoutWindow(self, gBottom)

    def SetStatusCount(self):
        """Sets status bar count field."""
        if gMessageList.searchResults != None:
            numUsed = len(gMessageList.searchResults)
        else:
            numUsed = len(gMessageList.items)
        text = _(u'PMs:')+u' %d/%d' % (numUsed,len(gMessageList.data.keys()))
        statusBar.SetStatusText(text,2)

    def OnSashDrag(self,event):
        """Handle sash moved."""
        hMin,hMax = 80,self.GetSizeTuple()[1]-80
        sashPos = max(hMin,min(hMax,event.GetDragRect().height))
        self.gTop.SetDefaultSize((10,sashPos))
        wx.LayoutAlgorithm().LayoutWindow(self, self.gBottom)
        settings['bash.messages.sashPos'] = sashPos

    def OnSize(self,event=None):
        wx.LayoutAlgorithm().LayoutWindow(self, self.gTop)
        wx.LayoutAlgorithm().LayoutWindow(self, self.gBottom)

    def OnShow(self):
        """Panel is shown. Update self.data."""
        if bosh.messages.refresh():
            gMessageList.RefreshUI()
            #self.Refresh()
        self.SetStatusCount()

    def OnSearchChar(self,event):
        if event.GetKeyCode() in (wx.WXK_RETURN,wx.WXK_NUMPAD_ENTER):
            self.DoSearch(None)
        else:
            event.Skip()

    def DoSearch(self,event):
        """Handle search button."""
        term = self.gSearchBox.GetValue()
        gMessageList.searchResults = gMessageList.data.search(term)
        gMessageList.RefreshUI()

    def DoClear(self,event):
        """Handle clear button."""
        self.gSearchBox.SetValue(u'')
        gMessageList.searchResults = None
        gMessageList.RefreshUI()

    def OnCloseWindow(self):
        """To be called when containing frame is closing. Use for saving data, scrollpos, etc."""
        if bosh.messages: bosh.messages.save()
        settings['bash.messages.scrollPos'] = gMessageList.vScrollPos

#------------------------------------------------------------------------------
class PeopleList(balt.Tank):
    def __init__(self,*args,**kwdargs):
        self.colNames = settings['bash.colNames']
        self.colAligns = settings['bash.people.colAligns']
        self.colWidths = settings['bash.people.colWidths']
        self.colReverse = settings['bash.people.colReverse']
        self.sort = settings['bash.people.sort']
        balt.Tank.__init__(self, *args, **kwdargs)

    @property
    def cols(self): return settings['bash.people.cols']

    def SetSort(self,sort):
        self.sort = settings['bash.people.sort'] = sort

    def SetColumnReverse(self,column,reverse):
        settings['bash.people.colReverse'][column] = reverse
        settings.setChanged('bash.people.colReverse')

    def OnColumnResize(self,event):
        """Column resized."""
        super(PeopleList,self).OnColumnResize(event)
        settings.setChanged('bash.people.colWidths')

    def GetColumnDex(self,column):
        return settingDefaults['bash.people.cols'].index(column)

#------------------------------------------------------------------------------
class PeoplePanel(SashTankPanel):
    """Panel for PeopleTank."""
    mainMenu = Links()
    itemMenu = Links()

    def __init__(self,parent):
        """Initialize."""
        data = bosh.PeopleData()
        SashTankPanel.__init__(self,data,parent)
        left,right = self.left,self.right
        #--Contents
        self.gList = PeopleList(left,data,
            karmacons, PeoplePanel.mainMenu, PeoplePanel.itemMenu,
            details=self, style=wx.LC_REPORT)
        self.gList.SetSizeHints(100,100)
        self.gName = wx.TextCtrl(right,wx.ID_ANY,style=wx.TE_READONLY)
        self.gText = wx.TextCtrl(right,wx.ID_ANY,style=wx.TE_MULTILINE)
        self.gKarma = spinCtrl(right,u'0',min=-5,max=5,onSpin=self.OnSpin)
        self.gKarma.SetSizeHints(40,-1)
        #--Events
        self.Bind(wx.EVT_SIZE,self.OnSize)
        #--Layout
        right.SetSizer(vSizer(
            (hSizer(
                (self.gName,1,wx.GROW),
                (self.gKarma,0,wx.GROW),
                ),0,wx.GROW),
            (self.gText,1,wx.GROW|wx.TOP,4),
            ))
        wx.LayoutAlgorithm().LayoutWindow(self, right)

    def SetStatusCount(self):
        """Sets status bar count field."""
        text = _(u'People:')+u' %d' % len(self.data.data)
        statusBar.SetStatusText(text,2)

    def OnSpin(self,event):
        """Karma spin."""
        if not self.detailsItem: return
        karma = int(self.gKarma.GetValue())
        text = self.data[self.detailsItem][2]
        self.data[self.detailsItem] = (time.time(),karma,text)
        self.gList.UpdateItem(self.gList.GetIndex(self.detailsItem))
        self.data.setChanged()

    #--Details view (if it exists)
    def SaveDetails(self):
        """Saves details if they need saving."""
        if not self.gText.IsModified(): return
        if not self.detailsItem or self.detailsItem not in self.data: return
        mtime,karma,text = self.data[self.detailsItem]
        self.data[self.detailsItem] = (time.time(),karma,self.gText.GetValue().strip())
        self.gList.UpdateItem(self.gList.GetIndex(self.detailsItem))
        self.data.setChanged()

    def RefreshDetails(self,item=None):
        """Refreshes detail view associated with data from item."""
        item = item or self.detailsItem
        if item not in self.data: item = None
        self.SaveDetails()
        if item is None:
            self.gKarma.SetValue(0)
            self.gName.SetValue(u'')
            self.gText.Clear()
        else:
            karma,text = self.data[item][1:3]
            self.gName.SetValue(item)
            self.gKarma.SetValue(karma)
            self.gText.SetValue(text)
        self.detailsItem = item

#------------------------------------------------------------------------------
class ModBasePanel(SashTankPanel):
    """Panel for ModBaseTank."""
    mainMenu = Links()
    itemMenu = Links()

    def __init__(self,parent):
        """Initialize."""
        data = bosh.ModBaseData()
        SashTankPanel.__init__(self, data, parent)
        #--Left
        left,right = self.left, self.right
        #--Contents
        self.gList = balt.Tank(left,data,
            karmacons, ModBasePanel.mainMenu, ModBasePanel.itemMenu,
            details=self, style=wx.LC_REPORT)
        self.gList.SetSizeHints(100,100)
        #--Right header
        self.gPackage = wx.TextCtrl(right,wx.ID_ANY,style=wx.TE_READONLY)
        self.gAuthor = wx.TextCtrl(right,wx.ID_ANY)
        self.gVersion = wx.TextCtrl(right,wx.ID_ANY)
        #--Right tags, abstract, review
        self.gTags = wx.TextCtrl(right,wx.ID_ANY)
        self.gAbstract = wx.TextCtrl(right,wx.ID_ANY,style=wx.TE_MULTILINE)
        #--Fields (for zipping)
        self.index_field = {
            1: self.gAuthor,
            2: self.gVersion,
            4: self.gTags,
            5: self.gAbstract,
            }
        #--Header
        fgSizer = wx.FlexGridSizer(4,2,2,4)
        fgSizer.AddGrowableCol(1,1)
        fgSizer.AddMany([
            staticText(right,_(u'Package')),
            (self.gPackage,0,wx.GROW),
            staticText(right,_(u'Author')),
            (self.gAuthor,0,wx.GROW),
            staticText(right,_(u'Version')),
            (self.gVersion,0,wx.GROW),
            staticText(right,_(u'Tags')),
            (self.gTags,0,wx.GROW),
            ])
        #--Events
        self.Bind(wx.EVT_SIZE,self.OnSize)
        #--Layout
        right.SetSizer(vSizer(
            (fgSizer,0,wx.GROW|wx.TOP|wx.LEFT,3),
            staticText(right,_(u'Abstract')),
            (self.gAbstract,1,wx.GROW|wx.TOP,4),
            ))
        wx.LayoutAlgorithm().LayoutWindow(self, right)

    def SetStatusCount(self):
        """Sets status bar count field."""
        text = _(u'ModBase:')+u' %d' % (len(self.data.data),)
        statusBar.SetStatusText(text,2)

    #--Details view (if it exists)
    def SaveDetails(self):
        """Saves details if they need saving."""
        item = self.detailsItem
        if not item or item not in self.data: return
        if not sum(x.IsModified() for x in self.index_field.values()): return
        entry = self.data[item]
        for index,field in self.index_field.items():
            entry[index] = field.GetValue().strip()
        self.gList.UpdateItem(self.gList.GetIndex(item))
        self.data.setChanged()

    def RefreshDetails(self,item=None):
        """Refreshes detail view associated with data from item."""
        item = item or self.detailsItem
        if item not in self.data: item = None
        self.SaveDetails()
        if item is None:
            self.gPackage.Clear()
            for field in self.index_field.values():
                field.Clear()
        else:
            entry = self.data[item]
            self.gPackage.SetValue(item)
            for index,field in self.index_field.items():
                field.SetValue(entry[index])
        self.detailsItem = item

#------------------------------------------------------------------------------
class BashNotebook(wx.Notebook, balt.TabDragMixin):
    def __init__(self, parent, id):
        wx.Notebook.__init__(self, parent, id)
        balt.TabDragMixin.__init__(self)
        #--Pages
        # Ensure the 'Mods' tab is always shown
        if 'Mods' not in settings['bash.tabs.order']:
            settings['bash.tabs.order'] = ['Mods']+settings['bash.tabs.order']
        iInstallers = iMods = -1
        for page in settings['bash.tabs.order']:
            enabled = settings['bash.tabs'].get(page,False)
            if not enabled: continue
            className,title,item = tabInfo.get(page,[None,None,None])
            if title is None: continue
            panel = globals().get(className,None)
            if panel is None: continue
            # Some page specific stuff
            if page == 'Installers': iInstallers = self.GetPageCount()
            elif page == 'Mods': iMods = self.GetPageCount()
            # Add the page
            try:
                item = panel(self)
                self.AddPage(item,title)
                tabInfo[page][2] = item
            except Exception, e:
                if isinstance(e, ImportError):
                    if page == 'PM Archive':
                        deprint(title+_(u' panel disabled due to Import Error (most likely comtypes)'),traceback=True)
                        continue
                if page == 'Mods':
                    deprint(_(u"Fatal error constructing '%s' panel.") % title,traceback=True)
                    raise
                deprint(_(u"Error constructing '%s' panel.") % title,traceback=True)
                if page in settings['bash.tabs']:
                    settings['bash.tabs'][page] = False
        self.Bind(wx.EVT_NOTEBOOK_PAGE_CHANGED,self.OnShowPage)
        #--Selection
        pageIndex = max(min(settings['bash.page'],self.GetPageCount()-1),0)
        if settings['bash.installers.fastStart'] and pageIndex == iInstallers:
            pageIndex = iMods
        self.SetSelection(pageIndex)
        #--Dragging
        self.Bind(balt.EVT_NOTEBOOK_DRAGGED, self.OnTabDragged)
        #--Setup Popup menu for Right Click on a Tab
        self.Bind(wx.EVT_CONTEXT_MENU, self.DoTabMenu)

    def DoTabMenu(self,event):
        pos = event.GetPosition()
        pos = self.ScreenToClient(pos)
        tabId = self.HitTest(pos)
        if tabId != wx.NOT_FOUND and tabId[0] != wx.NOT_FOUND:
            menu = Links()
            for key in settings['bash.tabs.order']:
                canDisable = bool(key != 'Mods')
                menu.append(Settings_Tab(key,canDisable))
            menu.PopupMenu(self,bashFrame,None)
        else:
            event.Skip()

    def OnTabDragged(self, event):
        oldPos = event.fromIndex
        newPos = event.toIndex
        # Update the settings
        removeTitle = self.GetPageText(newPos)
        oldOrder = settings['bash.tabs.order']
        for removeKey in oldOrder:
            if tabInfo[removeKey][1] == removeTitle:
                break
        oldOrder.remove(removeKey)
        if newPos == 0:
            # Moved to the front
            newOrder = [removeKey]+oldOrder
        elif newPos == self.GetPageCount() - 1:
            # Moved to the end
            newOrder = oldOrder+[removeKey]
        else:
            # Moved somewhere in the middle
            beforeTitle = self.GetPageText(newPos+1)
            for beforeKey in oldOrder:
                if tabInfo[beforeKey][1] == beforeTitle:
                    break
            beforeIndex = oldOrder.index(beforeKey)
            newOrder = oldOrder[:beforeIndex]+[removeKey]+oldOrder[beforeIndex:]
        settings['bash.tabs.order'] = newOrder
        event.Skip()

    def OnShowPage(self,event):
        """Call page's OnShow command."""
        if event.GetId() == self.GetId():
            self.GetPage(event.GetSelection()).OnShow()
            event.Skip()

#------------------------------------------------------------------------------
class BashStatusBar(wx.StatusBar):
    #--Class Data
    buttons = Links()

    def __init__(self, parent):
        wx.StatusBar.__init__(self, parent, wx.ID_ANY)
        global statusBar
        statusBar = self
        self.SetFieldsCount(3)
        self.UpdateIconSizes()
        #--Bind events
        wx.EVT_SIZE(self,self.OnSize)
        #--Clear text notice
        self.Bind(wx.EVT_TIMER, self.OnTimer)
        #--Setup Drag-n-Drop reordering
        self.dragging = wx.NOT_FOUND
        self.dragStart = 0
        self.moved = False

    def _addButton(self,link):
        gButton = link.GetBitmapButton(self,style=wx.NO_BORDER)
        if gButton:
            self.buttons.append(gButton)
            # DnD events
            gButton.Bind(wx.EVT_LEFT_DOWN,self.OnDragStart)
            gButton.Bind(wx.EVT_LEFT_UP,self.OnDragEnd)
            gButton.Bind(wx.EVT_MOUSE_CAPTURE_LOST,self.OnDragEndForced)
            gButton.Bind(wx.EVT_MOTION,self.OnDrag)

    def UpdateIconSizes(self):
        self.size = settings['bash.statusbar.iconSize']
        self.size += 8
        self.buttons = []
        buttons = BashStatusBar.buttons
        order = settings['bash.statusbar.order']
        orderChanged = False
        hide = settings['bash.statusbar.hide']
        hideChanged = False
        remove = set()
        # Add buttons in order that is saved
        for uid in order:
            link = self.GetLink(uid=uid)
            # Doesn't exist?
            if link is None:
                remove.add(uid)
                continue
            # Hidden?
            if uid in hide: continue
            # Add it
            self._addButton(link)
        for uid in remove:
            order.remove(uid)
        if remove:
            orderChanged = True
        # Add any new buttons
        for link in buttons:
            # Already tested?
            uid = link.uid
            if uid in order: continue
            # Remove any hide settings, if they exist
            if uid in hide:
                hide.discard(uid)
                hideChanged = True
            order.append(uid)
            orderChanged = True
            self._addButton(link)
        # Update settings
        if orderChanged: settings.setChanged('bash.statusbar.order')
        if hideChanged: settings.setChanged('bash.statusbar.hide')
        # Refresh
        self.SetStatusWidths([self.size*len(self.buttons),-1,130])
        self.SetSize((-1, self.size))
        self.GetParent().SendSizeEvent()
        self.OnSize()

    def HideButton(self,button):
        if button in self.buttons:
            # Find the BashStatusBar_Button instance that made it
            link = self.GetLink(button=button)
            if link:
                button.Show(False)
                self.buttons.remove(button)
                settings['bash.statusbar.hide'].add(link.uid)
                settings.setChanged('bash.statusbar.hide')
                # Refresh
                self.SetStatusWidths([self.size*len(self.buttons),-1,130])
                self.GetParent().SendSizeEvent()
                self.OnSize()

    def UnhideButton(self,link):
        uid = link.uid
        settings['bash.statusbar.hide'].discard(uid)
        settings.setChanged('bash.statusbar.hide')
        # Find the position to insert it at
        order = settings['bash.statusbar.order']
        if uid not in order:
            # Not specified, put it at the end
            order.append(uid)
            settings.setChanged('bash.statusbar.order')
            self._addButton(link)
        else:
            # Specified, but now factor in hidden buttons, etc
            thisIndex = order.index(link.uid)
            self._addButton(link)
            button = self.buttons.pop()
            insertBefore = 0
            for i in range(len(self.buttons)):
                otherlink = self.GetLink(index=i)
                indexOther = order.index(otherlink.uid)
                if indexOther > thisIndex:
                    insertBefore = i
                    break
            self.buttons.insert(i,button)
        # Refresh
        self.SetStatusWidths([self.size*len(self.buttons),-1,130])
        self.GetParent().SendSizeEvent()
        self.OnSize()

    def GetLink(self,uid=None,index=None,button=None):
        """Get the Link object with a specific uid,
           or that made a specific button."""
        if uid is not None:
            for link in BashStatusBar.buttons:
                if link.uid == uid:
                    return link
        elif index is not None:
            button = self.buttons[index]
        if button is not None:
            for link in BashStatusBar.buttons:
                if link.gButton is button:
                    return link
        return None

    def HitTest(self,mouseEvent):
        id = mouseEvent.GetId()
        for i,button in enumerate(self.buttons):
            if button.GetId() == id:
                x = mouseEvent.GetPosition()[0]
                delta = x/self.size
                if abs(x) % self.size > self.size:
                    delta += x/abs(x)
                i += delta
                if i < 0: i = 0
                elif i > len(self.buttons): i = len(self.buttons)
                return i
        return wx.NOT_FOUND

    def OnDragStart(self,event):
        self.dragging = self.HitTest(event)
        if self.dragging != wx.NOT_FOUND:
            self.dragStart = event.GetPosition()[0]
            button = self.buttons[self.dragging]
            button.CaptureMouse()
        event.Skip()

    def OnDragEndForced(self,event):
        if self.dragging == wx.NOT_FOUND or not self.GetParent().IsActive():
            # The even for clicking the button sends a force capture loss
            # message.  Ignore lost capture messages if we're the active
            # window.  If we're not, that means something else forced the
            # loss of mouse capture.
            self.dragging = wx.NOT_FOUND
            self.SetCursor(wx.StockCursor(wx.CURSOR_ARROW))
        event.Skip()

    def OnDragEnd(self,event):
        if self.dragging != wx.NOT_FOUND:
            button = self.buttons[self.dragging]
            try:
                button.ReleaseMouse()
            except:
                pass
            # -*- Hacky code! -*-
            # Since we've got to CaptureMouse to do DnD properly,
            # The button will never get a EVT_BUTTON event if you
            # just click it.  Can't figure out a good way for the
            # two to play nicely, so we'll just simulate it for now
            released = self.HitTest(event)
            if released != self.dragging: released = wx.NOT_FOUND
            self.dragging = wx.NOT_FOUND
            self.SetCursor(wx.StockCursor(wx.CURSOR_ARROW))
            if self.moved:
                self.moved = False
                return
            # -*- Rest of hacky code -*-
            if released != wx.NOT_FOUND:
                evt = wx.CommandEvent(wx.wxEVT_COMMAND_BUTTON_CLICKED,
                                      button.GetId())
                wx.PostEvent(button,evt)
        event.Skip()

    def OnDrag(self,event):
        if self.dragging != wx.NOT_FOUND:
            if abs(event.GetPosition()[0] - self.dragStart) > 4:
                self.SetCursor(wx.StockCursor(wx.CURSOR_HAND))
            over = self.HitTest(event)
            if over >= len(self.buttons): over -= 1
            if over not in (wx.NOT_FOUND, self.dragging):
                self.moved = True
                # update self.buttons
                button = self.buttons[self.dragging]
                self.buttons.remove(button)
                self.buttons.insert(over,button)
                # update settings
                uid = self.GetLink(button=button).uid
                settings['bash.statusbar.order'].remove(uid)
                settings['bash.statusbar.order'].insert(over,uid)
                settings.setChanged('bash.statusbar.order')
                self.dragging = over
                # Refresh button positions
                self.OnSize()
        event.Skip()

    def OnSize(self,event=None):
        rect = self.GetFieldRect(0)
        (xPos,yPos) = (rect.x+4,rect.y+2)
        for button in self.buttons:
            button.SetPosition((xPos,yPos))
            xPos += self.size
        if event: event.Skip()

    def SetText(self,text=u'',timeout=5):
        """Set's display text as specified. Empty string clears the field."""
        self.SetStatusText(text,1)
        if timeout > 0:
            wx.Timer(self).Start(timeout*1000,wx.TIMER_ONE_SHOT)

    def OnTimer(self,evt):
        """Clears display text as specified. Empty string clears the field."""
        self.SetStatusText(u'',1)

#------------------------------------------------------------------------------
class Updater(object):
    """Class to handle checking, getting, and applying Wrye Bash updates."""
    __slots__ = ('parent','pool','result','manual','updates','status')

    # Template for batch file for installing program updates
    batchTemplate = """@ECHO OFF
PUSHD "%%~dp0"
TITLE Updating Wrye Bash

ECHO Waiting for Wrye Bash process to terminate... > update.log
:: Wait 5 seconds
PING 127.0.0.1 -n 1 > NUL

ECHO. >> update.log
ECHO Applying Wrye Bash update... >> update.log

XCOPY download\Mopy\*.* "%%CD%%" /E /R /Y >> update.log
RMDIR download /S /Q >> update.log

ECHO. >> update.log
ECHO Update complete.  Wrye Bash will now restart. >> update.log

%sSTART "Staring Wrye Bash" %s

DEL %%0"""

    def __init__(self,parent):
        self.parent = parent
        self.pool = None
        self.result = None
        self.manual = False
        self.updates = (set(),set(),set())
        self.status = None
        Updater.intervalDic = {
            '00-01-0000 00:00' : (0, 0, 1, 0, 0, 0, 0, 0, 0), # Every day
            '00-07-0000 00:00' : (0, 0, 7, 0, 0, 0, 0, 0, 0), # Every week
            '01-00-0000 00:00' : (0, 1, 0, 0, 0, 0, 0, 0, 0)  # Every month
        }

    def GetStatus(self):
        """Returns a text to be used to display the current status"""
        if self.status is None:
            # Not doing anything
            return None
        elif self.status == 1:
            # Contacting SourceForge
            return _(u'Contacting SourceForge')
        elif self.status == 2:
            # Downloading Updates
            return _(u'Downloading Updates')
        elif self.status == 3:
            return _(u'Extracting Updates')
        elif self.status == 4:
            return _(u'Creating Backup')
        elif self.status == 5:
            return _(u'Installing')
        elif self.status == 0:
            return _(u'Restart Required')
        else:
            return None

    def Start(self):
        """Initiates an update if necessary.  Otherwise, sets up a delayed
           call to initate the update at the appropriate time."""
        if self.pool: return
        self.status = None
        freq = settings['bash.update.frequency']
        if freq is False: return
        elif freq is True:
            secondsToUpdate = 0
        else:
            last = datetime.datetime.fromtimestamp( settings['bash.update.last'] ).timetuple()
            next = tuple( [item1 + item2 for item1, item2 in zip( last, Updater.intervalDic[freq] )] )
            nextUpdate = time.mktime( next )
            secondsToUpdate = nextUpdate - time.time()

        secondsToUpdate = max(0,secondsToUpdate)
        deprint(u'Updater: Next update in %s seconds.' % secondsToUpdate,trace=False)
        if secondsToUpdate == 0:
            wx.CallLater(100,self.InitiateUpdate)
        else:
            if secondsToUpdate > 2147483:   # ~1/1000 max value for a C int/long, since wx.CallLater's first arg is limited to 32 bit signed integers (apparently -- anything above crashed for me)
                secondsToUpdate = 2147483   # This leads to an incredibly minor bug: if auto-update is set to every month and the user leaves Wrye Bash open for the whole month, it'll update a few
                                            # days earlier than expected. If there's a better way to check for overflow, feel free to change accordingly.

            wx.CallLater(secondsToUpdate*1000,self.InitiateUpdate)

    def InitiateUpdate(self,manual=False):
        """Startup the update checking process, set a timer to check
           for results"""
        if self.pool: return
        self.manual = manual
        self.status = 1
        if manual:
            deprint('Updater: Manually initiating update check.',trace=False)
        else:
            deprint('Updater: Automatically initiating update check.',trace=False)
        self.pool = multiprocessing.Pool(processes=1)
        func = bweb.getAllUpdates
        args = (settings['bash.version'],)
        self.result = self.pool.apply_async(func,args)
        # Check for results in 1 second
        wx.CallLater(1000,self.CheckUpdateStatus)

    def CheckUpdateStatus(self):
        """Check to see if any results are back from the update
           process"""
        if self.result.ready():
            # Results are back
            title = _(u'Check for Updates')
            try:
                updates = self.result.get()
            except Exception as e:
                deprint(u'Updater: An error occured while checking for updates:', traceback=True,trace=False)
                if self.manual:
                    balt.showError(self.parent,
                        _(u'An error occurred while contacting SourceForge:')
                        + u'\n\n%s' % e,
                        title)
                wx.CallAfter(self.Start)
                return
            finally:
                self.pool.terminate()
                self.pool = None
                self.result = None
            settings['bash.update.last'] = time.time()
            self.FilterUpdates(updates)
            if updates:
                self.HandleUpdates(updates)
            else:
                deprint(u'Updater: No updates available.',trace=False)
                if self.manual:
                    balt.showOk(self.parent,
                        _(u'There are no updates available for Wrye Bash on SourceForge.  If you are using the SVN however, be sure to check for updates with your SVN client.'),
                        title)
                wx.CallAfter(self.Start)
                return
        else:
            # Check again in 1 seconds
            wx.CallLater(1000,self.CheckUpdateStatus)

    def FilterUpdates(self,updates):
        """Filter out updates that are already installed"""
        currentVersion = settings['bash.version']
        installedDefs = settings['bash.update.defs']
        installedLangs = settings['bash.update.lang']
        for version in updates:
            if version != currentVersion: continue
            verUpdates = updates[version]
            verUpdates['definitions'] = [x for x in verUpdates['definitions'] if GPath(x[0]) not in installedDefs]
            verUpdates['languages'] = [x for x in verUpdates['languages'] if GPath(x[0]) not in installedLangs]
            if not verUpdates['definitions'] and not verUpdates['languages'] and not verUpdates['programs']:
                del updates[version]
            break

    def HandleUpdates(self,updates):
        active = self.parent.IsActive()
        dialog = UpdateDialog(self.parent,_(u'Check for Updates'),updates)
        if not active:
            self.parent.RequestUserAttention()
        if dialog.ShowModal() == wx.ID_CANCEL:
            dialog.Destroy()
            wx.CallAfter(self.Start)
            return
        selections = dialog.GetSelections()
        installed = dialog.GetInstalled()
        deprint(u'Updater: User selected to mark the following as already installed:', installed,trace=False)
        for x in installed:
            x = GPath(x)
            if u'game definition' in x.cs:
                settings['bash.update.defs'].add(x)
                settings.setChanged('bash.update.defs')
            elif (u'translation' in x.cs or
                  u'language' in x.cs):
                settings['bash.update.lang'].add(x)
                settings.setChanged('bash.update.lang')
        dialog.Destroy()
        if not selections:
            deprint(u'Updater: User opted to not install any updates.  Update session complete.',trace=False)
            wx.CallAfter(self.Start)
            return
        else:
            deprint(u'Updater: User selected the following updates to be installed:', selections[selections.keys()[0]],trace=False)
        # Clear out old folders
        outDir = bosh.dirs['mopy'].join(u'download')
        error = False
        for file in outDir.list():
            file = outDir.join(file)
            if file.isdir():
                try: file.rmtree(file.s)
                except: error = True
        if error:
            deprint(u'Updater: An error occured while cleaning out the downloads folder, update aborted.',trace=False)
            balt.showError(self.parent,
                _(u'Wrye Bash could not clean out the Mopy\\downloads folder of loose files.  Please ensure there are no open files in the Mopy\\downloads folder, and try again.'),
                _(u'Download Updates'))
            wx.CallAfter(self.Start)
            return
        # Initiate download
        self.status = 2
        deprint(u'Updater: Initiating download.',trace=False)
        version = selections.keys()[0]
        updates = selections[version]
        self.pool = multiprocessing.Pool(processes=1)
        func = bweb.downloadUpdates
        outDir = bosh.dirs['mopy'].join(u'download')
        outDir.makedirs()
        # Setup callback functions
        args = (updates,outDir.s)
        self.result = self.pool.apply_async(func,args)
        # Check for results in 10 seconds
        wx.CallLater(10000,self.CheckDownloadStatus)

    def CheckDownloadStatus(self):
        if self.result.ready():
            # Results are back
            title = _(u'Download Updates')
            try:
                fileNames = self.result.get()
            except Exception as e:
                deprint(u'Updater: An error occured while downloading files:', traceback=True,trace=False)
                balt.showError(self.parent,
                    _(u'An error occured while downloading files from SourceForge.')
                    + u'\n\n%s' % e,
                    title)
                wx.CallAfter(self.Start)
                return
            finally:
                self.pool.terminate()
                self.pool = None
                self.result = None
            # Re-verify downlods folder is empty, in case the user extracted some files
            outDir = bosh.dirs['mopy'].join(u'download')
            error = False
            for file in outDir.list():
                file = outDir.join(file)
                if file.isdir():
                    try: file.rmtree(file.s)
                    except: error = True
            if error:
                deprint(u'Updater: An error occured while re-verifying the downloads folder empty of loose files:', traceback=True,trace=False)
                balt.showError(self.parent,
                    _(u'Wrye Bash could not clean out the Mopy\\downloads folder of loose files.  Please ensure there are no open files in the Mopy\\downloads folder, and try again.'),
                    _(u'Download Updates'))
                wx.CallAfter(self.Start)
                return
            # Determine backup type
            deprint(u'Updater: Extracting updates.',trace=False)
            self.updates = (set(),set(),set())
            extract_last = []
            extract_first = []
            for file in fileNames:
                gFile = GPath(file).relpath(outDir)
                if u'game definition' in gFile.cs:
                    extract_last.insert(0,file)
                    self.updates[0].add(gFile)   # Definition (Partial)
                elif ('language' in gFile.cs or
                     u'translation' in gFile.cs):
                    extract_last.insert(0,file)
                    self.updates[1].add(gFile)   # Language (Partial)
                else:
                    extract_first.insert(0,file)
                    self.updates[2].add(gFile)   # Program (Semi-Full)
            fileNames = extract_first + extract_last
            deprint(u'Updater: Extraction order:', fileNames,trace=False)
            # Initiate extraction
            self.status = 3
            self.pool = multiprocessing.Pool(processes=1)
            func = bweb.extractUpdates
            exe7z = bosh.dirs['compiled'].join(u'7zUnicode.exe').s
            cmd7zTemplate = '"%s" x "%s" -y -r -o"%s"'
            args = (fileNames,exe7z,cmd7zTemplate,outDir.s)
            self.result = self.pool.apply_async(func,args)
            # Check results every second
            wx.CallLater(1000,self.CheckExtractStatus)
        else:
            # Check again in 1 second
            wx.CallLater(1000,self.CheckDownloadStatus)

    def CheckExtractStatus(self):
        if self.result.ready():
            # Extraction is complete
            title = _(u'Install Updates')
            try:
                failed = self.result.get()
            except Exception as e:
                deprint(u'Updater: An error occured while extracting files:', traceback=True,trace=False)
                balt.showError(self.parent,
                    _(u'An error occured while extracting update files.')
                    + u'\n\n%s' % e,
                    title)
                wx.CallAfter(self.Start)
                return
            finally:
                self.pool.terminate()
                self.pool = None
                self.result = None
            download = bosh.dirs['mopy'].join(u'download')
            if failed:
                msg = _(u'Errors occurred while extracting update files.') + u'\n\n'
                for fileName,errors in failed:
                    msg += u' * '+fileName+u':\n'
                    msg += u'\n'.join(u'   '+x for x in errors)
                deprint(u'Updater:',msg,trace=False)
                balt.showError(self.parent,msg,title)
                deprint(u'Updater: Removing extracted update files from the downloads folder.',trace=False)
                for file in download.list():
                    file = download.join(file)
                    if file.isdir():
                        try: file.rmtree(file.s)
                        except: pass
                wx.CallAfter(self.Start)
                return
            # Delete old files
            deprint(u'Updater: Removing non-update files from the downloads folder.',trace=False)
            for file in download.list():
                file = download.join(file)
                if not file.isdir():
                    try: file.remove()
                    except: pass
            # Backup old Wrye Bash install
            self.InitiateBackup(not bool(self.updates[2]))
        else:
            # Check again in a second
            wx.CallLater(1000,self.CheckExtractStatus)

    def InitiateBackup(self,backupType):
        """Backup all of Wrye Bash's files in case there's a problem
           with the update.  Ensure 7z.exe,7z.dll,and restore_<version>bat
           are all in the Mopy\backup directory."""
        deprint(u'Updater: Initiating Backup.',trace=False)
        self.status = 4
        self.pool = multiprocessing.Pool(processes=1)
        func = bweb.createBackup
        exe7z = bosh.dirs['compiled'].join(u'7zUnicode.exe').s
        outDir = bosh.dirs['mopy'].join(u'backup')
        if not backupType:
            deprint(u'Updater: Backup type: Semi-Full',trace=False)
            # Semi-Full (Full Mopy)
            kind = u''
            #--This section needs to be updated whenever the file layout of Wrye
            #  Bash changes
            excludes = '-x!".svn" -x!"*.tmp" -x!"*.log" -x!"*.mo" -x!"*.bak" -x!"backup" -x!"download"'
            if settings['bash.standalone']:
                excludes += ' -x!"*.py*" -x!"Wrye Bash Debug.bat"'
            else:
                excludes += ' -x!"*.pyc" -x!"Wrye Bash.exe" -x!"w9xpopen.exe"'
            includes = '"*"'
        else:
            deprint(u'Updater: Backup type: Partial',trace=False)
            # Language & Game Defintions
            kind = u'_partial'
            includes = '"bash\\game\\*.py" "bash\\l10n\\*.txt"'
            dir = bosh.dirs['mopy'].join(u'bash',u'game')
            excludes = '-x!"__init__.*"'
            for file in dir.list():
                file = dir.join(file)
                if not file.isdir() and file.cext == u'':
                    excludes += ' -x!"%s"' % file.stail
        args7z = 'a -y -r'
        if settings['bash.update.backupSFX']:
            backupExt = u'.exe'
            args7z += ' -sfx'
        else:
            backupExt = u'.7z'
        backup  = u'Wrye_Bash_%s%s_backup_%s%s' % (
            settings['bash.version'],kind,
            time.strftime(u'%d-%m-%Y-%H%M',time.localtime()),
            backupExt)
        backup = outDir.join(backup).s
        cmd7zTemplate = '"%s" '+args7z+' '+excludes+' "%s" '+includes
        args = (backup,exe7z,cmd7zTemplate)
        self.result = self.pool.apply_async(func,args)
        # Check results every second
        wx.CallLater(1000,self.CheckBackupStatus)

    def CheckBackupStatus(self):
        if self.result.ready():
            # Backup complete
            title = _(u'Install Update')
            try:
                failed = self.result.get()
            except Exception as e:
                deprint(u'Updater: An error occured while backing up:', traceback=True,trace=False)
                balt.showError(self.parent,
                    _(u'An error occurred while backing up the current Wrye Bash files.')
                    + u'\n\n%s' % e,
                    title)
                wx.CallAfter(self.Start)
                return
            finally:
                self.pool.terminate()
                self.pool = None
                self.result = None
            if failed:
                balt.showError(self.parent,
                    _(u'An error occurred while backing up the current Wrye Bash files.')
                    + u'\n\n' +
                    ' * %s' % failed,
                    title)
                deprint(u'Updater: An error occurred while backing up:', traceback=True,trace=False)
                wx.CallAfter(self.Start)
                return
            # Ask if the user wants to install the updates
            msg =  _(u'Wrye Bash is ready to install the following updates:')
            msg += u'\n\n'
            for updates in reversed(self.updates):
                msg += u'\n'.join(u' * '+x.stail for x in updates)
                if updates: msg += u'\n'
            msg += u'\n'
            msg += _(u'If you choose not to install this update at this time, you can manually install the files in Mopy\\downloads.  However, Wrye Bash will not be aware of any updated Game Definition or Translation updates that were installed in this manner.')
            msg += u'\n\n'
            msg += _(u'Install these updates?')
            if balt.askYes(self.parent,msg,_(u'Install Updates')):
                self.InstallUpdates()
            else:
                deprint(u'Updater: User opted to not install the prepared update.',trace=False)
                # Don't restart the update checker, since there's a valid update
                # waiting to be installed
        else:
            wx.CallLater(1000,self.CheckBackupStatus)

    def InstallUpdates(self):
        # Move files that can be moved
        self.status = 5
        fromDir = bosh.dirs['mopy'].join(u'download')
        fromDirJoin = fromDir.join
        mopyDir = bosh.dirs['mopy']
        mopyDirJoin = mopyDir.join
        dataDirJoin = bosh.dirs['mods'].join
        # Clean out junk files before installing:
        # - .tmp
        # - .log
        # Standalone:
        # - .py
        # - .pyc
        # - .pyw
        # - files without extension (compiled .py files)
        removeExts = set((u'.tmp',u'.log',u'.pyc'))
        if settings['bash.standalone']:
            removeExts |= set((u'.py',u'.pyw',u''))
        deprint(u'Updater: Cleaning installation of the following files:', removeExts,trace=False)
        skipDirs = (mopyDirJoin(u'download'),mopyDirJoin(u'backup'))
        with balt.Progress(_(u'Updating'),_(u'Cleaning old files...')+u'\n'+' '*60) as progress:
            count = sum(len(z) for x,y,z in mopyDir.walk())
            progress.setFull(count)
            i = 0
            for file in mopyDir.list():
                fullFile = mopyDirJoin(file)
                if fullFile.isdir():
                    if file == u'download' or file ==u'backup':
                        continue
                    for root,dirs,files in fullFile.walk():
                        for file in files:
                            progress(i)
                            if file.cext in removeExts:
                                file = root.join(file)
                                progress(i,_(u'Cleaning old files...')+u'\n'+file.relpath(mopyDir).s)
                                deprint(u'Updater: Cleaning:', file.relpath(mopyDir).s,trace=False)
                                try: file.remove()
                                except: pass
                            i += 1
                elif file.cext in removeExts:
                    progress(i,_(u'Cleaning old files...')+u'\n'+file.s)
                    deprint(u'Updater: Cleaning:', file.s,trace=False)
                    i += 1
                    try: fullFile.remove()
                    except: pass
            # Now copy the new files in
            progress(i,_(u'Installing new files...'))
            deprint(u'Updater: Installing new files.',trace=False)
            failedFiles = []
            for item in fromDir.list():
                item = fromDirJoin(item)
                if not item.isdir(): continue
                if item.tail == u'Mopy': destRootJoin = mopyDirJoin
                elif item.tail == u'Data': destRootJoin = dataDirJoin
                else: continue
                for root,dirs,files in item.walk(False):
                    relRoot = root.relpath(item)
                    empty = not dirs
                    for file in files:
                        try:
                            dest = destRootJoin(relRoot,file)
                            destRel = root.join(file).relpath(fromDir)
                            progress(i,_(u'Installing new files...')+u'\n'+destRel.s)
                            i += 1
                            deprint(u'Updater: Source file:', destRel.s,trace=False)
                            deprint(u'Updater:        dest:', dest.s,trace=False)
                            root.join(file).moveTo(dest)
                        except:
                            empty = False
                            failedFiles.append(destRel)
                    if empty:
                        try: root.removedirs()
                        except: pass
            if self.updates[2]:
                # Program update, so lang and def files the only ones installed now
                settings['bash.update.defs'] = self.updates[0]
                settings['bash.update.lang'] = self.updates[1]
                deprint(u'Updater: Recorded updates as only updates installed (program update).',trace=False)
            else:
                # Non-program update, so lang and def files are in addition to those already installed
                settings['bash.update.defs'] |= self.updates[0]
                settings['bash.update.lang'] |= self.updates[1]
                settings.setChanged('bash.update.defs')
                settings.setChanged('bash.update.defs')
                deprint(u'Updater: Recorded updates added to those already installed (non-program update).',trace=False)
            # Updates are installed, restart is required
            self.status = 0
        if failedFiles:
            # Some files couldn't be copied, because they were in use
            # for example, CBash.dll, or Wrye Bash.exe
            deprint(u'Updater: Not all update files could be applied.  The following files will be installed via apply_updates.bat:', failedFiles,trace=False)
            self.WriteBatchFile('')
            apply_updates = bosh.dirs['mopy'].join(u'apply_updates.bat')
            restart_args = (set((apply_updates.s,)),)
            if not balt.askYes(self.parent,
                _(u"The following updated files were unable to be applied, because they are currently in use.  Wrye Bash needs to restart to install these files.  If you choose not to restart, they will be installed when you quit.")
                + u'\n\n' +
                u'\n'.join(u' * '+x.s for x in failedFiles)
                + u'\n\n' +
                _(u'Restart now?'),
                _(u'Install Updates')):
                deprint(u'Updater: User choose not to restart in order to apply the update.  apply_updates.bat will be run at exit.',trace=False)
                # Re-write apply_update.bat to not execute Wrye Bash after it's run
                self.WriteBatchFile()
                global appRestart
                appRestart = restart_args[0]
                return
            deprint(u'Updater: Restarting Wrye Bash to apply the update.')
        else:
            # All files were copied successfully, now we just need to restart
            # and remove the updates folder
            try: fromDir.rmtree(fromDir.stail)
            except: pass
            deprint(u'Updater: Update successful.  Restart required',trace=False)
            if not balt.askYes(self.parent,
                    _(u'Wrye Bash has successfully installed the updates.  Wrye Bash needs to restart for this update to take effect.')
                    + u'\n\n' +
                    _(u'Restart now?'),
                    _(u'Update Complete')):
                deprint(u'Updater: User opted to not restart Wrye Bash.  Update will take effect next time Wrye Bash is launched.',trace=False)
                self.WriteBatchFile()
                return
            deprint(u'Updater: Restarting Wrye Bash.',trace=False)
            restart_args = ()
        bashFrame.Restart(*restart_args)

    def WriteBatchFile(self,addArgs=None):
        apply_updates = bosh.dirs['mopy'].join(u'apply_updates.bat')
        if addArgs is None:
            with apply_updates.open('w') as out:
                out.write(Updater.batchTemplate % ('::',''))
        else:
            args = sys.argv[:]
            def updateArgs(newArgs):
                if isinstance(newArgs,(list,tuple)):
                    if len(newArgs) > 0 and isinstance(newArgs[0],(list,tuple)):
                        for arg in newArgs:
                            updateArgs(arg)
                    else:
                        found = 0
                        for i in xrange(len(args)):
                            if not found and args[i] == newArgs[0]:
                                found = 1
                            elif found:
                                if found < len(newArgs):
                                    args[i] = newArgs[found]
                                    found += 1
                                else:
                                    break
                        else:
                            args.extend(newArgs)
            updateArgs(addArgs)

            if settings['bash.standalone']:
                commandLine = '"'+args[0]+'"'
            else:
                commandLine = '"%s" "%s"' % (sys.executable,args[0])
            if len(args) > 1:
                for arg in args[1:]:
                    if arg == '--restarting': continue
                    if ' ' in arg:
                        commandLine += ' "'+arg+'"'
                    else:
                        commandLine += ' '+arg
            with apply_updates.open('w') as out:
                out.write(Updater.batchTemplate % ('',commandLine))

#------------------------------------------------------------------------------
class BashFrame(wx.Frame):
    """Main application frame."""
    def __init__(self, parent=None,pos=wx.DefaultPosition,size=(400,500),
             style = wx.DEFAULT_FRAME_STYLE):
        """Initialization."""
        #--Singleton
        global bashFrame
        bashFrame = self
        balt.Link.Frame = self
        #--Window
        wx.Frame.__init__(self, parent, wx.ID_ANY, u'Wrye Bash', pos, size, style)
        minSize = settings['bash.frameSize.min']
        self.SetSizeHints(minSize[0],minSize[1])
        self.SetTitle()
        self.Maximize(settings['bash.frameMax'])
        #--Application Icons
        self.SetIcons(bashRed)
        #--Status Bar
        self.SetStatusBar(BashStatusBar(self))
        #--Notebook panel
        self.notebook = notebook = BashNotebook(self,wx.ID_ANY)
        #--Events
        self.Bind(wx.EVT_CLOSE, self.OnCloseWindow)
        self.Bind(wx.EVT_ACTIVATE, self.RefreshData)
        #--Data
        self.updater = Updater(self)
        self.inRefreshData = False #--Prevent recursion while refreshing.
        self.knownCorrupted = set()
        self.knownInvalidVerions = set()
        self.oblivionIniCorrupted = False
        self.incompleteInstallError = False
        bosh.bsaInfos = bosh.BSAInfos()
        #--Layout
        sizer = vSizer((notebook,1,wx.GROW))
        self.SetSizer(sizer)
        if len(bosh.bsaInfos.data) + len(bosh.modInfos.data) >= 325 and not settings['bash.mods.autoGhost']:
            message = _(u"It appears that you have more than 325 mods and bsas in your data directory and auto-ghosting is disabled. This may cause problems in %s; see the readme under auto-ghost for more details and please enable auto-ghost.") % bush.game.name
            if len(bosh.bsaInfos.data) + len(bosh.modInfos.data) >= 400:
                message = _(u"It appears that you have more than 400 mods and bsas in your data directory and auto-ghosting is disabled. This will cause problems in %s; see the readme under auto-ghost for more details. ") % bush.game.name
            balt.showWarning(bashFrame,message,_(u'Too many mod files.'))

    def Restart(self,args=True):
        if not args: return

        def argConvert(arg):
            """Converts --args into -a args"""
            if not isinstance(arg,basestring): return arg
            elif arg in sys.argv: return arg
            elif arg[:2] == '--': return '-'+arg[2]
            else: return arg

        newargs = []
        if isinstance(args,(list,tuple)):
            args = [[argConvert(x) for x in arg] if isinstance(arg,(list,tuple))
                    else argConvert(arg)
                    for arg in args]
        elif isinstance(args,set):
            # Special case for restarting for an update: args passed in as set()
            pass
        else:
            args = argConvert(args)

        global appRestart
        if isinstance(appRestart,set):
            # appRestart has already been setup to run apply_updates.bat on
            # on shutdown.  Rewrite that file to also start Wrye Bash at the end
            self.updater.WriteBatchFile(args)
        else:
            appRestart = args
        self.Close(True)

    def SetTitle(self,title=None):
        """Set title. Set to default if no title supplied."""
        if not title:
            ###Remove from Bash after CBash integrated
            if bush.game.altName and settings['bash.useAltName']:
                title = bush.game.altName + u' %s%s'
            else:
                title = u'Wrye Bash %s%s '+_(u'for')+u' '+bush.game.name
            title = title % (settings['bash.version'],
                _(u'(Standalone)') if settings['bash.standalone'] else u'')
            if CBash:
                title += u', CBash v%u.%u.%u: ' % (
                    CBash.GetVersionMajor(), CBash.GetVersionMinor(),
                    CBash.GetVersionRevision())
            else:
                title += u': '
            maProfile = re.match(ur'Saves\\(.+)\\$',bosh.saveInfos.localSave,re.U)
            if maProfile:
                title += maProfile.group(1)
            else:
                title += _(u'Default')
            if bosh.modInfos.voCurrent:
                title += u' ['+bosh.modInfos.voCurrent+u']'
        wx.Frame.SetTitle(self,title)

    def SetStatusCount(self):
        """Sets the status bar count field. Actual work is done by current panel."""
        if hasattr(self,'notebook'): #--Hack to get around problem with screens tab.
            selection = self.notebook.GetSelection()
            selection = max(min(selection,self.notebook.GetPageCount()),0)
            self.notebook.GetPage(selection).SetStatusCount()

    #--Events ---------------------------------------------
    def RefreshData(self, event=None):
        """Refreshes all data. Can be called manually, but is also triggered by window activation event."""
        def listFiles(files):
            text = u'\n* '
            text += u'\n* '.join(x.s for x in files[:min(15,len(files))])
            if len(files)>10:
                text += '\n+ %d '%(len(files)-15) + _(u'others')
            return text
        #--Ignore deactivation events.
        if event and not event.GetActive() or self.inRefreshData: return
        #--UPDATES-----------------------------------------
        self.inRefreshData = True
        popMods = popSaves = popInis = None
        #--Config helpers
        bosh.configHelpers.refresh()
        #--Check plugins.txt and mods directory...
        modInfosChanged = bosh.modInfos.refresh(doAutoGroup=True)
        if modInfosChanged:
            popMods = 'ALL'
        #--Have any mtimes been reset?
        if bosh.modInfos.mtimesReset:
            if bosh.modInfos.mtimesReset[0] == 'FAILED':
                balt.showWarning(self,_(u"It appears that the current user doesn't have permissions for some or all of the files in ")
                                        + bush.game.name+u'\\Data.\n' +
                                      _(u"Specifically had permission denied to change the time on:")
                                        + u'\n' + bosh.modInfos.mtimesReset[1].s)
            if not bosh.inisettings['SkipResetTimeNotifications']:
                message = [u'',_(u'Modified dates have been reset for some mod files')]
                message.extend(sorted(bosh.modInfos.mtimesReset))
                dialog = ListBoxes(self,_(u'Modified Dates Reset'),
                         _(u'Modified dates have been reset for some mod files.'),
                         [message],liststyle='list',Cancel=False)
                dialog.ShowModal()
                dialog.Destroy()
            del bosh.modInfos.mtimesReset[:]
            popMods = 'ALL'
        #--Mods autogrouped?
        if bosh.modInfos.autoGrouped:
            message = [u'',_(u'Auto-grouped files')]
            agDict = bosh.modInfos.autoGrouped
            ordered = bosh.modInfos.getOrdered(agDict.keys())
            message.extend(ordered)
            agDict.clear()
            dialog = ListBoxes(self,_(u'Some mods have been auto-grouped:'),
                               _(u'Some mods have been auto-grouped:'),
                               [message],liststyle='list',Cancel=False)
            dialog.ShowModal()
            dialog.Destroy()
        #--Check savegames directory...
        if bosh.saveInfos.refresh():
            popSaves = 'ALL'
        #--Check INI Tweaks...
        if bosh.iniInfos.refresh():
            popInis = 'ALL'
        #--Ensure BSA timestamps are good
        if bosh.inisettings['ResetBSATimestamps']:
            if bosh.bsaInfos.refresh():
                bosh.bsaInfos.resetMTimes()
        #--Repopulate
        if popMods:
            modList.RefreshUI(popMods) #--Will repop saves too.
        elif popSaves:
            saveList.RefreshUI(popSaves)
        if popInis:
            iniList.RefreshUI(popInis)
        #--Current notebook panel
        if gInstallers: gInstallers.frameActivated = True
        self.notebook.GetPage(self.notebook.GetSelection()).OnShow()
        #--WARNINGS----------------------------------------
        #--Does plugins.txt have any bad or missing files?
        ## Not applicable now with BOSS API - perhaps find a way to simulate this warning
        #if bosh.modInfos.plugins.selectedBad:
        #    message = [u'',_(u'Missing files have been removed from load list:')]
        #    message.extend(sorted(bosh.modInfos.plugins.selectedBad))
        #    dialog = ListBoxes(self,_(u'Warning: Load List Sanitized'),
        #             _(u'Missing files have been removed from load list:'),
        #             [message],liststyle='list',Cancel=False)
        #    dialog.ShowModal()
        #    dialog.Destroy()
        #    del bosh.modInfos.plugins.selectedBad[:]
        #    bosh.modInfos.plugins.save()
        #--Was load list too long? or bad filenames?
        ## Net to recode this with the BOSS API as well
        #if bosh.modInfos.plugins.selectedExtra:## or bosh.modInfos.activeBad:
        #    message = []
        #    ## Disable this message for now, until we're done testing if
        #    ## we can get the game to load these files
        #    #if bosh.modInfos.activeBad:
        #    #    msg = [u'Incompatible names:',u'Incompatible file names deactivated:']
        #    #    msg.extend(bosh.modInfos.bad_names)
        #    #    bosh.modInfos.activeBad = set()
        #    #    message.append(msg)
        #    if bosh.modInfos.plugins.selectedExtra:
        #        msg = [u'Too many files:',_(u'Load list is overloaded.  Some files have been deactivated:')]
        #        msg.extend(sorted(bosh.modInfos.plugins.selectedExtra))
        #        message.append(msg)
        #    dialog = ListBoxes(self,_(u'Warning: Load List Sanitized'),
        #             _(u'Files have been removed from load list:'),
        #             message,liststyle='list',Cancel=False)
        #    dialog.ShowModal()
        #    dialog.Destroy()
        #    del bosh.modInfos.plugins.selectedExtra[:]
        #    bosh.modInfos.plugins.save()
        #--Any new corrupted files?
        message = []
        corruptMods = set(bosh.modInfos.corrupted.keys())
        if not corruptMods <= self.knownCorrupted:
            m = [_(u'Corrupted Mods'),_(u'The following mod files have corrupted headers: ')]
            m.extend(sorted(corruptMods))
            message.append(m)
            self.knownCorrupted |= corruptMods
        corruptSaves = set(bosh.saveInfos.corrupted.keys())
        if not corruptSaves <= self.knownCorrupted:
            m = [_(u'Corrupted Saves'),_(u'The following save files have corrupted headers: ')]
            m.extend(sorted(corruptSaves))
            message.append(m)
            self.knownCorrupted |= corruptSaves
        invalidVersions = set([x for x in bosh.modInfos.data if round(bosh.modInfos[x].header.version,6) not in bush.game.esp.validHeaderVersions])
        if not invalidVersions <= self.knownInvalidVerions:
            m = [_(u'Unrecognized Versions'),_(u'The following mods have unrecognized TES4 header versions: ')]
            m.extend(sorted(invalidVersions))
            message.append(m)
            self.knownInvalidVerions |= invalidVersions
        if bosh.modInfos.new_missing_strings:
            m = [_(u'Missing String Localization files:'),_(u'This will cause CTDs if activated.')]
            m.extend(sorted(bosh.modInfos.missing_strings))
            message.append(m)
            bosh.modInfos.new_missing_strings.clear()
        if message:
            dialog = ListBoxes(self,_(u'Warning: Corrupt/Unrecognized Files'),
                     _(u'Some files have corrupted headers or TES4 header versions:'),
                     message,liststyle='list',Cancel=False)
            dialog.ShowModal()
            dialog.Destroy()
        #--Corrupt Oblivion.ini
        if self.oblivionIniCorrupted != bosh.oblivionIni.isCorrupted:
            self.oblivionIniCorrupted = bosh.oblivionIni.isCorrupted
            if self.oblivionIniCorrupted:
                message = _(u'Your %s should begin with a section header (e.g. "[General]"), but does not. You should edit the file to correct this.') % bush.game.iniFiles[0]
                balt.showWarning(self,fill(message))
        #--Any Y2038 Resets?
        if bolt.Path.mtimeResets:
            message = [u'',_(u"Bash cannot handle dates greater than January 19, 2038. Accordingly, the dates for the following files have been reset to an earlier date: ")]
            message.extend(sorted(bolt.Path.mtimeResets))
            dialog = ListBoxes(self,_(u'Warning: Dates Reset'),
                     _(u'Modified dates have been reset to an earlier date for  these files'),
                     [message],liststyle='list',Cancel=False)
            dialog.ShowModal()
            dialog.Destroy()
            del bolt.Path.mtimeResets[:]
        #--OBMM Warning?
        if settings['bosh.modInfos.obmmWarn'] == 1:
            settings['bosh.modInfos.obmmWarn'] = 2
            message = (_(u'Turn Lock Load Order Off?')
                       + u'\n\n' +
                       _(u'Lock Load Order is a feature which resets load order to a previously memorized state.  While this feature is good for maintaining your load order, it will also undo any load order changes that you have made in OBMM.')
                       )
            lockTimes = not balt.askYes(self,message,_(u'Lock Load Order'))
            bosh.modInfos.lockTimes = settings['bosh.modInfos.resetMTimes'] = lockTimes
            if lockTimes:
                bosh.modInfos.resetMTimes()
            else:
                bosh.modInfos.mtimes.clear()
            message = _(u"Lock Load Order is now %s.  To change it in the future, right click on the main list header on the Mods tab and select 'Lock Load Order'.")
            balt.showOk(self,message % ((_(u'off'),_(u'on'))[lockTimes],),_(u'Lock Load Order'))
        #--Missing docs directory?
        testFile = GPath(bosh.dirs['app']).join(u'Data',u'Docs',u'wtxt_teal.css')
        if not self.incompleteInstallError and not testFile.exists():
            self.incompleteInstallError = True
            message = (_(u'Installation appears incomplete.  Please re-unzip bash to game directory so that ALL files are installed.')
                       + u'\n\n' +
                       _(u'Correct installation will create %s\\Mopy and %s\\Data\\Docs directories.')
                       % (bush.game.name,bush.game.name)
                       )
            balt.showWarning(self,message,_(u'Incomplete Installation'))
        #--Merge info
        oldMergeable = set(bosh.modInfos.mergeable)
        scanList = bosh.modInfos.refreshMergeable()
        difMergeable = oldMergeable ^ bosh.modInfos.mergeable
        if scanList:
            with balt.Progress(_(u'Mark Mergeable')+u' '*30) as progress:
                progress.setFull(len(scanList))
                bosh.modInfos.rescanMergeable(scanList,progress)
        if scanList or difMergeable:
            modList.RefreshUI(scanList + list(difMergeable))
        #--Done (end recursion blocker)
        self.inRefreshData = False

    def OnCloseWindow(self, event):
        """Handle Close event. Save application data."""
        try:
            self.SaveSettings()
        except:
            deprint(u'An error occurred while trying to save settings:', traceback=True)
            pass
        if self.updater.pool:
            self.updater.pool.terminate()
        self.Destroy()

    def SaveSettings(self):
        """Save application data."""
        self.CleanSettings()
        if docBrowser: docBrowser.DoSave()
        if not (self.IsIconized() or self.IsMaximized()):
            settings['bash.framePos'] = self.GetPositionTuple()
            settings['bash.frameSize'] = self.GetSizeTuple()
        settings['bash.frameMax'] = self.IsMaximized()
        settings['bash.page'] = self.notebook.GetSelection()
        for index in range(self.notebook.GetPageCount()):
            self.notebook.GetPage(index).OnCloseWindow()
        settings.save()

    def CleanSettings(self):
        """Cleans junk from settings before closing."""
        #--Clean rename dictionary.
        modNames = set(bosh.modInfos.data.keys())
        modNames.update(bosh.modInfos.table.data.keys())
        renames = bosh.settings.getChanged('bash.mods.renames')
        for key,value in renames.items():
            if value not in modNames:
                del renames[key]
        #--Clean colors dictionary
        currentColors = set(settings['bash.colors'].keys())
        defaultColors = set(settingDefaults['bash.colors'].keys())
        invalidColors = currentColors - defaultColors
        missingColors = defaultColors - currentColors
        if invalidColors:
            for key in invalidColors:
                del settings['bash.colors'][key]
        if missingColors:
            for key in missingColors:
                settings['bash.colors'][key] = settingDefaults['bash.colors'][key]
        if invalidColors or missingColors:
            settings.setChanged('bash.colors')
        #--Clean backup
        for fileInfos in (bosh.modInfos,bosh.saveInfos):
            goodRoots = set(path.root for path in fileInfos.data.keys())
            backupDir = fileInfos.bashDir.join(u'Backups')
            if not backupDir.isdir(): continue
            for name in backupDir.list():
                path = backupDir.join(name)
                if name.root not in goodRoots and path.isfile():
                    path.remove()

#------------------------------------------------------------------------------
class ListBoxes(wx.Dialog):
    """A window with 1 or more lists."""
    def __init__(self,parent,title,message,lists,liststyle='check',style=wx.DEFAULT_DIALOG_STYLE,changedlabels={},Cancel=True):
        """lists is in this format:
        if liststyle == 'check' or 'list'
        [title,tooltip,item1,item2,itemn],
        [title,tooltip,....],
        elif liststyle == 'tree'
        [title,tooltip,{item1:[subitem1,subitemn],item2:[subitem1,subitemn],itemn:[subitem1,subitemn]}],
        [title,tooltip,....],
        """
        wx.Dialog.__init__(self,parent,wx.ID_ANY,title,style=style)
        self.SetIcons(bashBlue)
        minWidth = self.GetTextExtent(title)[0]*1.2+64
        sizer = wx.FlexGridSizer(len(lists)+1,1)
        self.ids = {}
        labels = {wx.ID_CANCEL:_(u'Cancel'),wx.ID_OK:_(u'OK')}
        labels.update(changedlabels)
        self.SetSize(wx.Size(self.GetTextExtent(title)[0]*1.2+64,-1))
        for i,group in enumerate(lists):
            title = group[0]
            tip = group[1]
            try: items = [x.s for x in group[2:]]
            except: items = [x for x in group[2:]]
            if len(items) == 0: continue
            box = wx.StaticBox(self,wx.ID_ANY,title)
            subsizer = wx.StaticBoxSizer(box, wx.HORIZONTAL)
            if liststyle == 'check':
                checks = wx.CheckListBox(self,wx.ID_ANY,choices=items,style=wx.LB_SINGLE|wx.LB_HSCROLL)
                for i in xrange(len(items)):
                    checks.Check(i,True)
            elif liststyle == 'list':
                checks = wx.ListBox(self,wx.ID_ANY,choices=items,style=wx.LB_SINGLE|wx.LB_HSCROLL)
            else:
                checks = wx.TreeCtrl(self,wx.ID_ANY,size=(150,200),style=wx.TR_DEFAULT_STYLE|wx.TR_FULL_ROW_HIGHLIGHT|wx.TR_HIDE_ROOT)
                root = checks.AddRoot(title)
                for item in group[2]:
                    child = checks.AppendItem(root,item.s)
                    for subitem in group[2][item]:
                        sub = checks.AppendItem(child,subitem.s)
            self.ids[title] = checks.GetId()
            checks.Bind(wx.EVT_KEY_UP, self.OnKeyUp)
            checks.SetToolTip(balt.tooltip(tip))
            subsizer.Add(checks,1,wx.EXPAND|wx.ALL,2)
            sizer.Add(subsizer,1,wx.EXPAND|wx.ALL,5)
            sizer.AddGrowableRow(i)
        okButton = button(self,id=wx.ID_OK,label=labels[wx.ID_OK])
        okButton.SetDefault()
        if Cancel:
            sizer.Add(hSizer(
                (balt.spacer),
                (okButton,0,wx.ALIGN_RIGHT|wx.RIGHT,2),
                (button(self,id=wx.ID_CANCEL,label=labels[wx.ID_CANCEL]),0,wx.ALIGN_RIGHT),
                ),1,wx.EXPAND|wx.BOTTOM|wx.LEFT|wx.RIGHT,5)
        else:
            sizer.Add(hSizer(
                (balt.spacer),
                (okButton,0,wx.ALIGN_RIGHT|wx.RIGHT,2),
                ),1,wx.EXPAND|wx.BOTTOM|wx.LEFT|wx.RIGHT,5)
        sizer.AddGrowableCol(0)
        sizer.SetSizeHints(self)
        self.SetSizer(sizer)
        #make sure that minimum size is at least the size of title
        if self.GetSize()[0] < minWidth:
            self.SetSize(wx.Size(minWidth,-1))


    def OnKeyUp(self,event):
        """Char events"""
        ##Ctrl-A - check all
        obj = event.GetEventObject()
        if not isinstance(obj,wx.CheckListBox): event.Skip()
        if event.CmdDown() and event.GetKeyCode() == ord('A'):
            for i in xrange(len(obj.GetStrings())):
                    obj.Check(i)
        ##Ctrl-D - decheck all
        elif event.CmdDown() and event.GetKeyCode() == ord('D'):
            obj.SetSelection(wx.NOT_FOUND)
            for i in xrange(len(obj.GetStrings())):
                obj.Check(i,False)
        event.Skip()

#------------------------------------------------------------------------------
class ColorDialog(wx.Dialog):
    """Color configuration dialog"""
    def __init__(self,parent):
        wx.Dialog.__init__(self,parent,wx.ID_ANY,_(u'Color Configuration'))
        self.changes = dict()
        #--ComboBox
        keys = [x for x in colors]
        keys.sort()
        choices = [colorInfo[x][0] for x in keys]
        choice = choices[0]
        self.text_key = dict()
        for key in keys:
            text = colorInfo[key][0]
            self.text_key[text] = key
        choiceKey = self.text_key[choice]
        self.comboBox = balt.comboBox(self,wx.ID_ANY,choice,choices=choices,style=wx.CB_READONLY)
        #--Color Picker
        self.picker = wx.ColourPickerCtrl(self,wx.ID_ANY)
        self.picker.SetColour(colors[choiceKey])
        #--Description
        help = colorInfo[choiceKey][1]
        self.textCtrl = wx.TextCtrl(self,wx.ID_ANY,help,style=wx.TE_MULTILINE|wx.TE_READONLY)
        #--Buttons
        self.default = button(self,_(u'Default'),onClick=self.OnDefault)
        self.defaultAll = button(self,_(u'All Defaults'),onClick=self.OnDefaultAll)
        self.apply = button(self,id=wx.ID_APPLY,onClick=self.OnApply)
        self.applyAll = button(self,_(u'Apply All'),onClick=self.OnApplyAll)
        self.exportConfig = button(self,_(u'Export...'),onClick=self.OnExport)
        self.importConfig = button(self,_(u'Import...'),onClick=self.OnImport)
        self.ok = button(self,id=wx.ID_OK)
        self.ok.SetDefault()
        #--Events
        self.comboBox.Bind(wx.EVT_COMBOBOX,self.OnComboBox)
        self.picker.Bind(wx.EVT_COLOURPICKER_CHANGED,self.OnColorPicker)
        #--Layout
        sizer = vSizer(
            (hSizer(
                (self.comboBox,1,wx.EXPAND|wx.RIGHT,5),
                (self.picker),
                ),0,wx.EXPAND|wx.ALL,5),
            (self.textCtrl,1,wx.EXPAND|wx.ALL,5),
            (hSizer(
                (self.defaultAll,0,wx.RIGHT,5),
                (self.applyAll,0,wx.RIGHT,5),
                (self.exportConfig),
                ),0,wx.EXPAND|wx.ALL,5),
            (hSizer(
                (self.default,0,wx.RIGHT,5),
                (self.apply,0,wx.RIGHT,5),
                (self.importConfig),
                (spacer),
                (self.ok),
                ),0,wx.EXPAND|wx.ALL,5),
            )
        self.comboBox.SetFocus()
        self.SetSizer(sizer)
        self.SetIcons(bashBlue)
        self.UpdateUIButtons()

    def GetChoice(self):
        return self.text_key[self.comboBox.GetValue()]

    def UpdateUIColors(self):
        """Update the bashFrame with the new colors"""
        nb = bashFrame.notebook
        with balt.BusyCursor():
            for (className,title,panel) in tabInfo.itervalues():
                if panel is not None:
                    panel.RefreshUIColors()

    def UpdateUIButtons(self):
        # Apply All and Default All
        for key in self.changes.keys():
            if self.changes[key] == colors[key]:
                del self.changes[key]
        anyChanged = bool(self.changes)
        allDefault = True
        for key in colors:
            if key in self.changes:
                color = self.changes[key]
            else:
                color = colors[key]
            default = bool(color == settingDefaults['bash.colors'][key])
            if not default:
                allDefault = False
                break
        # Apply and Default
        choice = self.GetChoice()
        changed = bool(choice in self.changes)
        if changed:
            color = self.changes[choice]
        else:
            color = colors[choice]
        default = bool(color == settingDefaults['bash.colors'][choice])
        # Update the Buttons, ComboBox, and ColorPicker
        self.apply.Enable(changed)
        self.applyAll.Enable(anyChanged)
        self.default.Enable(not default)
        self.defaultAll.Enable(not allDefault)
        self.picker.SetColour(color)
        self.comboBox.SetFocusFromKbd()

    def OnDefault(self,event):
        event.Skip()
        choice = self.GetChoice()
        newColor = settingDefaults['bash.colors'][choice]
        self.changes[choice] = newColor
        self.UpdateUIButtons()

    def OnDefaultAll(self,event):
        event.Skip()
        for key in colors:
            default = settingDefaults['bash.colors'][key]
            if colors[key] != default:
                self.changes[key] = default
        self.UpdateUIButtons()

    def OnApply(self,event):
        event.Skip()
        choice = self.GetChoice()
        newColor = self.changes[choice]
        #--Update settings and colors
        settings['bash.colors'][choice] = newColor
        settings.setChanged('bash.colors')
        colors[choice] = newColor
        self.UpdateUIButtons()
        self.UpdateUIColors()

    def OnApplyAll(self,event):
        event.Skip()
        for key,newColor in self.changes.iteritems():
            settings['bash.colors'][key] = newColor
            colors[key] = newColor
        settings.setChanged('bash.colors')
        self.UpdateUIButtons()
        self.UpdateUIColors()

    def OnExport(self,event):
        event.Skip()
        outDir = bosh.dirs['patches']
        outDir.makedirs()
        #--File dialog
        outPath = balt.askSave(self,_(u'Export color configuration to:'), outDir, _(u'Colors.txt'), u'*.txt')
        if not outPath: return
        try:
            with outPath.open('w') as file:
                for key in colors:
                    if key in self.changes:
                        color = self.changes[key]
                    else:
                        color = colors[key]
                    file.write(key+u': '+color+u'\n')
        except Exception,e:
            balt.showError(self,_(u'An error occurred writing to ')+outPath.stail+u':\n\n%s'%e)

    def OnImport(self,event):
        event.Skip()
        inDir = bosh.dirs['patches']
        inDir.makedirs()
        #--File dialog
        inPath = balt.askOpen(self,_(u'Import color configuration from:'), inDir, _(u'Colors.txt'), u'*.txt', mustExist=True)
        if not inPath: return
        try:
            with inPath.open('r') as file:
                for line in file:
                    # Format validation
                    if u':' not in line:
                        continue
                    split = line.split(u':')
                    if len(split) != 2:
                        continue
                    key = split[0]
                    # Verify color exists
                    if key not in colors:
                        continue
                    # Color format verification
                    color = eval(split[1])
                    if not isinstance(color, tuple) or len(color) not in (3,4):
                        continue
                    ok = True
                    for value in color:
                        if not isinstance(value,int):
                            ok = False
                            break
                        if value < 0x00 or value > 0xFF:
                            ok = False
                            break
                    if not ok:
                        continue
                    # Save it
                    if color == colors[key]: continue
                    self.changes[key] = color
        except Exception, e:
            balt.showError(bashFrame,_(u'An error occurred reading from ')+inPath.stail+u':\n\n%s'%e)
        self.UpdateUIButtons()

    def OnComboBox(self,event):
        event.Skip()
        self.UpdateUIButtons()
        choice = self.GetChoice()
        help = colorInfo[choice][1]
        self.textCtrl.SetValue(help)

    def OnColorPicker(self,event):
        event.Skip()
        choice = self.GetChoice()
        newColor = self.picker.GetColour()
        self.changes[choice] = newColor
        self.UpdateUIButtons()

#------------------------------------------------------------------------------
class DocBrowser(wx.Frame):
    """Doc Browser frame."""
    def __init__(self,modName=None):
        """Intialize.
        modName -- current modname (or None)."""
        import wx.lib.iewin
        #--Data
        self.modName = GPath(modName or u'')
        self.data = bosh.modInfos.table.getColumn('doc')
        self.docEdit = bosh.modInfos.table.getColumn('docEdit')
        self.docType = None
        self.docIsWtxt = False
        #--Clean data
        for key,doc in self.data.items():
            if not isinstance(doc,bolt.Path):
                self.data[key] = GPath(doc)
        #--Singleton
        global docBrowser
        docBrowser = self
        #--Window
        pos = settings['bash.modDocs.pos']
        size = settings['bash.modDocs.size']
        wx.Frame.__init__(self, bashFrame, wx.ID_ANY, _(u'Doc Browser'), pos, size,
            style=wx.DEFAULT_FRAME_STYLE)
        self.SetBackgroundColour(wx.NullColour)
        self.SetSizeHints(250,250)
        #--Mod Name
        self.modNameBox = wx.TextCtrl(self,wx.ID_ANY,style=wx.TE_READONLY)
        self.modNameList = wx.ListBox(self,wx.ID_ANY,choices=sorted(x.s for x in self.data.keys()),style=wx.LB_SINGLE|wx.LB_SORT)
        self.modNameList.Bind(wx.EVT_LISTBOX,self.DoSelectMod)
        #wx.EVT_COMBOBOX(self.modNameBox,ID_SELECT,self.DoSelectMod)
        #--Application Icons
        self.SetIcons(bashDocBrowser)
        #--Set Doc
        self.setButton = button(self,_(u'Set Doc...'),onClick=self.DoSet)
        #--Forget Doc
        self.forgetButton = button(self,_(u'Forget Doc...'),onClick=self.DoForget)
        #--Rename Doc
        self.renameButton = button(self,_(u'Rename Doc...'),onClick=self.DoRename)
        #--Edit Doc
        self.editButton = wx.ToggleButton(self,ID_EDIT,_(u'Edit Doc...'))
        wx.EVT_TOGGLEBUTTON(self.editButton,ID_EDIT,self.DoEdit)
        self.openButton = button(self,_(u'Open Doc...'),onClick=self.DoOpen,tip=_(u'Open doc in external editor.'))
        #--Html Back
        bitmap = wx.ArtProvider_GetBitmap(wx.ART_GO_BACK,wx.ART_HELP_BROWSER, (16,16))
        self.prevButton = bitmapButton(self,bitmap,onClick=self.DoPrevPage)
        #--Html Forward
        bitmap = wx.ArtProvider_GetBitmap(wx.ART_GO_FORWARD,wx.ART_HELP_BROWSER, (16,16))
        self.nextButton = bitmapButton(self,bitmap,onClick=self.DoNextPage)
        #--Doc Name
        self.docNameBox = wx.TextCtrl(self,wx.ID_ANY,style=wx.TE_READONLY)
        #--Doc display
        self.plainText = wx.TextCtrl(self,wx.ID_ANY,style=wx.TE_READONLY|wx.TE_MULTILINE|wx.TE_RICH2|wx.SUNKEN_BORDER)
        self.htmlText = wx.lib.iewin.IEHtmlWindow(self, wx.ID_ANY, style = wx.NO_FULL_REPAINT_ON_RESIZE)
        #--Events
        wx.EVT_CLOSE(self, self.OnCloseWindow)
        #--Layout
        self.mainSizer = vSizer(
            (hSizer( #--Buttons
                (self.setButton,0,wx.GROW),
                (self.forgetButton,0,wx.GROW),
                (self.renameButton,0,wx.GROW),
                (self.editButton,0,wx.GROW),
                (self.openButton,0,wx.GROW),
                (self.prevButton,0,wx.GROW),
                (self.nextButton,0,wx.GROW),
                ),0,wx.GROW|wx.ALL^wx.BOTTOM,4),
            (hSizer( #--Mod name, doc name
                #(self.modNameBox,2,wx.GROW|wx.RIGHT,4),
                (self.docNameBox,2,wx.GROW),
                ),0,wx.GROW|wx.TOP|wx.BOTTOM,4),
            (self.plainText,3,wx.GROW),
            (self.htmlText,3,wx.GROW),
            )
        sizer = hSizer(
            (vSizer(
                (self.modNameBox,0,wx.GROW),
                (self.modNameList,1,wx.GROW|wx.TOP,4),
                ),0,wx.GROW|wx.TOP|wx.RIGHT,4),
            (self.mainSizer,1,wx.GROW),
            )
        #--Set
        self.SetSizer(sizer)
        self.SetMod(modName)
        self.SetDocType('txt')

    def GetIsWtxt(self,docPath=None):
        """Determines whether specified path is a wtxt file."""
        docPath = docPath or GPath(self.data.get(self.modName,u''))
        if not docPath.exists(): return False
        with docPath.open('r',encoding='utf-8-sig') as textFile:
            maText = re.match(ur'^=.+=#\s*$',textFile.readline(),re.U)
        return (maText != None)

    def DoHome(self, event):
        """Handle "Home" button click."""
        self.htmlText.GoHome()

    def DoPrevPage(self, event):
        """Handle "Back" button click."""
        self.htmlText.GoBack()

    def DoNextPage(self, event):
        """Handle "Next" button click."""
        self.htmlText.GoForward()

    def DoOpen(self,event):
        """Handle "Open Doc" button."""
        docPath = self.data.get(self.modName)
        if not docPath: return bell()
        docPath.start()

    def DoEdit(self,event):
        """Handle "Edit Doc" button click."""
        self.DoSave()
        editing = self.editButton.GetValue()
        self.docEdit[self.modName] = editing
        self.docIsWtxt = self.GetIsWtxt()
        if self.docIsWtxt:
            self.SetMod(self.modName)
        else:
            self.plainText.SetEditable(editing)

    def DoForget(self,event):
        """Handle "Forget Doc" button click.
        Sets help document for current mod name to None."""
        #--Already have mod data?
        modName = self.modName
        if modName not in self.data:
            return
        index = self.modNameList.FindString(modName.s)
        if index != wx.NOT_FOUND:
            self.modNameList.Delete(index)
        del self.data[modName]
        self.SetMod(modName)

    def DoSelectMod(self,event):
        """Handle mod name combobox selection."""
        self.SetMod(event.GetString())

    def DoSet(self,event):
        """Handle "Set Doc" button click."""
        #--Already have mod data?
        modName = self.modName
        if modName in self.data:
            (docsDir,fileName) = self.data[modName].headTail
        else:
            docsDir = settings['bash.modDocs.dir'] or bosh.dirs['mods']
            fileName = GPath(u'')
        #--Dialog
        path = balt.askOpen(self,_(u'Select doc for %s:') % modName.s,
            docsDir,fileName, u'*.*',mustExist=True)
        if not path: return
        settings['bash.modDocs.dir'] = path.head
        if modName not in self.data:
            self.modNameList.Append(modName.s)
        self.data[modName] = path
        self.SetMod(modName)

    def DoRename(self,event):
        """Handle "Rename Doc" button click."""
        modName = self.modName
        oldPath = self.data[modName]
        (workDir,fileName) = oldPath.headTail
        #--Dialog
        path = balt.askSave(self,_(u'Rename file to:'),workDir,fileName, u'*.*')
        if not path or path == oldPath: return
        #--OS renaming
        path.remove()
        oldPath.moveTo(path)
        if self.docIsWtxt:
            oldHtml, newHtml = (x.root+u'.html' for x in (oldPath,path))
            if oldHtml.exists(): oldHtml.moveTo(newHtml)
            else: newHtml.remove()
        #--Remember change
        self.data[modName] = path
        self.SetMod(modName)

    def DoSave(self):
        """Saves doc, if necessary."""
        if not self.plainText.IsModified(): return
        docPath = self.data.get(self.modName)
        self.plainText.DiscardEdits()
        if not docPath:
            raise BoltError(_(u'Filename not defined.'))
        with docPath.open('w',encoding='utf-8-sig') as out:
            out.write(self.plainText.GetValue())
        if self.docIsWtxt:
            docsDir = bosh.modInfos.dir.join(u'Docs')
            bolt.WryeText.genHtml(docPath, None, docsDir)

    def SetMod(self,modName=None):
        """Sets the mod to show docs for."""
        #--Save Current Edits
        self.DoSave()
        #--New modName
        self.modName = modName = GPath(modName or u'')
        #--ModName
        if modName:
            self.modNameBox.SetValue(modName.s)
            index = self.modNameList.FindString(modName.s)
            self.modNameList.SetSelection(index)
            self.setButton.Enable(True)
        else:
            self.modNameBox.SetValue(u'')
            self.modNameList.SetSelection(wx.NOT_FOUND)
            self.setButton.Enable(False)
        #--Doc Data
        docPath = self.data.get(modName) or GPath(u'')
        docExt = docPath.cext
        self.docNameBox.SetValue(docPath.stail)
        self.forgetButton.Enable(docPath != u'')
        self.renameButton.Enable(docPath != u'')
        #--Edit defaults to false.
        self.editButton.SetValue(False)
        self.editButton.Enable(False)
        self.openButton.Enable(False)
        self.plainText.SetEditable(False)
        self.docIsWtxt = False
        #--View/edit doc.
        if not docPath:
            self.plainText.SetValue(u'')
            self.SetDocType('txt')
        elif not docPath.exists():
            myTemplate = bosh.modInfos.dir.join(u'Docs',u'My Readme Template.txt')
            bashTemplate = bosh.modInfos.dir.join(u'Docs',u'Bash Readme Template.txt')
            if myTemplate.exists():
                template = u''.join(myTemplate.open().readlines())
            elif bashTemplate.exists():
                template = u''.join(bashTemplate.open().readlines())
            else:
                template = u'= $modName '+(u'='*(74-len(modName)))+u'#\n'+docPath
            defaultText = string.Template(template).substitute(modName=modName.s)
            self.plainText.SetValue(defaultText)
            self.SetDocType('txt')
            if docExt in (u'.txt',u'.etxt'):
                self.editButton.Enable(True)
                self.openButton.Enable(True)
                editing = self.docEdit.get(modName,True)
                self.editButton.SetValue(editing)
                self.plainText.SetEditable(editing)
            self.docIsWtxt = (docExt == u'.txt')
        elif docExt in (u'.htm',u'.html',u'.mht'):
            self.htmlText.Navigate(docPath.s,0x2) #--0x2: Clear History
            self.SetDocType('html')
        else:
            self.editButton.Enable(True)
            self.openButton.Enable(True)
            editing = self.docEdit.get(modName,False)
            self.editButton.SetValue(editing)
            self.plainText.SetEditable(editing)
            self.docIsWtxt = self.GetIsWtxt(docPath)
            htmlPath = self.docIsWtxt and docPath.root+u'.html'
            if htmlPath and (not htmlPath.exists() or (docPath.mtime > htmlPath.mtime)):
                docsDir = bosh.modInfos.dir.join(u'Docs')
                bolt.WryeText.genHtml(docPath,None,docsDir)
            if not editing and htmlPath and htmlPath.exists():
                self.htmlText.Navigate(htmlPath.s,0x2) #--0x2: Clear History
                self.SetDocType('html')
            else:
                # Oddly, wxPython's LoadFile function doesn't read unicode correctly,
                # even in unicode builds
                with docPath.open('r',encoding='utf-8-sig') as ins:
                    data = ins.read()
                self.plainText.SetValue(data)
                self.SetDocType('txt')

    #--Set Doc Type
    def SetDocType(self,docType):
        """Shows the plainText or htmlText view depending on document type (i.e. file name extension)."""
        if docType == self.docType:
            return
        sizer = self.mainSizer
        if docType == 'html':
            sizer.Show(self.plainText,False)
            sizer.Show(self.htmlText,True)
            self.prevButton.Enable(True)
            self.nextButton.Enable(True)
        else:
            sizer.Show(self.plainText,True)
            sizer.Show(self.htmlText,False)
            self.prevButton.Enable(False)
            self.nextButton.Enable(False)
        self.Layout()

    #--Window Closing
    def OnCloseWindow(self, event):
        """Handle window close event.
        Remember window size, position, etc."""
        self.DoSave()
        settings['bash.modDocs.show'] = False
        if not self.IsIconized() and not self.IsMaximized():
            settings['bash.modDocs.pos'] = self.GetPositionTuple()
            settings['bash.modDocs.size'] = self.GetSizeTuple()
        self.Destroy()

#------------------------------------------------------------------------------
class ModChecker(wx.Frame):
    """Mod Checker frame."""
    def __init__(self):
        """Intialize."""
        import wx.lib.iewin
        #--Singleton
        global modChecker
        modChecker = self
        #--Window
        pos = settings.get('bash.modChecker.pos',balt.defPos)
        size = settings.get('bash.modChecker.size',(475,500))
        wx.Frame.__init__(self, bashFrame, wx.ID_ANY, _(u'Mod Checker'), pos, size,
            style=wx.DEFAULT_FRAME_STYLE)
        self.SetBackgroundColour(wx.NullColour)
        self.SetSizeHints(250,250)
        self.SetIcons(bashBlue)
        #--Data
        self.ordered = None
        self.merged = None
        self.imported = None
        #--Text
        self.gTextCtrl = wx.lib.iewin.IEHtmlWindow(self, wx.ID_ANY, style = wx.NO_FULL_REPAINT_ON_RESIZE)
        #--Buttons
        bitmap = wx.ArtProvider_GetBitmap(wx.ART_GO_BACK,wx.ART_HELP_BROWSER, (16,16))
        gBackButton = bitmapButton(self,bitmap,onClick=lambda evt: self.gTextCtrl.GoBack())
        bitmap = wx.ArtProvider_GetBitmap(wx.ART_GO_FORWARD,wx.ART_HELP_BROWSER, (16,16))
        gForwardButton = bitmapButton(self,bitmap,onClick=lambda evt: self.gTextCtrl.GoForward())
        gUpdateButton = button(self,_(u'Update'),onClick=lambda event: self.CheckMods())
        self.gShowModList = toggleButton(self,_(u'Mod List'),onClick=self.CheckMods)
        self.gShowRuleSets = toggleButton(self,_(u'Rule Sets'),onClick=self.CheckMods)
        self.gShowNotes = toggleButton(self,_(u'Notes'),onClick=self.CheckMods)
        self.gShowConfig = toggleButton(self,_(u'Configuration'),onClick=self.CheckMods)
        self.gShowSuggest = toggleButton(self,_(u'Suggestions'),onClick=self.CheckMods)
        self.gShowCRC = toggleButton(self,_(u'CRCs'),onClick=self.CheckMods)
        self.gShowVersion = toggleButton(self,_(u'Version Numbers'),onClick=self.CheckMods)
        if settings['bash.CBashEnabled']:
            self.gScanDirty = toggleButton(self,_(u'Scan for Dirty Edits'),onClick=self.CheckMods)
        else:
            self.gScanDirty = toggleButton(self,_(u"Scan for UDR's"),onClick=self.CheckMods)
        self.gCopyText = button(self,_(u'Copy Text'),onClick=self.OnCopyText)
        self.gShowModList.SetValue(settings.get('bash.modChecker.showModList',False))
        self.gShowNotes.SetValue(settings.get('bash.modChecker.showNotes',True))
        self.gShowConfig.SetValue(settings.get('bash.modChecker.showConfig',True))
        self.gShowSuggest.SetValue(settings.get('bash.modChecker.showSuggest',True))
        self.gShowCRC.SetValue(settings.get('bash.modChecker.showCRC',False))
        self.gShowVersion.SetValue(settings.get('bash.modChecker.showVersion',True))
        #--Events
        self.Bind(wx.EVT_CLOSE, self.OnCloseWindow)
        self.Bind(wx.EVT_ACTIVATE, self.OnActivate)
        #--Layout
        self.SetSizer(
            vSizer(
                (self.gTextCtrl,1,wx.EXPAND|wx.ALL^wx.BOTTOM,2),
                (hSizer(
                    gBackButton,
                    gForwardButton,
                    (self.gShowModList,0,wx.LEFT,4),
                    (self.gShowRuleSets,0,wx.LEFT,4),
                    (self.gShowNotes,0,wx.LEFT,4),
                    (self.gShowConfig,0,wx.LEFT,4),
                    (self.gShowSuggest,0,wx.LEFT,4),
                    ),0,wx.ALL|wx.EXPAND,4),
                (hSizer(
                    (self.gShowVersion,0,wx.LEFT,4),
                    (self.gShowCRC,0,wx.LEFT,4),
                    (self.gScanDirty,0,wx.LEFT,4),
                    (self.gCopyText,0,wx.LEFT,4),
                    spacer,
                    gUpdateButton,
                    ),0,wx.ALL|wx.EXPAND,4),
                )
            )
        self.CheckMods()

    def OnCopyText(self,event=None):
        """Copies text of report to clipboard."""
        text = u'[spoiler]\n'+self.text+u'[/spoiler]'
        text = re.sub(ur'\[\[.+?\|\s*(.+?)\]\]',ur'\1',text,re.U)
        text = re.sub(u'(__|\*\*|~~)',u'',text,re.U)
        text = re.sub(u'&bull; &bull;',u'**',text,re.U)
        text = re.sub(u'<[^>]+>','',text,re.U)
        if (wx.TheClipboard.Open()):
            wx.TheClipboard.SetData(wx.TextDataObject(text))
            wx.TheClipboard.Close()

    def CheckMods(self,event=None):
        """Do mod check."""
        settings['bash.modChecker.showModList'] = self.gShowModList.GetValue()
        settings['bash.modChecker.showRuleSets'] = self.gShowRuleSets.GetValue()
        if not settings['bash.modChecker.showRuleSets']:
            self.gShowNotes.SetValue(False)
            self.gShowConfig.SetValue(False)
            self.gShowSuggest.SetValue(False)
        settings['bash.modChecker.showNotes'] = self.gShowNotes.GetValue()
        settings['bash.modChecker.showConfig'] = self.gShowConfig.GetValue()
        settings['bash.modChecker.showSuggest'] = self.gShowSuggest.GetValue()
        settings['bash.modChecker.showCRC'] = self.gShowCRC.GetValue()
        settings['bash.modChecker.showVersion'] = self.gShowVersion.GetValue()
        #--Cache info from modinfos to support auto-update.
        self.ordered = bosh.modInfos.ordered
        self.merged = bosh.modInfos.merged.copy()
        self.imported = bosh.modInfos.imported.copy()
        #--Do it
        self.text = bosh.configHelpers.checkMods(
            settings['bash.modChecker.showModList'],
            settings['bash.modChecker.showRuleSets'],
            settings['bash.modChecker.showNotes'],
            settings['bash.modChecker.showConfig'],
            settings['bash.modChecker.showSuggest'],
            settings['bash.modChecker.showCRC'],
            settings['bash.modChecker.showVersion'],
            scanDirty=(None,modChecker)[self.gScanDirty.GetValue()]
            )
        logPath = bosh.dirs['saveBase'].join(u'ModChecker.html')
        cssDir = settings.get('balt.WryeLog.cssDir', GPath(u''))
        ins = StringIO.StringIO(self.text+u'\n{{CSS:wtxt_sand_small.css}}')
        with logPath.open('w',encoding='utf-8-sig') as out:
            bolt.WryeText.genHtml(ins,out,cssDir)
        self.gTextCtrl.Navigate(logPath.s,0x2) #--0x2: Clear History

    def OnActivate(self,event):
        """Handle window activate/deactive. Use for auto-updating list."""
        if (event.GetActive() and (
            self.ordered != bosh.modInfos.ordered or
            self.merged != bosh.modInfos.merged or
            self.imported != bosh.modInfos.imported)
            ):
            self.CheckMods()

    def OnCloseWindow(self, event):
        """Handle window close event.
        Remember window size, position, etc."""
        if not self.IsIconized() and not self.IsMaximized():
            settings['bash.modChecker.pos'] = self.GetPositionTuple()
            settings['bash.modChecker.size'] = self.GetSizeTuple()
        self.Destroy()

#------------------------------------------------------------------------------
def GetBashVersion():
    return bass.AppVersion

    #--Version from readme
    #readme = bosh.dirs['mopy'].join(u'Wrye Bash.txt')
    #if readme.exists() and readme.mtime != settings['bash.readme'][0]:
    #    reVersion = re.compile(ur'^=== (\d+(\.(dev|beta)?\d*)?) \[', re.I|re.U)
    #    for line in readme.open(encoding='utf-8-sig'):
    #        maVersion = reVersion.match(line)
    #        if maVersion:
    #            return (readme.mtime,maVersion.group(1))
    #return settings['bash.readme'] #readme file not found or not changed

#------------------------------------------------------------------------------
class BashApp(wx.App):
    """Bash Application class."""
    def Init(self): # not OnInit(), we need to initialize _after_ the app has been instanced
        global appRestart
        appRestart = False
        """wxWindows: Initialization handler."""
        #--Constants
        self.InitResources()
        #--Init Data
        progress = wx.ProgressDialog(u'Wrye Bash',_(u'Initializing Data')+u' '*10,
            style=wx.PD_AUTO_HIDE|wx.PD_APP_MODAL|wx.PD_SMOOTH)
        self.InitData(progress)
        progress.Update(70,_(u'Initializing Version'))
        self.InitVersion()
        #--MWFrame
        progress.Update(80,_(u'Initializing Windows'))
        frame = BashFrame(
             pos=settings['bash.framePos'],
             size=settings['bash.frameSize'])
        progress.Destroy()
        self.SetTopWindow(frame)
        frame.Show()
        balt.ensureDisplayed(frame)
        frame.updater.Start()

    def InitResources(self):
        """Init application resources."""
        global bashBlue, bashRed, bashDocBrowser, bashMonkey, fonts
        bashBlue = bashBlue.GetIconBundle()
        bashRed = bashRed.GetIconBundle()
        bashDocBrowser = bashDocBrowser.GetIconBundle()
        bashMonkey = bashMonkey.GetIconBundle()
        fonts = balt.fonts()

    def InitData(self,progress):
        """Initialize all data. Called by OnInit()."""
        progress.Update(5,_(u'Initializing ModInfos'))
        bosh.gameInis = [bosh.OblivionIni(x) for x in bush.game.iniFiles]
        bosh.oblivionIni = bosh.gameInis[0]
        bosh.trackedInfos = bosh.TrackedFileInfos(bosh.INIInfo)
        bosh.modInfos = bosh.ModInfos()
        bosh.modInfos.refresh(doAutoGroup=True)
        progress.Update(30,_(u'Initializing SaveInfos'))
        bosh.saveInfos = bosh.SaveInfos()
        bosh.saveInfos.refresh()
        progress.Update(40,_(u'Initializing IniInfos'))
        bosh.iniInfos = bosh.INIInfos()
        bosh.iniInfos.refresh()
        #--Patch check
        if bush.game.esp.canBash:
            if not bosh.modInfos.bashed_patches and bosh.inisettings['EnsurePatchExists']:
                progress.Update(68,_(u'Generating Blank Bashed Patch'))
                bosh.PatchFile.generateNextBashedPatch()

    def InitVersion(self):
        """Perform any version to version conversion. Called by OnInit()."""
        #--Renames dictionary: Strings to Paths.
        if settings['bash.version'] < 40:
            #--Renames array
            newRenames = {}
            for key,value in settings['bash.mods.renames'].items():
                newRenames[GPath(key)] = GPath(value)
            settings['bash.mods.renames'] = newRenames
            #--Mod table data
            modTableData = bosh.modInfos.table.data
            for key in modTableData.keys():
                if not isinstance(key,bolt.Path):
                    modTableData[GPath(key)] = modTableData[key]
                    del modTableData[key]
        #--Window sizes by class name rather than by class
        if settings['bash.version'] < 43:
            for key,value in balt.sizes.items():
                if isinstance(key,ClassType):
                    balt.sizes[key.__name__] = value
                    del balt.sizes[key]
        #--Current Version
        settings['bash.version'] = 43
        if settings['bash.version'] != GetBashVersion():
            settings['bash.version'] = GetBashVersion()
            # rescan mergeability
            if not CBash: #Because it is rescanned on showing of patch dialogue anyways so that would double up in CBash Mode.
                nullProgress = bolt.Progress()
                bosh.modInfos.rescanMergeable(bosh.modInfos.data,nullProgress)
        elif settings['bash.CBashEnabled'] != bool(CBash) and not CBash:
            nullProgress = bolt.Progress()
            bosh.modInfos.rescanMergeable(bosh.modInfos.data,nullProgress)
        settings['bash.CBashEnabled'] = bool(CBash)

# Misc Dialogs ----------------------------------------------------------------
#------------------------------------------------------------------------------
class ImportFaceDialog(wx.Dialog):
    """Dialog for importing faces."""
    def __init__(self,parent,id,title,fileInfo,faces):
        #--Data
        self.fileInfo = fileInfo
        if faces and isinstance(faces.keys()[0],(IntType,LongType)):
            self.data = dict((u'%08X %s' % (key,face.pcName),face) for key,face in faces.items())
        else:
            self.data = faces
        self.items = sorted(self.data.keys(),key=string.lower)
        #--GUI
        wx.Dialog.__init__(self,parent,id,title,
            style=wx.DEFAULT_DIALOG_STYLE|wx.RESIZE_BORDER)
        wx.EVT_CLOSE(self, self.OnCloseWindow)
        self.SetSizeHints(550,300)
        #--List Box
        self.list = wx.ListBox(self,wx.ID_OK,choices=self.items,style=wx.LB_SINGLE)
        self.list.SetSizeHints(175,150)
        wx.EVT_LISTBOX(self,wx.ID_OK,self.EvtListBox)
        #--Name,Race,Gender Checkboxes
        self.nameCheck = checkBox(self,_(u'Name'))
        self.raceCheck = checkBox(self,_(u'Race'))
        self.genderCheck = checkBox(self,_(u'Gender'))
        self.statsCheck = checkBox(self,_(u'Stats'))
        self.classCheck = checkBox(self,_(u'Class'))
        flags = bosh.PCFaces.flags(settings.get('bash.faceImport.flags',0x4))
        self.nameCheck.SetValue(flags.name)
        self.raceCheck.SetValue(flags.race)
        self.genderCheck.SetValue(flags.gender)
        self.statsCheck.SetValue(flags.stats)
        self.classCheck.SetValue(flags.iclass)
        #--Name,Race,Gender Text
        self.nameText  = staticText(self,u'-----------------------------')
        self.raceText  = staticText(self,u'')
        self.genderText  = staticText(self,u'')
        self.statsText  = staticText(self,u'')
        self.classText  = staticText(self,u'')
        #--Other
        importButton = button(self,_(u'Import'),onClick=self.DoImport)
        importButton.SetDefault()
        self.picture = balt.Picture(self,350,210,scaling=2)
        #--Layout
        fgSizer = wx.FlexGridSizer(3,2,2,4)
        fgSizer.AddGrowableCol(1,1)
        fgSizer.AddMany([
            self.nameCheck,
            self.nameText,
            self.raceCheck,
            self.raceText,
            self.genderCheck,
            self.genderText,
            self.statsCheck,
            self.statsText,
            self.classCheck,
            self.classText,
            ])
        sizer = hSizer(
            (self.list,1,wx.EXPAND|wx.TOP,4),
            (vSizer(
                self.picture,
                (hSizer(
                    (fgSizer,1),
                    (vSizer(
                        (importButton,0,wx.ALIGN_RIGHT),
                        (button(self,id=wx.ID_CANCEL),0,wx.TOP,4),
                        )),
                    ),0,wx.EXPAND|wx.TOP,4),
                ),0,wx.EXPAND|wx.ALL,4),
            )
        #--Done
        if 'ImportFaceDialog' in balt.sizes:
            self.SetSizer(sizer)
            self.SetSize(balt.sizes['ImportFaceDialog'])
        else:
            self.SetSizerAndFit(sizer)

    def EvtListBox(self,event):
        """Responds to listbox selection."""
        itemDex = event.GetSelection()
        item = self.items[itemDex]
        face = self.data[item]
        self.nameText.SetLabel(face.pcName)
        self.raceText.SetLabel(face.getRaceName())
        self.genderText.SetLabel(face.getGenderName())
        self.statsText.SetLabel(_(u'Health ')+unicode(face.health))
        itemImagePath = bosh.dirs['mods'].join(u'Docs',u'Images','%s.jpg' % item)
        bitmap = (itemImagePath.exists() and
            wx.Bitmap(itemImagePath.s,wx.BITMAP_TYPE_JPEG)) or None
        self.picture.SetBitmap(bitmap)

    def DoImport(self,event):
        """Imports selected face into save file."""
        selections = self.list.GetSelections()
        if not selections:
            wx.Bell()
            return
        itemDex = selections[0]
        item = self.items[itemDex]
        #--Do import
        flags = bosh.PCFaces.flags()
        flags.hair = flags.eye = True
        flags.name = self.nameCheck.GetValue()
        flags.race = self.raceCheck.GetValue()
        flags.gender = self.genderCheck.GetValue()
        flags.stats = self.statsCheck.GetValue()
        flags.iclass = self.classCheck.GetValue()
        #deprint(flags.getTrueAttrs())
        settings['bash.faceImport.flags'] = int(flags)
        bosh.PCFaces.save_setFace(self.fileInfo,self.data[item],flags)
        balt.showOk(self,_(u'Face imported.'),self.fileInfo.name.s)
        self.EndModal(wx.ID_OK)

    #--Window Closing
    def OnCloseWindow(self, event):
        """Handle window close event.
        Remember window size, position, etc."""
        balt.sizes['ImportFaceDialog'] = self.GetSizeTuple()
        self.Destroy()

# Patchers 00 ------------------------------------------------------------------
#------------------------------------------------------------------------------
class PatchDialog(wx.Dialog):
    """Bash Patch update dialog."""
    patchers = []       #--All patchers. These are copied as needed.
    CBash_patchers = [] #--All patchers (CBash mode).  These are copied as needed.

    def __init__(self,parent,patchInfo,doCBash=None,importConfig=True):
        """Initialized."""
        self.parent = parent
        if (doCBash or doCBash is None) and settings['bash.CBashEnabled']:
            doCBash = True
        else:
            doCBash = False
        self.doCBash = doCBash
        size = balt.sizes.get(self.__class__.__name__,(500,600))
        wx.Dialog.__init__(self,parent,wx.ID_ANY,_(u'Update ')+patchInfo.name.s+[u'',u' (CBash)'][doCBash], size=size,
            style=wx.DEFAULT_DIALOG_STYLE|wx.RESIZE_BORDER)
        self.SetSizeHints(400,300)
        #--Data
        groupOrder = dict([(group,index) for index,group in
            enumerate((_(u'General'),_(u'Importers'),_(u'Tweakers'),_(u'Special')))])
        patchConfigs = bosh.modInfos.table.getItem(patchInfo.name,'bash.patch.configs',{})
        # If the patch config isn't from the same mode (CBash/Python), try converting
        # it over to the current mode
        configIsCBash = bosh.CBash_PatchFile.configIsCBash(patchConfigs)
        if configIsCBash != self.doCBash:
            if importConfig:
                patchConfigs = self.ConvertConfig(patchConfigs)
            else:
                patchConfigs = {}
        isFirstLoad = 0 == len(patchConfigs)
        self.patchInfo = patchInfo
        if doCBash:
            self.patchers = [copy.deepcopy(patcher) for patcher in PatchDialog.CBash_patchers]
        else:
            self.patchers = [copy.deepcopy(patcher) for patcher in PatchDialog.patchers]
        self.patchers.sort(key=lambda a: a.__class__.name)
        self.patchers.sort(key=lambda a: groupOrder[a.__class__.group])
        for patcher in self.patchers:
            patcher.getConfig(patchConfigs) #--Will set patcher.isEnabled
            if u'UNDEFINED' in (patcher.__class__.group, patcher.__class__.group):
                raise UncodedError(u'Name or group not defined for: %s' % patcher.__class__.__name__)
            patcher.SetCallbackFns(self._CheckPatcher, self._BoldPatcher)
            patcher.SetIsFirstLoad(isFirstLoad)
        self.currentPatcher = None
        patcherNames = [patcher.getName() for patcher in self.patchers]
        #--GUI elements
        self.gExecute = button(self,id=wx.ID_OK,label=_(u'Build Patch'),onClick=self.Execute)
        self.gSelectAll = button(self,id=wx.wx.ID_SELECTALL,label=_(u'Select All'),onClick=self.SelectAll)
        self.gDeselectAll = button(self,id=wx.wx.ID_SELECTALL,label=_(u'Deselect All'),onClick=self.DeselectAll)
        cancelButton = button(self,id=wx.ID_CANCEL,label=_(u'Cancel'))
        self.gPatchers = wx.CheckListBox(self,wx.ID_ANY,choices=patcherNames,style=wx.LB_SINGLE)
        self.gExportConfig = button(self,id=wx.ID_SAVEAS,label=_(u'Export'),onClick=self.ExportConfig)
        self.gImportConfig = button(self,id=wx.ID_OPEN,label=_(u'Import'),onClick=self.ImportConfig)
        self.gRevertConfig = button(self,id=wx.ID_REVERT_TO_SAVED,label=_(u'Revert To Saved'),onClick=self.RevertConfig)
        self.gRevertToDefault = button(self,id=wx.ID_REVERT,label=_(u'Revert To Default'),onClick=self.DefaultConfig)
        for index,patcher in enumerate(self.patchers):
            self.gPatchers.Check(index,patcher.isEnabled)
        self.defaultTipText = _(u'Items that are new since the last time this patch was built are displayed in bold')
        self.gTipText = staticText(self,self.defaultTipText)
        #--Events
        self.Bind(wx.EVT_SIZE,self.OnSize)
        self.gPatchers.Bind(wx.EVT_LISTBOX, self.OnSelect)
        self.gPatchers.Bind(wx.EVT_CHECKLISTBOX, self.OnCheck)
        self.gPatchers.Bind(wx.EVT_MOTION,self.OnMouse)
        self.gPatchers.Bind(wx.EVT_LEAVE_WINDOW,self.OnMouse)
        self.gPatchers.Bind(wx.EVT_CHAR,self.OnChar)
        self.mouseItem = -1
        #--Layout
        self.gConfigSizer = gConfigSizer = vSizer()
        sizer = vSizer(
            (hSizer(
                (self.gPatchers,0,wx.EXPAND),
                (self.gConfigSizer,1,wx.EXPAND|wx.LEFT,4),
                ),1,wx.EXPAND|wx.ALL,4),
            (self.gTipText,0,wx.EXPAND|wx.ALL^wx.TOP,4),
            (wx.StaticLine(self),0,wx.EXPAND|wx.BOTTOM,4),
            (hSizer(
                spacer,
                (self.gExportConfig,0,wx.LEFT,4),
                (self.gImportConfig,0,wx.LEFT,4),
                (self.gRevertConfig,0,wx.LEFT,4),
                (self.gRevertToDefault,0,wx.LEFT,4),
                ),0,wx.EXPAND|wx.LEFT|wx.RIGHT|wx.BOTTOM,4),
            (hSizer(
                spacer,
                self.gExecute,
                (self.gSelectAll,0,wx.LEFT,4),
                (self.gDeselectAll,0,wx.LEFT,4),
                (cancelButton,0,wx.LEFT,4),
                ),0,wx.EXPAND|wx.LEFT|wx.RIGHT|wx.BOTTOM,4)
            )
        self.SetSizer(sizer)
        self.SetIcons(bashMonkey)
        #--Patcher panels
        for patcher in self.patchers:
            gConfigPanel = patcher.GetConfigPanel(self,gConfigSizer,self.gTipText)
            gConfigSizer.Show(gConfigPanel,False)
        self.gPatchers.Select(1)
        self.ShowPatcher(self.patchers[1])
        self.SetOkEnable()

    #--Core -------------------------------
    def SetOkEnable(self):
        """Sets enable state for Ok button."""
        for patcher in self.patchers:
            if patcher.isEnabled:
                return self.gExecute.Enable(True)
        self.gExecute.Enable(False)

    def ShowPatcher(self,patcher):
        """Show patcher panel."""
        gConfigSizer = self.gConfigSizer
        if patcher == self.currentPatcher: return
        if self.currentPatcher != None:
            gConfigSizer.Show(self.currentPatcher.gConfigPanel,False)
        gConfigPanel = patcher.GetConfigPanel(self,gConfigSizer,self.gTipText)
        gConfigSizer.Show(gConfigPanel,True)
        self.Layout()
        patcher.Layout()
        self.currentPatcher = patcher

    def Execute(self,event=None):
        """Do the patch."""
        self.EndModal(wx.ID_OK)
        patchName = self.patchInfo.name
        progress = balt.Progress(patchName.s,(u' '*60+u'\n'), abort=True)
        ###Remove from Bash after CBash integrated
        patchFile = None
        if self.doCBash:
            try:
                from datetime import timedelta
                timer1 = time.clock()
                fullName = self.patchInfo.getPath().tail
                #--Save configs
                patchConfigs = {'ImportedMods':set()}
                for patcher in self.patchers:
                    patcher.saveConfig(patchConfigs)
                bosh.modInfos.table.setItem(patchName,'bash.patch.configs',patchConfigs)
                #--Do it
                log = bolt.LogFile(StringIO.StringIO())
                patchers = [patcher for patcher in self.patchers if patcher.isEnabled]

                patchFile = bosh.CBash_PatchFile(patchName,patchers)
                #try to speed this up!
                patchFile.initData(SubProgress(progress,0,0.1))
                #try to speed this up!
                patchFile.buildPatch(SubProgress(progress,0.1,0.9))
                #no speeding needed/really possible (less than 1/4 second even with large LO)
                patchFile.buildPatchLog(patchName,log,SubProgress(progress,0.95,0.99))
                #--Save
                progress.setCancel(False)
                progress(1.0,patchName.s+u'\n'+_(u'Saving...'))
                patchFile.save()
                patchTime = fullName.mtime
                try:
                    patchName.untemp()
                except WindowsError, werr:
                    if werr.winerror != 32: raise
                    while balt.askYes(self,(_(u'Bash encountered an error when renaming %s to %s.')
                                            + u'\n\n' +
                                            _(u'The file is in use by another process such as TES4Edit.')
                                            + u'\n' +
                                            _(u'Please close the other program that is accessing %s.')
                                            + u'\n\n' +
                                            _(u'Try again?')) % (patchName.temp.s, patchName.s, patchName.s),
                                      _(u'Bash Patch - Save Error')):
                        try:
                            patchName.untemp()
                        except WindowsError, werr:
                            continue
                        break
                    else:
                        raise
                patchName.mtime = patchTime
                #--Cleanup
                self.patchInfo.refresh()
                modList.RefreshUI(patchName)
                #--Done
                progress.Destroy()
                timer2 = time.clock()
                #--Readme and log
                log.setHeader(None)
                log(u'{{CSS:wtxt_sand_small.css}}')
                logValue = log.out.getvalue()
                log.out.close()
                timerString = unicode(timedelta(seconds=round(timer2 - timer1, 3))).rstrip(u'0')
                logValue = re.sub(u'TIMEPLACEHOLDER', timerString, logValue, 1)
                readme = bosh.modInfos.dir.join(u'Docs',patchName.sroot+u'.txt')
                with readme.open('w',encoding='utf-8') as file:
                    file.write(logValue)
                bosh.modInfos.table.setItem(patchName,'doc',readme)
                #--Convert log/readme to wtxt and show log
                docsDir = bosh.modInfos.dir.join(u'Docs')
                bolt.WryeText.genHtml(readme,None,docsDir)
                balt.playSound(self.parent,bosh.inisettings['SoundSuccess'].s)
                balt.showWryeLog(self.parent,readme.root+u'.html',patchName.s,icons=bashBlue)
                #--Select?
                message = _(u'Activate %s?') % patchName.s
                if bosh.modInfos.isSelected(patchName) or balt.askYes(self.parent,message,patchName.s):
                    try:
                        oldFiles = bosh.modInfos.ordered[:]
                        bosh.modInfos.select(patchName)
                        changedFiles = bolt.listSubtract(bosh.modInfos.ordered,oldFiles)
                        if len(changedFiles) > 1:
                            statusBar.SetText(_(u'Masters Activated: ') + unicode(len(changedFiles)-1))
                    except bosh.PluginsFullError:
                        balt.showError(self,
                            _(u'Unable to add mod %s because load list is full.')
                            % patchName.s)
                    modList.RefreshUI()
            except bolt.FileEditError, error:
                balt.playSound(self.parent,bosh.inisettings['SoundError'].s)
                balt.showError(self,u'%s'%error,_(u'File Edit Error'))
            except BoltError, error:
                balt.playSound(self.parent,bosh.inisettings['SoundError'].s)
                balt.showError(self,u'%s'%error,_(u'Processing Error'))
            except CancelError:
                pass
            except:
                balt.playSound(self.parent,bosh.inisettings['SoundError'].s)
                raise
            finally:
                try:
                    patchFile.Current.Close()
                except:
                    pass
                progress.Destroy()
        else:
            try:
                from datetime import timedelta
                timer1 = time.clock()
                #--Save configs
                patchConfigs = {'ImportedMods':set()}
                for patcher in self.patchers:
                    patcher.saveConfig(patchConfigs)
                bosh.modInfos.table.setItem(patchName,'bash.patch.configs',patchConfigs)
                #--Do it
                log = bolt.LogFile(StringIO.StringIO())
                nullProgress = bolt.Progress()
                patchers = [patcher for patcher in self.patchers if patcher.isEnabled]
                patchFile = bosh.PatchFile(self.patchInfo,patchers)
                patchFile.initData(SubProgress(progress,0,0.1)) #try to speed this up!
                patchFile.initFactories(SubProgress(progress,0.1,0.2)) #no speeding needed/really possible (less than 1/4 second even with large LO)
                patchFile.scanLoadMods(SubProgress(progress,0.2,0.8)) #try to speed this up!
                patchFile.buildPatch(log,SubProgress(progress,0.8,0.9))#no speeding needed/really possible (less than 1/4 second even with large LO)
                #--Save
                progress.setCancel(False)
                progress(0.9,patchName.s+u'\n'+_(u'Saving...'))
                try:
                    patchFile.safeSave()
                except WindowsError, werr:
                    if werr.winerror != 32: raise
                    while balt.askYes(self,(_(u'Bash encountered an error when saving %s.')
                                            + u'\n\n' +
                                            _(u'The file is in use by another process such as TES4Edit.')
                                            + u'\n' +
                                            _(u'Please close the other program that is accessing %s.')
                                            + u'\n\n' +
                                            _(u'Try again?')) % (patchName.s,patchName.s),
                                      _(u'Bash Patch - Save Error')):
                        try:
                            patchFile.safeSave()
                        except WindowsError, werr:
                            continue
                        break
                    else:
                        raise

                #--Cleanup
                self.patchInfo.refresh()
                modList.RefreshUI(patchName)
                #--Done
                progress.Destroy()
                timer2 = time.clock()
                #--Readme and log
                log.setHeader(None)
                log(u'{{CSS:wtxt_sand_small.css}}')
                logValue = log.out.getvalue()
                log.out.close()
                timerString = unicode(timedelta(seconds=round(timer2 - timer1, 3))).rstrip(u'0')
                logValue = re.sub(u'TIMEPLACEHOLDER', timerString, logValue, 1)
                readme = bosh.modInfos.dir.join(u'Docs',patchName.sroot+u'.txt')
                with readme.open('w',encoding='utf-8-sig') as file:
                    file.write(logValue)
                bosh.modInfos.table.setItem(patchName,'doc',readme)
                #--Convert log/readme to wtxt and show log
                docsDir = bosh.modInfos.dir.join(u'Docs')
                bolt.WryeText.genHtml(readme,None,docsDir)
                balt.playSound(self.parent,bosh.inisettings['SoundSuccess'].s)
                balt.showWryeLog(self.parent,readme.root+u'.html',patchName.s,icons=bashBlue)
                #--Select?
                message = _(u'Activate %s?') % patchName.s
                if bosh.modInfos.isSelected(patchName) or balt.askYes(self.parent,message,patchName.s):
                    try:
                        # Note to the regular WB devs:
                        #  The bashed patch wasn't activating when it had been manually deleting. So, on
                        #   startup, WB would create a new one, but something, somewhere (BAPI?) wasn't
                        #   registering this so when this: bosh.modInfos.select(patchName) executed, bash
                        #   couldn't actually find anything to execute. This fix really belongs somewhere else
                        #   (after the patch is recreated?), but I don't know where it goes, so I'm sticking it
                        #   here until one of you come back or I find a better place.
                        bosh.modInfos.plugins.refresh(True)
                        oldFiles = bosh.modInfos.ordered[:]
                        bosh.modInfos.select(patchName)
                        changedFiles = bolt.listSubtract(bosh.modInfos.ordered,oldFiles)
                        if len(changedFiles) > 1:
                            statusBar.SetText(_(u'Masters Activated: ') + unicode(len(changedFiles)-1))
                    except bosh.PluginsFullError:
                        balt.showError(self,
                            _(u'Unable to add mod %s because load list is full.')
                            % patchName.s)
                    modList.RefreshUI()
            except bolt.FileEditError, error:
                balt.playSound(self.parent,bosh.inisettings['SoundError'].s)
                balt.showError(self,u'%s'%error,_(u'File Edit Error'))
            except BoltError, error:
                balt.playSound(self.parent,bosh.inisettings['SoundError'].s)
                balt.showError(self,u'%s'%error,_(u'Processing Error'))
            except CancelError:
                pass
            except:
                balt.playSound(self.parent,bosh.inisettings['SoundError'].s)
                raise
            finally:
                progress.Destroy()

    def SaveConfig(self,event=None):
        """Save the configuration"""
        patchName = self.patchInfo.name
        patchConfigs = {'ImportedMods':set()}
        for patcher in self.patchers:
            patcher.saveConfig(patchConfigs)
        bosh.modInfos.table.setItem(patchName,'bash.patch.configs',patchConfigs)

    def ExportConfig(self,event=None):
        """Export the configuration to a user selected dat file."""
        patchName = self.patchInfo.name + _(u'_Configuration.dat')
        textDir = bosh.dirs['patches']
        textDir.makedirs()
        #--File dialog
        textPath = balt.askSave(self.parent,_(u'Export Bashed Patch configuration to:'),
                                textDir,patchName, u'*Configuration.dat')
        if not textPath: return
        pklPath = textPath+u'.pkl'
        table = bolt.Table(bosh.PickleDict(textPath, pklPath))
        patchConfigs = {'ImportedMods':set()}
        for patcher in self.patchers:
            patcher.saveConfig(patchConfigs)
        table.setItem(bolt.Path(u'Saved Bashed Patch Configuration (%s)' % ([u'Python',u'CBash'][self.doCBash])),'bash.patch.configs',patchConfigs)
        table.save()

    def ImportConfig(self,event=None):
        """Import the configuration to a user selected dat file."""
        patchName = self.patchInfo.name + _(u'_Configuration.dat')
        textDir = bosh.dirs['patches']
        textDir.makedirs()
        #--File dialog
        textPath = balt.askOpen(self.parent,_(u'Import Bashed Patch configuration from:'),textDir,patchName, u'*.dat',mustExist=True)
        if not textPath: return
        pklPath = textPath+u'.pkl'
        table = bolt.Table(bosh.PickleDict(
            textPath, pklPath))
        #try the current Bashed Patch mode.
        patchConfigs = table.getItem(bolt.Path(u'Saved Bashed Patch Configuration (%s)' % ([u'Python',u'CBash'][self.doCBash])),'bash.patch.configs',{})
        if not patchConfigs: #try the old format:
            patchConfigs = table.getItem(bolt.Path(u'Saved Bashed Patch Configuration'),'bash.patch.configs',{})
            if patchConfigs:
                configIsCBash = bosh.CBash_PatchFile.configIsCBash(patchConfigs)
                if configIsCBash != self.doCBash:
                    patchConfigs = self.UpdateConfig(patchConfigs)
            else:   #try the non-current Bashed Patch mode:
                patchConfigs = table.getItem(bolt.Path(u'Saved Bashed Patch Configuration (%s)' % ([u'CBash',u'Python'][self.doCBash])),'bash.patch.configs',{})
                if patchConfigs:
                    patchConfigs = self.UpdateConfig(patchConfigs)
        if patchConfigs is None:
            patchConfigs = {}
        for index,patcher in enumerate(self.patchers):
            patcher.SetIsFirstLoad(False)
            patcher.getConfig(patchConfigs)
            self.gPatchers.Check(index,patcher.isEnabled)
            if hasattr(patcher, 'gList'):
                if patcher.getName() == 'Leveled Lists': continue #not handled yet!
                for index, item in enumerate(patcher.items):
                    try:
                        patcher.gList.Check(index,patcher.configChecks[item])
                    except KeyError: pass#deprint(_(u'item %s not in saved configs') % (item))
            if hasattr(patcher, 'gTweakList'):
                for index, item in enumerate(patcher.tweaks):
                    try:
                        patcher.gTweakList.Check(index,item.isEnabled)
                        patcher.gTweakList.SetString(index,item.getListLabel())
                    except: deprint(_(u'item %s not in saved configs') % (item))
        self.SetOkEnable()

    def UpdateConfig(self,patchConfigs,event=None):
        if not balt.askYes(self.parent,
            _(u"Wrye Bash detects that the selected file was saved in Bash's %s mode, do you want Wrye Bash to attempt to adjust the configuration on import to work with %s mode (Good chance there will be a few mistakes)? (Otherwise this import will have no effect.)")
                % ([u'CBash',u'Python'][self.doCBash],
                   [u'Python',u'CBash'][self.doCBash])):
            return
        if self.doCBash:
            bosh.PatchFile.patchTime = bosh.CBash_PatchFile.patchTime
            bosh.PatchFile.patchName = bosh.CBash_PatchFile.patchName
        else:
            bosh.CBash_PatchFile.patchTime = bosh.PatchFile.patchTime
            bosh.CBash_PatchFile.patchName = bosh.PatchFile.patchName
        return self.ConvertConfig(patchConfigs)

    def ConvertConfig(self,patchConfigs):
        newConfig = {}
        for key in patchConfigs:
            if key in otherPatcherDict:
                newConfig[otherPatcherDict[key].__class__.__name__] = patchConfigs[key]
            else:
                newConfig[key] = patchConfigs[key]
        return newConfig

    def RevertConfig(self,event=None):
        """Revert configuration back to saved"""
        patchConfigs = bosh.modInfos.table.getItem(self.patchInfo.name,'bash.patch.configs',{})
        if bosh.CBash_PatchFile.configIsCBash(patchConfigs) and not self.doCBash:
            patchConfigs = self.ConvertConfig(patchConfigs)
        for index,patcher in enumerate(self.patchers):
            patcher.SetIsFirstLoad(False)
            patcher.getConfig(patchConfigs)
            self.gPatchers.Check(index,patcher.isEnabled)
            if hasattr(patcher, 'gList'):
                if patcher.getName() == 'Leveled Lists': continue #not handled yet!
                for index, item in enumerate(patcher.items):
                    try: patcher.gList.Check(index,patcher.configChecks[item])
                    except Exception, err: deprint(_(u'Error reverting Bashed patch configuration (error is: %s). Item %s skipped.') % (err,item))
            if hasattr(patcher, 'gTweakList'):
                for index, item in enumerate(patcher.tweaks):
                    try:
                        patcher.gTweakList.Check(index,item.isEnabled)
                        patcher.gTweakList.SetString(index,item.getListLabel())
                    except Exception, err: deprint(_(u'Error reverting Bashed patch configuration (error is: %s). Item %s skipped.') % (err,item))
        self.SetOkEnable()

    def DefaultConfig(self,event=None):
        """Revert configuration back to default"""
        patchConfigs = {}
        for index,patcher in enumerate(self.patchers):
            patcher.SetIsFirstLoad(True)
            patcher.getConfig(patchConfigs)
            self.gPatchers.Check(index,patcher.isEnabled)
            if hasattr(patcher, 'gList'):
                patcher.SetItems(patcher.getAutoItems())
            if hasattr(patcher, 'gTweakList'):
                for index, item in enumerate(patcher.tweaks):
                    try:
                        patcher.gTweakList.Check(index,item.isEnabled)
                        patcher.gTweakList.SetString(index,item.getListLabel())
                    except Exception, err: deprint(_(u'Error reverting Bashed patch configuration (error is: %s). Item %s skipped.') % (err,item))
        self.SetOkEnable()

    def SelectAll(self,event=None):
        """Select all patchers and entries in patchers with child entries."""
        for index,patcher in enumerate(self.patchers):
            self.gPatchers.Check(index,True)
            patcher.isEnabled = True
            if hasattr(patcher, 'gList'):
                if patcher.getName() == 'Leveled Lists': continue
                for index, item in enumerate(patcher.items):
                    patcher.gList.Check(index,True)
                    patcher.configChecks[item] = True
            if hasattr(patcher, 'gTweakList'):
                for index, item in enumerate(patcher.tweaks):
                    patcher.gTweakList.Check(index,True)
                    item.isEnabled = True
            self.gExecute.Enable(True)

    def DeselectAll(self,event=None):
        """Deselect all patchers and entries in patchers with child entries."""
        for index,patcher in enumerate(self.patchers):
            self.gPatchers.Check(index,False)
            patcher.isEnabled = False
            if patcher.getName() in [_(u'Leveled Lists'),_(u"Alias Mod Names")]: continue # special case that one.
            if hasattr(patcher, 'gList'):
                patcher.gList.SetChecked([])
                patcher.OnListCheck()
            if hasattr(patcher, 'gTweakList'):
                patcher.gTweakList.SetChecked([])
        self.gExecute.Enable(False)

    #--GUI --------------------------------
    def OnSize(self,event):
        balt.sizes[self.__class__.__name__] = self.GetSizeTuple()
        self.Layout()
        self.currentPatcher.Layout()

    def OnSelect(self,event):
        """Responds to patchers list selection."""
        itemDex = event.GetSelection()
        self.ShowPatcher(self.patchers[itemDex])

    def _CheckPatcher(self,patcher):
        """Remotely enables a patcher.  Called from a particular patcher's OnCheck method."""
        index = self.patchers.index(patcher)
        self.gPatchers.Check(index)
        patcher.isEnabled = True
        self.SetOkEnable()

    def _BoldPatcher(self,patcher):
        """Set the patcher label to bold font.  Called from a patcher when it realizes it has something new in its list"""
        index = self.patchers.index(patcher)
        font = self.gPatchers.GetFont()
        font.SetWeight(wx.FONTWEIGHT_BOLD)
        self.gPatchers.SetItemFont(index, font)

    def OnCheck(self,event):
        """Toggle patcher activity state."""
        index = event.GetSelection()
        patcher = self.patchers[index]
        patcher.isEnabled = self.gPatchers.IsChecked(index)
        self.gPatchers.SetSelection(index)
        self.ShowPatcher(patcher)
        self.SetOkEnable()

    def OnMouse(self,event):
        """Check mouse motion to detect right click event."""
        if event.Moving():
            mouseItem = (event.m_y/self.gPatchers.GetItemHeight() +
                self.gPatchers.GetScrollPos(wx.VERTICAL))
            if mouseItem != self.mouseItem:
                self.mouseItem = mouseItem
                self.MouseEnteredItem(mouseItem)
        elif event.Leaving():
            self.gTipText.SetLabel(self.defaultTipText)
            self.mouseItem = -1
        event.Skip()

    def MouseEnteredItem(self,item):
        """Show tip text when changing item."""
        #--Following isn't displaying correctly.
        if item < len(self.patchers):
            patcherClass = self.patchers[item].__class__
            tip = patcherClass.tip or re.sub(ur'\..*',u'.',patcherClass.text.split(u'\n')[0],flags=re.U)
            self.gTipText.SetLabel(tip)
        else:
            self.gTipText.SetLabel(self.defaultTipText)

    def OnChar(self,event):
        """Keyboard input to the patchers list box"""
        if event.GetKeyCode() == 1 and event.CmdDown(): # Ctrl+'A'
            patcher = self.currentPatcher
            if patcher is not None:
                if event.ShiftDown():
                    patcher.DeselectAll()
                else:
                    patcher.SelectAll()
                return
        event.Skip()

#------------------------------------------------------------------------------
class Patcher:
    def SetCallbackFns(self,checkPatcherFn,boldPatcherFn):
        self._checkPatcherFn = checkPatcherFn
        self._boldPatcherFn = boldPatcherFn

    def SetIsFirstLoad(self,isFirstLoad):
        self._isFirstLoad = isFirstLoad

    def _EnsurePatcherEnabled(self):
        if hasattr(self, '_checkPatcherFn'):
            self._checkPatcherFn(self)

    def _BoldPatcherLabel(self):
        if hasattr(self, '_boldPatcherFn'):
            self._boldPatcherFn(self)

    def _GetIsFirstLoad(self):
        if hasattr(self, '_isFirstLoad'):
            return self._isFirstLoad
        else:
            return False

    """Basic patcher panel with no options."""
    def GetConfigPanel(self,parent,gConfigSizer,gTipText):
        """Show config."""
        if not self.gConfigPanel:
            self.gTipText = gTipText
            gConfigPanel = self.gConfigPanel = wx.Window(parent,wx.ID_ANY)
            text = fill(self.text,70)
            gText = staticText(self.gConfigPanel,text)
            gSizer = vSizer(gText)
            gConfigPanel.SetSizer(gSizer)
            gConfigSizer.Add(gConfigPanel,1,wx.EXPAND)
        return self.gConfigPanel

    def Layout(self):
        """Layout control components."""
        if self.gConfigPanel:
            self.gConfigPanel.Layout()

#------------------------------------------------------------------------------
class AliasesPatcher(Patcher,bosh.AliasesPatcher):
    """Basic patcher panel with no options."""
    def GetConfigPanel(self,parent,gConfigSizer,gTipText):
        """Show config."""
        if self.gConfigPanel: return self.gConfigPanel
        #--Else...
        #--Tip
        self.gTipText = gTipText
        gConfigPanel = self.gConfigPanel = wx.Window(parent,wx.ID_ANY)
        text = fill(self.__class__.text,70)
        gText = staticText(gConfigPanel,text)
        #gExample = staticText(gConfigPanel,
        #    _(u"Example Mod 1.esp >> Example Mod 1.2.esp"))
        #--Aliases Text
        self.gAliases = wx.TextCtrl(gConfigPanel,wx.ID_ANY,u'',style=wx.TE_MULTILINE)
        self.gAliases.Bind(wx.EVT_KILL_FOCUS, self.OnEditAliases)
        self.SetAliasText()
        #--Sizing
        gSizer = vSizer(
            gText,
            #(gExample,0,wx.EXPAND|wx.TOP,8),
            (self.gAliases,1,wx.EXPAND|wx.TOP,4))
        gConfigPanel.SetSizer(gSizer)
        gConfigSizer.Add(gConfigPanel,1,wx.EXPAND)
        return self.gConfigPanel

    def SetAliasText(self):
        """Sets alias text according to current aliases."""
        self.gAliases.SetValue(u'\n'.join([
            u'%s >> %s' % (key.s,value.s) for key,value in sorted(self.aliases.items())]))

    def OnEditAliases(self,event):
        text = self.gAliases.GetValue()
        self.aliases.clear()
        for line in text.split(u'\n'):
            fields = map(string.strip,line.split(u'>>'))
            if len(fields) != 2 or not fields[0] or not fields[1]: continue
            self.aliases[GPath(fields[0])] = GPath(fields[1])
        self.SetAliasText()

class CBash_AliasesPatcher(Patcher,bosh.CBash_AliasesPatcher):
    """Basic patcher panel with no options."""
    def GetConfigPanel(self,parent,gConfigSizer,gTipText):
        """Show config."""
        if self.gConfigPanel: return self.gConfigPanel
        #--Else...
        #--Tip
        self.gTipText = gTipText
        gConfigPanel = self.gConfigPanel = wx.Window(parent,wx.ID_ANY)
        text = fill(self.text,70)
        gText = staticText(gConfigPanel,text)
        #gExample = staticText(gConfigPanel,
        #    _(u"Example Mod 1.esp >> Example Mod 1.2.esp"))
        #--Aliases Text
        self.gAliases = wx.TextCtrl(gConfigPanel,wx.ID_ANY,u'',style=wx.TE_MULTILINE)
        self.gAliases.Bind(wx.EVT_KILL_FOCUS, self.OnEditAliases)
        self.SetAliasText()
        #--Sizing
        gSizer = vSizer(
            gText,
            #(gExample,0,wx.EXPAND|wx.TOP,8),
            (self.gAliases,1,wx.EXPAND|wx.TOP,4))
        gConfigPanel.SetSizer(gSizer)
        gConfigSizer.Add(gConfigPanel,1,wx.EXPAND)
        return self.gConfigPanel

    def SetAliasText(self):
        """Sets alias text according to current aliases."""
        self.gAliases.SetValue(u'\n'.join([
            u'%s >> %s' % (key.s,value.s) for key,value in sorted(self.aliases.items())]))

    def OnEditAliases(self,event):
        text = self.gAliases.GetValue()
        self.aliases.clear()
        for line in text.split(u'\n'):
            fields = map(string.strip,line.split(u'>>'))
            if len(fields) != 2 or not fields[0] or not fields[1]: continue
            self.aliases[GPath(fields[0])] = GPath(fields[1])
        self.SetAliasText()

#------------------------------------------------------------------------------
class ListPatcher(Patcher):
    """Patcher panel with option to select source elements."""
    listLabel = _(u'Source Mods/Files')

    def GetConfigPanel(self,parent,gConfigSizer,gTipText):
        """Show config."""
        if self.gConfigPanel: return self.gConfigPanel
        #--Else...
        self.forceItemCheck = self.__class__.forceItemCheck
        self.selectCommands = self.__class__.selectCommands
        self.gTipText = gTipText
        gConfigPanel = self.gConfigPanel = wx.Window(parent,wx.ID_ANY)
        text = fill(self.text,70)
        gText = staticText(self.gConfigPanel,text)
        if self.forceItemCheck:
            self.gList = wx.ListBox(gConfigPanel,wx.ID_ANY)
        else:
            self.gList =wx.CheckListBox(gConfigPanel,wx.ID_ANY)
            self.gList.Bind(wx.EVT_CHECKLISTBOX,self.OnListCheck)
        #--Events
        self.gList.Bind(wx.EVT_MOTION,self.OnMouse)
        self.gList.Bind(wx.EVT_RIGHT_DOWN,self.OnMouse)
        self.gList.Bind(wx.EVT_RIGHT_UP,self.OnMouse)
        self.mouseItem = -1
        self.mouseState = None
        #--Manual controls
        if self.forceAuto:
            gManualSizer = None
            self.SetItems(self.getAutoItems())
        else:
            self.gAuto = checkBox(gConfigPanel,_(u'Automatic'),onCheck=self.OnAutomatic)
            self.gAuto.SetValue(self.autoIsChecked)
            self.gAdd = button(gConfigPanel,_(u'Add'),onClick=self.OnAdd)
            self.gRemove = button(gConfigPanel,_(u'Remove'),onClick=self.OnRemove)
            self.OnAutomatic()
            gManualSizer = (vSizer(
                (self.gAuto,0,wx.TOP,2),
                (self.gAdd,0,wx.TOP,12),
                (self.gRemove,0,wx.TOP,4),
                ),0,wx.EXPAND|wx.LEFT,4)
        if self.selectCommands:
            self.gSelectAll= button(gConfigPanel,_(u'Select All'),onClick=self.SelectAll)
            self.gDeselectAll = button(gConfigPanel,_(u'Deselect All'),onClick=self.DeselectAll)
            gSelectSizer = (vSizer(
                (self.gSelectAll,0,wx.TOP,12),
                (self.gDeselectAll,0,wx.TOP,4),
                ),0,wx.EXPAND|wx.LEFT,4)
        else: gSelectSizer = None
        #--Layout
        gSizer = vSizer(
            (gText,),
            (hsbSizer((gConfigPanel,wx.ID_ANY,self.__class__.listLabel),
                ((4,0),0,wx.EXPAND),
                (self.gList,1,wx.EXPAND|wx.TOP,2),
                gManualSizer,gSelectSizer,
                ),1,wx.EXPAND|wx.TOP,4),
            )
        gConfigPanel.SetSizer(gSizer)
        gConfigSizer.Add(gConfigPanel,1,wx.EXPAND)
        return gConfigPanel

    def SetItems(self,items):
        """Set item to specified set of items."""
        items = self.items = self.sortConfig(items)
        forceItemCheck = self.forceItemCheck
        defaultItemCheck = self.__class__.canAutoItemCheck and bosh.inisettings['AutoItemCheck']
        self.gList.Clear()
        isFirstLoad = self._GetIsFirstLoad()
        patcherOn = False
        patcherBold = False
        for index,item in enumerate(items):
            itemLabel = self.getItemLabel(item)
            self.gList.Insert(itemLabel,index)
            if forceItemCheck:
                if self.configChecks.get(item) is None:
                    patcherOn = True
                self.configChecks[item] = True
            else:
                effectiveDefaultItemCheck = defaultItemCheck and not itemLabel.endswith(u'.csv')
                if self.configChecks.get(item) is None:
                    if effectiveDefaultItemCheck:
                        patcherOn = True
                    if not isFirstLoad:
                        # indicate that this is a new item by bolding it and its parent patcher
                        font = self.gConfigPanel.GetFont()
                        font.SetWeight(wx.FONTWEIGHT_BOLD)
                        self.gList.SetItemFont(index, font)
                        patcherBold = True
                self.gList.Check(index,self.configChecks.setdefault(item,effectiveDefaultItemCheck))
        self.configItems = items
        if patcherOn:
            self._EnsurePatcherEnabled()
        if patcherBold:
            self._BoldPatcherLabel()

    def OnListCheck(self,event=None):
        """One of list items was checked. Update all configChecks states."""
        ensureEnabled = False
        for index,item in enumerate(self.items):
            checked = self.gList.IsChecked(index)
            self.configChecks[item] = checked
            if checked:
                ensureEnabled = True
        if event is not None:
            if self.gList.IsChecked(event.GetSelection()):
                self._EnsurePatcherEnabled()
        elif ensureEnabled:
            self._EnsurePatcherEnabled()

    def OnAutomatic(self,event=None):
        """Automatic checkbox changed."""
        self.autoIsChecked = self.gAuto.IsChecked()
        self.gAdd.Enable(not self.autoIsChecked)
        self.gRemove.Enable(not self.autoIsChecked)
        if self.autoIsChecked:
            self.SetItems(self.getAutoItems())

    def OnAdd(self,event):
        """Add button clicked."""
        srcDir = bosh.modInfos.dir
        wildcard = bush.game.name+_(u' Mod Files')+u' (*.esp;*.esm)|*.esp;*.esm'
        #--File dialog
        title = _(u'Get ')+self.__class__.listLabel
        srcPaths = balt.askOpenMulti(self.gConfigPanel,title,srcDir, u'', wildcard)
        if not srcPaths: return
        #--Get new items
        for srcPath in srcPaths:
            dir,name = srcPath.headTail
            if dir == srcDir and name not in self.configItems:
                self.configItems.append(name)
        self.SetItems(self.configItems)

    def OnRemove(self,event):
        """Remove button clicked."""
        selected = self.gList.GetSelections()
        newItems = [item for index,item in enumerate(self.configItems) if index not in selected]
        self.SetItems(newItems)

    #--Choice stuff ---------------------------------------
    def OnMouse(self,event):
        """Check mouse motion to detect right click event."""
        if event.RightDown():
            self.mouseState = (event.m_x,event.m_y)
            event.Skip()
        elif event.RightUp() and self.mouseState:
            self.ShowChoiceMenu(event)
        elif event.Dragging():
            if self.mouseState:
                oldx,oldy = self.mouseState
                if max(abs(event.m_x-oldx),abs(event.m_y-oldy)) > 4:
                    self.mouseState = None
        else:
            self.mouseState = False
            event.Skip()

    def ShowChoiceMenu(self,event):
        """Displays a popup choice menu if applicable.
        NOTE: Assume that configChoice returns a set of chosen items."""
        if not self.choiceMenu: return
        #--Item Index
        if self.forceItemCheck:
            itemHeight = self.gList.GetCharHeight()
        else:
            itemHeight = self.gList.GetItemHeight()
        itemIndex = event.m_y/itemHeight + self.gList.GetScrollPos(wx.VERTICAL)
        if itemIndex >= len(self.items): return
        self.gList.SetSelection(itemIndex)
        self.rightClickItemIndex = itemIndex
        choiceSet = self.getChoice(self.items[itemIndex])
        #--Build Menu
        menu = wx.Menu()
        for index,label in enumerate(self.choiceMenu):
            if label == u'----':
                menu.AppendSeparator()
            else:
                menuItem = wx.MenuItem(menu,index,label,kind=wx.ITEM_CHECK)
                menu.AppendItem(menuItem)
                if label in choiceSet: menuItem.Check()
                wx.EVT_MENU(self.gList,index,self.OnItemChoice)
        #--Show/Destroy Menu
        self.gList.PopupMenu(menu)
        menu.Destroy()

    def OnItemChoice(self,event):
        """Handle choice menu selection."""
        itemIndex = self.rightClickItemIndex
        item =self.items[itemIndex]
        choice = self.choiceMenu[event.GetId()]
        choiceSet = self.configChoices[item]
        choiceSet ^= set((choice,))
        if choice != u'Auto':
            choiceSet.discard(u'Auto')
        elif u'Auto' in self.configChoices[item]:
            self.getChoice(item)
        self.gList.SetString(itemIndex,self.getItemLabel(item))

    def SelectAll(self,event=None):
        """'Select All' Button was pressed, update all configChecks states."""
        try:
            for index, item in enumerate(self.items):
                self.gList.Check(index,True)
            self.OnListCheck()
        except AttributeError:
            pass #ListBox instead of CheckListBox
        self.gConfigPanel.GetParent().gPatchers.SetFocusFromKbd()

    def DeselectAll(self,event=None):
        """'Deselect All' Button was pressed, update all configChecks states."""
        try:
            self.gList.SetChecked([])
            self.OnListCheck()
        except AttributeError:
            pass #ListBox instead of CheckListBox
        self.gConfigPanel.GetParent().gPatchers.SetFocusFromKbd()
#------------------------------------------------------------------------------
class TweakPatcher(Patcher):
    """Patcher panel with list of checkable, configurable tweaks."""
    listLabel = _(u"Tweaks")

    def GetConfigPanel(self,parent,gConfigSizer,gTipText):
        """Show config."""
        if self.gConfigPanel: return self.gConfigPanel
        #--Else...
        self.gTipText = gTipText
        gConfigPanel = self.gConfigPanel = wx.Window(parent,wx.ID_ANY,style=wx.TAB_TRAVERSAL)
        text = fill(self.__class__.text,70)
        gText = staticText(self.gConfigPanel,text)
        self.gTweakList = wx.CheckListBox(gConfigPanel,wx.ID_ANY)
        #--Events
        self.gTweakList.Bind(wx.EVT_CHECKLISTBOX,self.TweakOnListCheck)
        self.gTweakList.Bind(wx.EVT_MOTION,self.TweakOnMouse)
        self.gTweakList.Bind(wx.EVT_LEAVE_WINDOW,self.TweakOnMouse)
        self.gTweakList.Bind(wx.EVT_RIGHT_DOWN,self.TweakOnMouse)
        self.gTweakList.Bind(wx.EVT_RIGHT_UP,self.TweakOnMouse)
        self.mouseItem = -1
        self.mouseState = None
        if self.selectCommands:
            self.gSelectAll= button(gConfigPanel,_(u'Select All'),onClick=self.TweakSelectAll)
            self.gDeselectAll = button(gConfigPanel,_(u'Deselect All'),onClick=self.TweakDeselectAll)
            gSelectSizer = (vSizer(
                (self.gSelectAll,0,wx.TOP,12),
                (self.gDeselectAll,0,wx.TOP,4),
                ),0,wx.EXPAND|wx.LEFT,4)
        else: gSelectSizer = None
        #--Init GUI
        self.SetTweaks()
        #--Layout
        gSizer = vSizer(
            (gText,),
            (hsbSizer((gConfigPanel,wx.ID_ANY,self.__class__.listLabel),
                ((4,0),0,wx.EXPAND),
                (self.gTweakList,1,wx.EXPAND|wx.TOP,2),
                gSelectSizer,
                ),1,wx.EXPAND|wx.TOP,4),
            )
        gConfigPanel.SetSizer(gSizer)
        gConfigSizer.Add(gConfigPanel,1,wx.EXPAND)
        return gConfigPanel

    def SetTweaks(self):
        """Set item to specified set of items."""
        self.gTweakList.Clear()
        isFirstLoad = self._GetIsFirstLoad()
        patcherBold = False
        for index,tweak in enumerate(self.tweaks):
            label = tweak.getListLabel()
            if tweak.choiceLabels and tweak.choiceLabels[tweak.chosen].startswith(u'Custom'):
                if isinstance(tweak.choiceValues[tweak.chosen][0],basestring):
                    label += u' %s' % tweak.choiceValues[tweak.chosen][0]
                else:
                    label += u' %4.2f ' % tweak.choiceValues[tweak.chosen][0]
            self.gTweakList.Insert(label,index)
            self.gTweakList.Check(index,tweak.isEnabled)
            if not isFirstLoad and tweak.isNew():
                # indicate that this is a new item by bolding it and its parent patcher
                font = self.gConfigPanel.GetFont()
                font.SetWeight(wx.FONTWEIGHT_BOLD)
                self.gTweakList.SetItemFont(index, font)
                patcherBold = True
        if patcherBold:
            self._BoldPatcherLabel()

    def TweakOnListCheck(self,event=None):
        """One of list items was checked. Update all check states."""
        ensureEnabled = False
        for index, tweak in enumerate(self.tweaks):
            checked = self.gTweakList.IsChecked(index)
            tweak.isEnabled = checked
            if checked:
                ensureEnabled = True
        if event is not None:
            if self.gTweakList.IsChecked(event.GetSelection()):
                self._EnsurePatcherEnabled()
        elif ensureEnabled:
            self._EnsurePatcherEnabled()

    def TweakOnMouse(self,event):
        """Check mouse motion to detect right click event."""
        if event.RightDown():
            self.mouseState = (event.m_x,event.m_y)
            event.Skip()
        elif event.RightUp() and self.mouseState:
            self.ShowChoiceMenu(event)
        elif event.Leaving():
            self.gTipText.SetLabel(u'')
            self.mouseState = False
            event.Skip()
        elif event.Dragging():
            if self.mouseState:
                oldx,oldy = self.mouseState
                if max(abs(event.m_x-oldx),abs(event.m_y-oldy)) > 4:
                    self.mouseState = None
        elif event.Moving():
            mouseItem = event.m_y/self.gTweakList.GetItemHeight() + self.gTweakList.GetScrollPos(wx.VERTICAL)
            self.mouseState = False
            if mouseItem != self.mouseItem:
                self.mouseItem = mouseItem
                self.MouseEnteredItem(mouseItem)
            event.Skip()
        else:
            self.mouseState = False
            event.Skip()

    def MouseEnteredItem(self,item):
        """Show tip text when changing item."""
        #--Following isn't displaying correctly.
        tip = item < len(self.tweaks) and self.tweaks[item].tip
        if tip:
            self.gTipText.SetLabel(tip)
        else:
            self.gTipText.SetLabel(u'')

    def ShowChoiceMenu(self,event):
        """Displays a popup choice menu if applicable."""
        #--Tweak Index
        tweakIndex = event.m_y/self.gTweakList.GetItemHeight() + self.gTweakList.GetScrollPos(wx.VERTICAL)
        self.rightClickTweakIndex = tweakIndex
        #--Tweaks
        tweaks = self.tweaks
        if tweakIndex >= len(tweaks): return
        choiceLabels = tweaks[tweakIndex].choiceLabels
        if len(choiceLabels) <= 1: return
        chosen = tweaks[tweakIndex].chosen
        self.gTweakList.SetSelection(tweakIndex)
        #--Build Menu
        menu = wx.Menu()
        for index,label in enumerate(choiceLabels):
            if label == u'----':
                menu.AppendSeparator()
            elif label.startswith(_(u'Custom')):
                if isinstance(tweaks[tweakIndex].choiceValues[index][0],basestring):
                    menulabel = label + u' %s' % tweaks[tweakIndex].choiceValues[index][0]
                else:
                    menulabel = label + u' %4.2f ' % tweaks[tweakIndex].choiceValues[index][0]
                menuItem = wx.MenuItem(menu,index,menulabel,kind=wx.ITEM_CHECK)
                menu.AppendItem(menuItem)
                if index == chosen: menuItem.Check()
                wx.EVT_MENU(self.gTweakList,index,self.OnTweakCustomChoice)
            else:
                menuItem = wx.MenuItem(menu,index,label,kind=wx.ITEM_CHECK)
                menu.AppendItem(menuItem)
                if index == chosen: menuItem.Check()
                wx.EVT_MENU(self.gTweakList,index,self.OnTweakChoice)
        #--Show/Destroy Menu
        self.gTweakList.PopupMenu(menu)
        menu.Destroy()

    def OnTweakChoice(self,event):
        """Handle choice menu selection."""
        tweakIndex = self.rightClickTweakIndex
        self.tweaks[tweakIndex].chosen = event.GetId()
        self.gTweakList.SetString(tweakIndex,self.tweaks[tweakIndex].getListLabel())

    def OnTweakCustomChoice(self,event):
        """Handle choice menu selection."""
        tweakIndex = self.rightClickTweakIndex
        index = event.GetId()
        tweak = self.tweaks[tweakIndex]
        value = []
        for i, v in enumerate(tweak.choiceValues[index]):
            if isinstance(v,float):
                label = (_(u'Enter the desired custom tweak value.')
                         + u'\n' +
                         _(u'Due to an inability to get decimal numbers from the wxPython prompt please enter an extra zero after your choice if it is not meant to be a decimal.')
                         + u'\n' +
                         _(u'If you are trying to enter a decimal multiply it by 10, for example for 0.3 enter 3 instead.')
                         + u'\n' + tweak.key[i])
                new = balt.askNumber(self.gConfigPanel,label,prompt=_(u'Value'),
                    title=tweak.label+_(u' ~ Custom Tweak Value'),value=self.tweaks[tweakIndex].choiceValues[index][i],min=-10000,max=10000)
                if new == None: #user hit cancel
                    return
                value.append(float(new)/10)
            elif isinstance(v,int):
                label = _(u'Enter the desired custom tweak value.')+u'\n'+tweak.key[i]
                new = balt.askNumber(self.gConfigPanel,label,prompt=_(u'Value'),
                    title=tweak.label+_(u' ~ Custom Tweak Value'),value=self.tweaks[tweakIndex].choiceValues[index][i],min=-10000,max=10000)
                if new == None: #user hit cancel
                    return
                value.append(new)
            elif isinstance(v,basestring):
                label = _(u'Enter the desired custom tweak text.')+u'\n'+tweak.key[i]
                new = balt.askText(self.gConfigPanel,label,
                    title=tweak.label+_(u' ~ Custom Tweak Text'),default=self.tweaks[tweakIndex].choiceValues[index][i])
                if new == None: #user hit cancel
                    return
                value.append(new)
        if not value: value = tweak.choiceValues[index]
        tweak.choiceValues[index] = tuple(value)
        tweak.chosen = index
        if isinstance(tweak.choiceValues[index][0],basestring):
            menulabel = tweak.getListLabel() + u' %s' % tweak.choiceValues[index][0]
        else:
            menulabel = tweak.getListLabel() + u' %4.2f ' % tweak.choiceValues[index][0]
        self.gTweakList.SetString(tweakIndex,(menulabel))

    def TweakSelectAll(self,event=None):
        """'Select All' Button was pressed, update all configChecks states."""
        try:
            for index, item in enumerate(self.tweaks):
                self.gTweakList.Check(index,True)
            self.OnListCheck()
        except AttributeError:
            pass #ListBox instead of CheckListBox
        self.gConfigPanel.GetParent().gPatchers.SetFocusFromKbd()

    def TweakDeselectAll(self,event=None):
        """'Deselect All' Button was pressed, update all configChecks states."""
        try:
            self.gTweakList.SetChecked([])
            self.OnListCheck()
        except AttributeError:
            pass #ListBox instead of CheckListBox
        self.gConfigPanel.GetParent().gPatchers.SetFocusFromKbd()

#------------------------------------------------------------------------------
class DoublePatcher(TweakPatcher,ListPatcher):
    """Patcher panel with option to select source elements."""
    listLabel = _(u'Source Mods/Files')

    def GetConfigPanel(self,parent,gConfigSizer,gTipText):
        """Show config."""
        if self.gConfigPanel: return self.gConfigPanel
        #--Else...
        self.gTipText = gTipText
        gConfigPanel = self.gConfigPanel = wx.Window(parent,wx.ID_ANY)
        text = fill(self.text,70)
        gText = staticText(self.gConfigPanel,text)
        #--Import List
        self.gList = wx.CheckListBox(gConfigPanel,wx.ID_ANY)
        self.gList.Bind(wx.EVT_MOTION,self.OnMouse)
        self.gList.Bind(wx.EVT_RIGHT_DOWN,self.OnMouse)
        self.gList.Bind(wx.EVT_RIGHT_UP,self.OnMouse)
        #--Tweak List
        self.gTweakList = wx.CheckListBox(gConfigPanel,wx.ID_ANY)
        self.gTweakList.Bind(wx.EVT_CHECKLISTBOX,self.TweakOnListCheck)
        self.gTweakList.Bind(wx.EVT_MOTION,self.TweakOnMouse)
        self.gTweakList.Bind(wx.EVT_LEAVE_WINDOW,self.TweakOnMouse)
        self.gTweakList.Bind(wx.EVT_RIGHT_DOWN,self.TweakOnMouse)
        self.gTweakList.Bind(wx.EVT_RIGHT_UP,self.TweakOnMouse)
        self.mouseItem = -1
        self.mouseState = None
        #--Buttons
        self.gSelectAll = button(gConfigPanel,_(u'Select All'),onClick=self.SelectAll)
        self.gDeselectAll = button(gConfigPanel,_(u'Deselect All'),onClick=self.DeselectAll)
        gSelectSizer = (vSizer(
            (self.gSelectAll,0,wx.TOP,12),
            (self.gDeselectAll,0,wx.TOP,4),
            ),0,wx.EXPAND|wx.LEFT,4)
        self.gTweakSelectAll = button(gConfigPanel,_(u'Select All'),onClick=self.TweakSelectAll)
        self.gTweakDeselectAll = button(gConfigPanel,_(u'Deselect All'),onClick=self.TweakDeselectAll)
        gTweakSelectSizer = (vSizer(
            (self.gTweakSelectAll,0,wx.TOP,12),
            (self.gTweakDeselectAll,0,wx.TOP,4),
            ),0,wx.EXPAND|wx.LEFT,4)
        #--Layout
        gSizer = vSizer(
            (gText,),
            (hsbSizer((gConfigPanel,wx.ID_ANY,self.__class__.listLabel),
                ((4,0),0,wx.EXPAND),
                (self.gList,1,wx.EXPAND|wx.TOP,2),
                gSelectSizer,),1,wx.EXPAND|wx.TOP,4),
            (hsbSizer((gConfigPanel,wx.ID_ANY,self.__class__.subLabel),
                ((4,0),0,wx.EXPAND),
                (self.gTweakList,1,wx.EXPAND|wx.TOP,2),
                gTweakSelectSizer,),1,wx.EXPAND|wx.TOP,4),
            )
        gConfigPanel.SetSizer(gSizer)
        gConfigSizer.Add(gConfigPanel,1,wx.EXPAND)
        #--Initialize
        self.SetItems(self.getAutoItems())
        self.SetTweaks()
        return gConfigPanel

#------------------------------------------------------------------------------
# Patchers 10 ------------------------------------------------------------------
class PatchMerger(bosh.PatchMerger,ListPatcher):
    listLabel = _(u'Mergeable Mods')
class CBash_PatchMerger(bosh.CBash_PatchMerger,ListPatcher):
    listLabel = _(u'Mergeable Mods')
# Patchers 20 ------------------------------------------------------------------
class GraphicsPatcher(bosh.GraphicsPatcher,ListPatcher): pass
class CBash_GraphicsPatcher(bosh.CBash_GraphicsPatcher,ListPatcher): pass

class KFFZPatcher(bosh.KFFZPatcher,ListPatcher): pass
class CBash_KFFZPatcher(bosh.CBash_KFFZPatcher,ListPatcher): pass

class NPCAIPackagePatcher(bosh.NPCAIPackagePatcher,ListPatcher): pass
class CBash_NPCAIPackagePatcher(bosh.CBash_NPCAIPackagePatcher,ListPatcher): pass

class ActorImporter(bosh.ActorImporter,ListPatcher): pass
class CBash_ActorImporter(bosh.CBash_ActorImporter,ListPatcher): pass

class DeathItemPatcher(bosh.DeathItemPatcher,ListPatcher): pass
class CBash_DeathItemPatcher(bosh.CBash_DeathItemPatcher,ListPatcher): pass

class CellImporter(bosh.CellImporter,ListPatcher): pass
class CBash_CellImporter(bosh.CBash_CellImporter,ListPatcher): pass

class ImportFactions(bosh.ImportFactions,ListPatcher): pass
class CBash_ImportFactions(bosh.CBash_ImportFactions,ListPatcher): pass

class ImportRelations(bosh.ImportRelations,ListPatcher): pass
class CBash_ImportRelations(bosh.CBash_ImportRelations,ListPatcher): pass

class ImportInventory(bosh.ImportInventory,ListPatcher): pass
class CBash_ImportInventory(bosh.CBash_ImportInventory,ListPatcher): pass

class ImportActorsSpells(bosh.ImportActorsSpells,ListPatcher): pass
class CBash_ImportActorsSpells(bosh.CBash_ImportActorsSpells,ListPatcher): pass

class NamesPatcher(bosh.NamesPatcher,ListPatcher): pass
class CBash_NamesPatcher(bosh.CBash_NamesPatcher,ListPatcher): pass

class NpcFacePatcher(bosh.NpcFacePatcher,ListPatcher): pass
class CBash_NpcFacePatcher(bosh.CBash_NpcFacePatcher,ListPatcher): pass

class RacePatcher(bosh.RacePatcher,DoublePatcher):
    listLabel = _(u'Race Mods')
class CBash_RacePatcher(bosh.CBash_RacePatcher,DoublePatcher):
    listLabel = _(u'Race Mods')

class RoadImporter(bosh.RoadImporter,ListPatcher): pass
class CBash_RoadImporter(bosh.CBash_RoadImporter,ListPatcher): pass

class SoundPatcher(bosh.SoundPatcher,ListPatcher): pass
class CBash_SoundPatcher(bosh.CBash_SoundPatcher,ListPatcher): pass

class StatsPatcher(bosh.StatsPatcher,ListPatcher): pass
class CBash_StatsPatcher(bosh.CBash_StatsPatcher,ListPatcher): pass

class ImportScripts(bosh.ImportScripts,ListPatcher):pass
class CBash_ImportScripts(bosh.CBash_ImportScripts,ListPatcher):pass

class SpellsPatcher(bosh.SpellsPatcher,ListPatcher):pass
class CBash_SpellsPatcher(bosh.CBash_SpellsPatcher,ListPatcher):pass

# Patchers 30 ------------------------------------------------------------------
class AssortedTweaker(bosh.AssortedTweaker,TweakPatcher): pass
class CBash_AssortedTweaker(bosh.CBash_AssortedTweaker,TweakPatcher): pass

class ClothesTweaker(bosh.ClothesTweaker,TweakPatcher): pass
class CBash_ClothesTweaker(bosh.CBash_ClothesTweaker,TweakPatcher): pass

class GmstTweaker(bosh.GmstTweaker,TweakPatcher): pass
class CBash_GmstTweaker(bosh.CBash_GmstTweaker,TweakPatcher): pass

class NamesTweaker(bosh.NamesTweaker,TweakPatcher): pass
class CBash_NamesTweaker(bosh.CBash_NamesTweaker,TweakPatcher): pass

class TweakActors(bosh.TweakActors,TweakPatcher): pass
class CBash_TweakActors(bosh.CBash_TweakActors,TweakPatcher): pass

# Patchers 40 ------------------------------------------------------------------
class AlchemicalCatalogs(bosh.AlchemicalCatalogs,Patcher): pass
class CBash_AlchemicalCatalogs(bosh.CBash_AlchemicalCatalogs,Patcher): pass

class CoblExhaustion(bosh.CoblExhaustion,ListPatcher): pass
class CBash_CoblExhaustion(bosh.CBash_CoblExhaustion,ListPatcher): pass

class UpdateReferences(bosh.UpdateReferences,ListPatcher): pass
class CBash_UpdateReferences(bosh.CBash_UpdateReferences,ListPatcher): pass

class ListsMerger(bosh.ListsMerger,ListPatcher):
    listLabel = _(u'Override Delev/Relev Tags')
class CBash_ListsMerger(bosh.CBash_ListsMerger,ListPatcher):
    listLabel = _(u'Override Delev/Relev Tags')

class MFactMarker(bosh.MFactMarker,ListPatcher): pass
class CBash_MFactMarker(bosh.CBash_MFactMarker,ListPatcher): pass

class SEWorldEnforcer(bosh.SEWorldEnforcer,Patcher): pass
class CBash_SEWorldEnforcer(bosh.CBash_SEWorldEnforcer,Patcher): pass

class ContentsChecker(bosh.ContentsChecker,Patcher): pass
class CBash_ContentsChecker(bosh.CBash_ContentsChecker,Patcher): pass
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
# Init Patchers
def initPatchers():
    PatchDialog.patchers.extend((
        globals()[x]() for x in bush.game.patchers
        ))
    PatchDialog.CBash_patchers.extend((
        globals()[x]() for x in bush.game.CBash_patchers
        ))

otherPatcherDict = {
    AliasesPatcher().__class__.__name__ : CBash_AliasesPatcher(),
    AssortedTweaker().__class__.__name__ : CBash_AssortedTweaker(),
    PatchMerger().__class__.__name__ : CBash_PatchMerger(),
    AlchemicalCatalogs().__class__.__name__ : CBash_AlchemicalCatalogs(),
    KFFZPatcher().__class__.__name__ : CBash_KFFZPatcher(),
    ActorImporter().__class__.__name__ : CBash_ActorImporter(),
    DeathItemPatcher().__class__.__name__ : CBash_DeathItemPatcher(),
    NPCAIPackagePatcher().__class__.__name__ : CBash_NPCAIPackagePatcher(),
    CoblExhaustion().__class__.__name__ : CBash_CoblExhaustion(),
    UpdateReferences().__class__.__name__ : CBash_UpdateReferences(),
    CellImporter().__class__.__name__ : CBash_CellImporter(),
    ClothesTweaker().__class__.__name__ : CBash_ClothesTweaker(),
    GmstTweaker().__class__.__name__ : CBash_GmstTweaker(),
    GraphicsPatcher().__class__.__name__ : CBash_GraphicsPatcher(),
    ImportFactions().__class__.__name__ : CBash_ImportFactions(),
    ImportInventory().__class__.__name__ : CBash_ImportInventory(),
    SpellsPatcher().__class__.__name__ : CBash_SpellsPatcher(),
    TweakActors().__class__.__name__ : CBash_TweakActors(),
    ImportRelations().__class__.__name__ : CBash_ImportRelations(),
    ImportScripts().__class__.__name__ : CBash_ImportScripts(),
    ImportActorsSpells().__class__.__name__ : CBash_ImportActorsSpells(),
    ListsMerger().__class__.__name__ : CBash_ListsMerger(),
    MFactMarker().__class__.__name__ : CBash_MFactMarker(),
    NamesPatcher().__class__.__name__ : CBash_NamesPatcher(),
    NamesTweaker().__class__.__name__ : CBash_NamesTweaker(),
    NpcFacePatcher().__class__.__name__ : CBash_NpcFacePatcher(),
    RacePatcher().__class__.__name__ : CBash_RacePatcher(),
    RoadImporter().__class__.__name__ : CBash_RoadImporter(),
    SoundPatcher().__class__.__name__ : CBash_SoundPatcher(),
    StatsPatcher().__class__.__name__ : CBash_StatsPatcher(),
    SEWorldEnforcer().__class__.__name__ : CBash_SEWorldEnforcer(),
    ContentsChecker().__class__.__name__ : CBash_ContentsChecker(),
    CBash_AliasesPatcher().__class__.__name__ : AliasesPatcher(),
    CBash_AssortedTweaker().__class__.__name__ : AssortedTweaker(),
    CBash_PatchMerger().__class__.__name__ : PatchMerger(),
    CBash_AlchemicalCatalogs().__class__.__name__ : AlchemicalCatalogs(),
    CBash_KFFZPatcher().__class__.__name__ : KFFZPatcher(),
    CBash_ActorImporter().__class__.__name__ : ActorImporter(),
    CBash_DeathItemPatcher().__class__.__name__ : DeathItemPatcher(),
    CBash_NPCAIPackagePatcher().__class__.__name__ : NPCAIPackagePatcher(),
    CBash_CoblExhaustion().__class__.__name__ : CoblExhaustion(),
    CBash_UpdateReferences().__class__.__name__ : UpdateReferences(),
    CBash_CellImporter().__class__.__name__ : CellImporter(),
    CBash_ClothesTweaker().__class__.__name__ : ClothesTweaker(),
    CBash_GmstTweaker().__class__.__name__ : GmstTweaker(),
    CBash_GraphicsPatcher().__class__.__name__ : GraphicsPatcher(),
    CBash_ImportFactions().__class__.__name__ : ImportFactions(),
    CBash_ImportInventory().__class__.__name__ : ImportInventory(),
    CBash_SpellsPatcher().__class__.__name__ : SpellsPatcher(),
    CBash_TweakActors().__class__.__name__ : TweakActors(),
    CBash_ImportRelations().__class__.__name__ : ImportRelations(),
    CBash_ImportScripts().__class__.__name__ : ImportScripts(),
    CBash_ImportActorsSpells().__class__.__name__ : ImportActorsSpells(),
    CBash_ListsMerger().__class__.__name__ : ListsMerger(),
    CBash_MFactMarker().__class__.__name__ : MFactMarker(),
    CBash_NamesPatcher().__class__.__name__ : NamesPatcher(),
    CBash_NamesTweaker().__class__.__name__ : NamesTweaker(),
    CBash_NpcFacePatcher().__class__.__name__ : NpcFacePatcher(),
    CBash_RacePatcher().__class__.__name__ : RacePatcher(),
    CBash_RoadImporter().__class__.__name__ : RoadImporter(),
    CBash_SoundPatcher().__class__.__name__ : SoundPatcher(),
    CBash_StatsPatcher().__class__.__name__ : StatsPatcher(),
    CBash_SEWorldEnforcer().__class__.__name__ : SEWorldEnforcer(),
    CBash_ContentsChecker().__class__.__name__ : ContentsChecker(),
    }
# Files Links -----------------------------------------------------------------
#------------------------------------------------------------------------------
class BoolLink(Link):
    """Simple link that just toggles a setting."""
    def __init__(self, text, key, help=''):
        Link.__init__(self)
        self.text = text
        self.help = help
        self.key = key

    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,self.text,self.help,kind=wx.ITEM_CHECK)
        menu.AppendItem(menuItem)
        menuItem.Check(settings[self.key])

    def Execute(self,event):
        settings[self.key] ^= True


#------------------------------------------------------------------------------
class Files_Open(Link):
    """Opens data directory in explorer."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Open...'), _(u"Open '%s'") % (window.data.dir.tail))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        """Handle selection."""
        dir = self.window.data.dir
        dir.makedirs()
        dir.start()

#------------------------------------------------------------------------------
class Files_SortBy(Link):
    """Sort files by specified key (sortCol)."""
    def __init__(self,sortCol,prefix=''):
        Link.__init__(self)
        self.sortCol = sortCol
        self.sortName = settings['bash.colNames'][sortCol]
        self.prefix = prefix

    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,self.prefix+self.sortName,_(u'Sort by %s') % (self.sortName),kind=wx.ITEM_RADIO)
        menu.AppendItem(menuItem)
        if window.sort == self.sortCol: menuItem.Check()

    def Execute(self,event):
        if hasattr(self, 'gTank'):
            self.gTank.SortItems(self.sortCol,'INVERT')
        else:
            self.window.PopulateItems(self.sortCol,-1)

#------------------------------------------------------------------------------
class Files_Unhide(Link):
    """Unhide file(s). (Move files back to Data Files or Save directory.)"""
    def __init__(self,type):
        Link.__init__(self)
        self.type = type

    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u"Unhide..."), _(u"Unhides hidden %ss.") % self.type)
        menu.AppendItem(menuItem)

    def Execute(self,event):
        srcDir = bosh.dirs['modsBash'].join(u'Hidden')
        if self.type == 'mod':
            wildcard = bush.game.name+u' '+_(u'Mod Files')+u' (*.esp;*.esm)|*.esp;*.esm'
            destDir = self.window.data.dir
        elif self.type == 'save':
            wildcard = bush.game.name+u' '+_(u'Save files')+u' (*.ess)|*.ess'
            srcDir = self.window.data.bashDir.join(u'Hidden')
            destDir = self.window.data.dir
        elif self.type == 'installer':
            window = self.gTank
            wildcard = bush.game.name+u' '+_(u'Mod Archives')+u' (*.7z;*.zip;*.rar)|*.7z;*.zip;*.rar'
            destDir = bosh.dirs['installers']
            srcPaths = balt.askOpenMulti(window,_(u'Unhide files:'),srcDir, u'.Folder Selection.', wildcard)
        else:
            wildcard = u'*.*'
        isSave = (destDir == bosh.saveInfos.dir)
        #--File dialog
        srcDir.makedirs()
        if not self.type == 'installer':
            window = self.window
            srcPaths = balt.askOpenMulti(window,_(u'Unhide files:'),srcDir, u'', wildcard)
        if not srcPaths: return
        #--Iterate over Paths
        for srcPath in srcPaths:
            #--Copy from dest directory?
            (newSrcDir,srcFileName) = srcPath.headTail
            if newSrcDir == destDir:
                balt.showError(window,_(u"You can't unhide files from this directory."))
                return
            #--Folder selection?
            if srcFileName.csbody == u'.folder selection':
                if newSrcDir == srcDir:
                    #--Folder selection on the 'Hidden' folder
                    return
                (newSrcDir,srcFileName) = newSrcDir.headTail
                srcPath = srcPath.head
            #--File already unhidden?
            destPath = destDir.join(srcFileName)
            if destPath.exists():
                balt.showWarning(window,_(u"File skipped: %s. File is already present.")
                    % (srcFileName.s,))
            #--Move it?
            else:
                srcPath.moveTo(destPath)
                if isSave:
                    bosh.CoSaves(srcPath).move(destPath)
        #--Repopulate
        bashFrame.RefreshData()

# File Links ------------------------------------------------------------------
#------------------------------------------------------------------------------
class File_Delete(Link):
    """Delete the file and all backups."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menu.AppendItem(wx.MenuItem(menu,self.id,_(u'Delete'),
                help=_(u"Delete %(filename)s.") % ({'filename':data[0]})))

    def Execute(self,event):
        message = [u'',_(u'Uncheck files to skip deleting them if desired.')]
        message.extend(sorted(self.data))
        dialog = ListBoxes(self.window,_(u'Delete Files'),
                     _(u'Delete these files? This operation cannot be undone.'),
                     [message])
        if dialog.ShowModal() != wx.ID_CANCEL:
            id = dialog.ids[message[0]]
            checks = dialog.FindWindowById(id)
            if checks:
                for i,mod in enumerate(self.data):
                    if checks.IsChecked(i):
                        self.window.data.delete(mod)
            self.window.RefreshUI()
        dialog.Destroy()

#------------------------------------------------------------------------------
class File_Duplicate(Link):
    """Create a duplicate of the file."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        self.title = (_(u'Duplicate'),_(u'Duplicate...'))[len(data) == 1]
        menuItem = wx.MenuItem(menu,self.id,self.title, _(u"Make a copy of '%s'") % (data[0]))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        data = self.data
        for item in data:
            fileName = GPath(item)
            fileInfos = self.window.data
            fileInfo = fileInfos[fileName]
            #--Mod with resources?
            #--Warn on rename if file has bsa and/or dialog
            if fileInfo.isMod() and tuple(fileInfo.hasResources()) != (False,False):
                hasBsa, hasVoices = fileInfo.hasResources()
                modName = fileInfo.name
                if hasBsa and hasVoices:
                    message = (_(u"This mod has an associated archive (%s.bsa) and an associated voice directory (Sound\\Voices\\%s), which will not be attached to the duplicate mod.")
                               + u'\n\n' +
                               _(u'Note that the BSA archive may also contain a voice directory (Sound\\Voices\\%s), which would remain detached even if a duplicate archive were also created.')
                               ) % (modName.sroot,modName.s,modName.s)
                elif hasBsa:
                    message = (_(u'This mod has an associated archive (%s.bsa), which will not be attached to the duplicate mod.')
                               + u'\n\n' +
                               _(u'Note that this BSA archive may contain a voice directory (Sound\\Voices\\%s), which would remain detached even if a duplicate archive were also created.')
                               ) % (modName.sroot,modName.s)
                else: #hasVoices
                    message = _(u'This mod has an associated voice directory (Sound\\Voice\\%s), which will not be attached to the duplicate mod.') % modName.s
                if not balt.askWarning(self.window,message,_(u'Duplicate ')+fileName.s):
                    continue
            #--Continue copy
            (root,ext) = fileName.rootExt
            if ext.lower() == u'.bak': ext = u'.ess'
            (destDir,wildcard) = (fileInfo.dir, u'*'+ext)
            destName = GPath(root+u' Copy'+ext)
            destPath = destDir.join(destName)
            count = 0
            while destPath.exists() and count < 1000:
                count += 1
                destName = GPath(root + u' Copy %d'  % count + ext)
                destPath = destDir.join(destName)
            destName = destName.s
            destDir.makedirs()
            if len(data) == 1:
                destPath = balt.askSave(self.window,_(u'Duplicate as:'), destDir,destName,wildcard)
                if not destPath: return
                destDir,destName = destPath.headTail
            if (destDir == fileInfo.dir) and (destName == fileName):
                balt.showError(self.window,_(u"Files cannot be duplicated to themselves!"))
                continue
            if(fileInfo.isMod()):
                newTime = bosh.modInfos.getFreeTime(fileInfo.getPath().mtime)
            else:
                newTime = '+1'
            fileInfos.copy(fileName,destDir,destName,mtime=newTime)
            if destDir == fileInfo.dir:
                fileInfos.table.copyRow(fileName,destName)
                if fileInfos.table.getItem(fileName,'mtime'):
                    fileInfos.table.setItem(destName,'mtime',newTime)
                if fileInfo.isMod():
                    fileInfos.autoSort()
            self.window.RefreshUI()

#------------------------------------------------------------------------------
class File_Hide(Link):
    """Hide the file. (Move it to Bash/Hidden directory.)"""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menu.AppendItem(wx.MenuItem(menu,self.id,_(u'Hide'),
                help=_(u"Move %(filename)s to the Bash/Hidden directory.") % ({'filename':data[0]})))

    def Execute(self,event):
        if not bosh.inisettings['SkipHideConfirmation']:
            message = _(u'Hide these files? Note that hidden files are simply moved to the Bash\\Hidden subdirectory.')
            if not balt.askYes(self.window,message,_(u'Hide Files')): return
        #--Do it
        destRoot = self.window.data.bashDir.join(u'Hidden')
        fileInfos = self.window.data
        fileGroups = fileInfos.table.getColumn('group')
        for fileName in self.data:
            destDir = destRoot
            #--Use author subdirectory instead?
            author = getattr(fileInfos[fileName].header,'author',u'NOAUTHOR') #--Hack for save files.
            authorDir = destRoot.join(author)
            if author and authorDir.isdir():
                destDir = authorDir
            #--Use group subdirectory instead?
            elif fileName in fileGroups:
                groupDir = destRoot.join(fileGroups[fileName])
                if groupDir.isdir():
                    destDir = groupDir
            if not self.window.data.moveIsSafe(fileName,destDir):
                message = (_(u'A file named %s already exists in the hidden files directory. Overwrite it?')
                    % fileName.s)
                if not balt.askYes(self.window,message,_(u'Hide Files')): continue
            #--Do it
            self.window.data.move(fileName,destDir,False)
        #--Refresh stuff
        bashFrame.RefreshData()

#------------------------------------------------------------------------------
class File_ListMasters(Link):
    """Copies list of masters to clipboard."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u"List Masters..."),
                help=_(u"Copies list of %(filename)s's masters to the clipboard.") % ({'filename':data[0]}))
        menu.AppendItem(menuItem)
        if len(data) != 1: menuItem.Enable(False)

    def Execute(self,event):
        fileName = GPath(self.data[0])
        fileInfo = self.window.data[fileName]
        text = bosh.modInfos.getModList(fileInfo=fileInfo)
        if (wx.TheClipboard.Open()):
            wx.TheClipboard.SetData(wx.TextDataObject(text))
            wx.TheClipboard.Close()
        balt.showLog(self.window,text,fileName.s,asDialog=False,fixedFont=False,icons=bashBlue)

#------------------------------------------------------------------------------
class File_Redate(Link):
    """Move the selected files to start at a specified date."""
    def AppendToMenu(self,menu,window,data):
        if bosh.boss.LoadOrderMethod == bosh.bapi.BOSS_API_LOMETHOD_TEXTFILE:
            return
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Redate...'),
                help=_(u"Move the selected files to start at a specified date."))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        #--Get current start time.
        modInfos = self.window.data
        fileNames = [mod for mod in self.data if mod not in modInfos.autoSorted]
        if not fileNames: return
        #--Ask user for revised time.
        newTimeStr = balt.askText(self.window,_(u'Redate selected mods starting at...'),
            _(u'Redate Mods'),formatDate(int(time.time())))
        if not newTimeStr: return
        try:
            newTimeTup = bosh.unformatDate(newTimeStr,u'%c')
            newTime = int(time.mktime(newTimeTup))
        except ValueError:
            balt.showError(self.window,_(u'Unrecognized date: ')+newTimeStr)
            return
        except OverflowError:
            balt.showError(self,_(u'Bash cannot handle dates greater than January 19, 2038.)'))
            return
        #--Do it
        selInfos = [modInfos[fileName] for fileName in fileNames]
        selInfos.sort(key=attrgetter('mtime'))
        for fileInfo in selInfos:
            fileInfo.setmtime(newTime)
            newTime += 60
        #--Refresh
        modInfos.refresh(doInfos=False)
        modInfos.refreshInfoLists()
        self.window.RefreshUI()

#------------------------------------------------------------------------------
class File_Sort(Link):
    """Sort the selected files."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Sort'),
                help=_(u"sort the selected files."))
        menu.AppendItem(menuItem)
        if len(data) < 2: menuItem.Enable(False)

    def Execute(self,event):
        message = (_(u'Reorder selected mods in alphabetical order?  The first file will be given the date/time of the current earliest file in the group, with consecutive files following at 1 minute increments.')
                   + u'\n\n' +
                   _(u'Note that this operation cannot be undone.  Note also that some mods need to be in a specific order to work correctly, and this sort operation may break that order.')
                   )
        if not balt.askContinue(self.window,message,'bash.sortMods.continue',_(u'Sort Mods')):
            return
        #--Get first time from first selected file.
        modInfos = self.window.data
        fileNames = [mod for mod in self.data if mod not in modInfos.autoSorted]
        if not fileNames: return
        dotTimes = [modInfos[fileName].mtime for fileName in fileNames if fileName.s[0] in u'.=+']
        if dotTimes:
            newTime = min(dotTimes)
        else:
            newTime = min(modInfos[fileName].mtime for fileName in self.data)
        #--Do it
        fileNames.sort(key=lambda a: a.cext)
        fileNames.sort(key=lambda a: a.s[0] not in u'.=')
        for fileName in fileNames:
            modInfos[fileName].setmtime(newTime)
            newTime += 60
        #--Refresh
        modInfos.refresh(doInfos=False)
        modInfos.refreshInfoLists()
        self.window.RefreshUI()

#------------------------------------------------------------------------------
class File_Snapshot(Link):
    """Take a snapshot of the file."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        self.title = (_(u'Snapshot'),_(u'Snapshot...'))[len(data) == 1]
        menuItem = wx.MenuItem(menu,self.id,self.title,
            help=_(u"Creates a snapshot copy of the current mod in a subdirectory (Bash\Snapshots)."))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        data = self.data
        for item in data:
            fileName = GPath(item)
            fileInfo = self.window.data[fileName]
            (destDir,destName,wildcard) = fileInfo.getNextSnapshot()
            destDir.makedirs()
            if len(data) == 1:
                destPath = balt.askSave(self.window,_(u'Save snapshot as:'),
                    destDir,destName,wildcard)
                if not destPath: return
                (destDir,destName) = destPath.headTail
            #--Extract version number
            fileRoot = fileName.root
            destRoot = destName.root
            fileVersion = bolt.getMatch(re.search(ur'[ _]+v?([\.\d]+)$',fileRoot.s,re.U),1)
            snapVersion = bolt.getMatch(re.search(ur'-[\d\.]+$',destRoot.s,re.U))
            fileHedr = fileInfo.header
            if fileInfo.isMod() and (fileVersion or snapVersion) and bosh.reVersion.search(fileHedr.description):
                if fileVersion and snapVersion:
                    newVersion = fileVersion+snapVersion
                elif snapVersion:
                    newVersion = snapVersion[1:]
                else:
                    newVersion = fileVersion
                newDescription = bosh.reVersion.sub(u'\\1 '+newVersion, fileHedr.description,1,flags=re.U)
                fileInfo.writeDescription(newDescription)
                self.window.details.SetFile(fileName)
            #--Copy file
            self.window.data.copy(fileName,destDir,destName)

#------------------------------------------------------------------------------
class File_RevertToSnapshot(Link):
    """Revert to Snapshot."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Revert to Snapshot...'),
            help=_(u"Revert to a previously created snapshot from the Bash/Snapshots dir."))
        menu.AppendItem(menuItem)
        menuItem.Enable(len(self.data) == 1)

    def Execute(self,event):
        """Handle menu item selection."""
        fileInfo = self.window.data[self.data[0]]
        fileName = fileInfo.name
        #--Snapshot finder
        destDir = self.window.data.dir
        srcDir = self.window.data.bashDir.join(u'Snapshots')
        wildcard = fileInfo.getNextSnapshot()[2]
        #--File dialog
        srcDir.makedirs()
        snapPath = balt.askOpen(self.window,_(u'Revert %s to snapshot:') % fileName.s,
            srcDir, u'', wildcard,mustExist=True)
        if not snapPath: return
        snapName = snapPath.tail
        #--Warning box
        message = (_(u"Revert %s to snapshot %s dated %s?")
            % (fileInfo.name.s, snapName.s, formatDate(snapPath.mtime)))
        if not balt.askYes(self.window,message,_(u'Revert to Snapshot')): return
        with balt.BusyCursor():
            destPath = fileInfo.getPath()
            snapPath.copyTo(destPath)
            fileInfo.setmtime()
            try:
                self.window.data.refreshFile(fileName)
            except bosh.FileError:
                balt.showError(self,_(u'Snapshot file is corrupt!'))
                self.window.details.SetFile(None)
            self.window.RefreshUI(fileName)

#------------------------------------------------------------------------------
class File_Backup(Link):
    """Backup file."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Backup'),
            help=_(u"Create a backup of the slected file(s)."))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        for item in self.data:
            fileInfo = self.window.data[item]
            fileInfo.makeBackup(True)

#------------------------------------------------------------------------------
class File_RevertToBackup:
    """Revert to last or first backup."""
    def AppendToMenu(self,menu,window,data):
        self.window = window
        self.data = data
        #--Backup Files
        singleSelect = len(data) == 1
        self.fileInfo = window.data[data[0]]
        #--Backup Item
        wx.EVT_MENU(window,ID_REVERT_BACKUP,self.Execute)
        menuItem = wx.MenuItem(menu,ID_REVERT_BACKUP,_(u'Revert to Backup'))
        menu.AppendItem(menuItem)
        self.backup = self.fileInfo.bashDir.join(u'Backups',self.fileInfo.name)
        menuItem.Enable(singleSelect and self.backup.exists())
        #--First Backup item
        wx.EVT_MENU(window,ID_REVERT_FIRST,self.Execute)
        menuItem = wx.MenuItem(menu,ID_REVERT_FIRST,_(u'Revert to First Backup'))
        menu.AppendItem(menuItem)
        self.firstBackup = self.backup +u'f'
        menuItem.Enable(singleSelect and self.firstBackup.exists())

    def Execute(self,event):
        fileInfo = self.fileInfo
        fileName = fileInfo.name
        #--Backup/FirstBackup?
        if event.GetId() ==  ID_REVERT_BACKUP:
            backup = self.backup
        else:
            backup = self.firstBackup
        #--Warning box
        message = _(u"Revert %s to backup dated %s?") % (fileName.s,
            formatDate(backup.mtime))
        if balt.askYes(self.window,message,_(u'Revert to Backup')):
            with balt.BusyCursor():
                dest = fileInfo.dir.join(fileName)
                backup.copyTo(dest)
                fileInfo.setmtime()
                if fileInfo.isEss(): #--Handle CoSave (.pluggy and .obse) files.
                    bosh.CoSaves(backup).copy(dest)
                try:
                    self.window.data.refreshFile(fileName)
                except bosh.FileError:
                    balt.showError(self,_(u'Old file is corrupt!'))
                self.window.RefreshUI(fileName)

#------------------------------------------------------------------------------
class File_Open(Link):
    """Open specified file(s)."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        if len(data) == 1:
            help = _(u"Open '%s' with the system's default program.") % data[0]
        else:
            help = _(u'Open the selected files.')
        menuItem = wx.MenuItem(menu,self.id,_(u'Open...'),help)
        menu.AppendItem(menuItem)
        menuItem.Enable(len(self.data)>0)

    def Execute(self,event):
        """Handle selection."""
        dir = self.window.data.dir
        for file in self.data:
            dir.join(file).start()
#------------------------------------------------------------------------------
class List_Column(Link):
    def __init__(self,columnsKey,colName,enable=True):
        Link.__init__(self)
        self.colName = colName
        self.columnsKey = columnsKey
        self.enable = enable

    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        colName = settings['bash.colNames'][self.colName]
        check = self.colName in settings[self.columnsKey]
        help = _(u"Show/Hide '%s' column.") % colName
        menuItem = wx.MenuItem(menu,self.id,colName,help,kind=wx.ITEM_CHECK)
        menuItem.Enable(self.enable)
        menu.AppendItem(menuItem)
        menuItem.Check(check)

    def Execute(self,event):
        if self.colName in settings[self.columnsKey]:
            settings[self.columnsKey].remove(self.colName)
            settings.setChanged(self.columnsKey)
        else:
            #--Ensure the same order each time
            settings[self.columnsKey] = [x for x in settingDefaults[self.columnsKey] if x in settings[self.columnsKey] or x == self.colName]
        self.window.PopulateColumns()
        self.window.RefreshUI()

#------------------------------------------------------------------------------

class List_Columns(Link):
    """Customize visible columns."""
    def __init__(self,columnsKey,persistantColumns=[]):
        Link.__init__(self)
        self.columnsKey = columnsKey
        self.persistant = persistantColumns

    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        subMenu = wx.Menu()
        menu.AppendMenu(self.id,_(u"Columns"),subMenu)
        for col in settingDefaults[self.columnsKey]:
            enable = col not in self.persistant
            List_Column(self.columnsKey,col,enable).AppendToMenu(subMenu,window,data)

#------------------------------------------------------------------------------
class Installers_AddMarker(Link):
    """Add an installer marker."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Add Marker...'),_(u'Adds a Marker, a special type of package useful for separating and labelling your packages.'))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        """Handle selection."""
        index = self.gTank.GetIndex(GPath(u'===='))
        if index == -1:
            self.data.addMarker(u'====')
            self.data.refresh(what='OS')
            gInstallers.RefreshUIMods()
            index = self.gTank.GetIndex(GPath(u'===='))
        if index != -1:
            self.gTank.ClearSelected()
            self.gTank.gList.SetItemState(index,wx.LIST_STATE_SELECTED,wx.LIST_STATE_SELECTED)
            self.gTank.gList.EditLabel(index)

# Installers Links ------------------------------------------------------------
#------------------------------------------------------------------------------
class Installers_AnnealAll(Link):
    """Anneal all packages."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Anneal All'),_(u'This will install any missing files (for active installers) and correct all install order and reconfiguration errors.'))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        """Handle selection."""
        try:
            with balt.Progress(_(u"Annealing..."),u'\n'+u' '*60) as progress:
                self.data.anneal(progress=progress)
        finally:
            self.data.refresh(what='NS')
            gInstallers.RefreshUIMods()
            bashFrame.RefreshData()

#------------------------------------------------------------------------------
class Installers_UninstallAllPackages(Link):
    """Uninstall all packages."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Uninstall All Packages'),_(u'This will uninstall all packages.'))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        """Handle selection."""
        if not balt.askYes(self.gTank,fill(_(u"Really uninstall All Packages?"),70),self.title): return
        try:
            with balt.Progress(_(u"Uninstalling..."),u'\n'+u' '*60) as progress:
                self.data.uninstall(unArchives='ALL',progress=progress)
        finally:
            self.data.refresh(what='NS')
            gInstallers.RefreshUIMods()
            bashFrame.RefreshData()

#------------------------------------------------------------------------------
class Installers_UninstallAllUnknownFiles(Link):
    """Uninstall all files that do not come from a current package/bethesda files.
       For safety just moved to Oblivion Mods\Bash Installers\Bash\Data Folder Contents (date/time)\."""
    def __init__(self):
        Link.__init__(self)
        self._helpMessage = _(u'This will remove all mod files that are not linked to an active installer out of the Data folder.')

    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Clean Data'),self._helpMessage)
        menu.AppendItem(menuItem)

    def Execute(self,event):
        """Handle selection."""
        fullMessage = _(u"Clean Data directory?") + u"  " + self._helpMessage + u"  " + _(u'This includes files that were installed manually or by another program.  Files will be moved to the "%s" directory instead of being deleted so you can retrieve them later if necessary.  Note that if you use TES4LODGen, this will also clean out the DistantLOD folder, so on completion please run TES4LodGen again.') % u'Oblivion Mods\\Bash Installers\\Bash\\Data Folder Contents <date>'
        if not balt.askYes(self.gTank,fill(fullMessage,70),self.title):
            return
        try:
            with balt.Progress(_(u"Cleaning Data Files..."),u'\n'+u' '*65) as progress:
                self.data.clean(progress=progress)
        finally:
            self.data.refresh(what='NS')
            gInstallers.RefreshUIMods()
            bashFrame.RefreshData()

#------------------------------------------------------------------------------
class Installers_AutoAnneal(BoolLink):
    def __init__(self):
        BoolLink.__init__(self,
                          _(u'Auto-Anneal'),
                          'bash.installers.autoAnneal',
                          _(u"Enable/Disable automatic annealing of packages.")
                          )

#------------------------------------------------------------------------------
class Installers_AutoWizard(BoolLink):
    def __init__(self):
        BoolLink.__init__(self,
                          _(u'Auto-Anneal/Install Wizards'),
                          'bash.installers.autoWizard',
                          _(u"Enable/Disable automatic installing or anneal (as applicable) of packages after running its wizard.")
                          )

#------------------------------------------------------------------------------
class Installers_WizardOverlay(BoolLink):
    """Toggle using the wizard overlay icon"""
    def __init__(self):
        BoolLink.__init__(self,
                          _(u'Wizard Icon Overlay'),
                          'bash.installers.wizardOverlay',
                          _(u"Enable/Disable the magic wand icon overlay for packages with Wizards.")
                          )

    def Execute(self,event):
        BoolLink.Execute(self,event)
        gInstallers.gList.RefreshUI()

#------------------------------------------------------------------------------
class Installers_AutoRefreshProjects(BoolLink):
    """Toggle autoRefreshProjects setting and update."""
    def __init__(self):
        BoolLink.__init__(self,
                          _(u'Auto-Refresh Projects'),
                          'bash.installers.autoRefreshProjects',
                          )

#------------------------------------------------------------------------------
class Installers_AutoApplyEmbeddedBCFs(BoolLink):
    """Toggle autoApplyEmbeddedBCFs setting and update."""
    def __init__(self):
        BoolLink.__init__(self,
                          _(u'Auto-Apply Embedded BCFs'),
                          'bash.installers.autoApplyEmbeddedBCFs',
                          _(u'If enabled, embedded BCFs will automatically be applied to archives.')
                          )

    def Execute(self,event):
        BoolLink.Execute(self,event)
        gInstallers.OnShow()

#------------------------------------------------------------------------------
class Installers_AutoRefreshBethsoft(BoolLink):
    """Toggle refreshVanilla setting and update."""
    def __init__(self): BoolLink.__init__(self,
                                          _(u'Auto-Refresh Bethsoft Content'),
                                         'bash.installers.autoRefreshBethsoft',
                                         )

    def Execute(self,event):
        if not settings[self.key]:
            message = balt.fill(_(u"Enable refreshing Bethsoft Content?  This will cause data refreshing to take much longer if the timestamps on Bethsoft BSA's, ESP's, or ESM's change."))
            if not balt.askWarning(self.gTank,fill(message,80),self.title): return
        BoolLink.Execute(self,event)

#------------------------------------------------------------------------------
class Installers_Enabled(BoolLink):
    """Flips installer state."""
    def __init__(self): BoolLink.__init__(self,
                                         _(u'Enabled'),
                                         'bash.installers.enabled',
                                         _(u'Enable/Disable the Installers tab.')
                                         )

    def Execute(self,event):
        """Handle selection."""
        enabled = settings[self.key]
        message = (_(u"Do you want to enable Installers?")
                   + u'\n\n\t' +
                   _(u"If you do, Bash will first need to initialize some data. This can take on the order of five minutes if there are many mods installed.")
                   )
        if not enabled and not balt.askYes(self.gTank,fill(message,80),self.title):
            return
        enabled = settings[self.key] = not enabled
        if enabled:
            gInstallers.refreshed = False
            gInstallers.OnShow()
            gInstallers.gList.RefreshUI()
        else:
            gInstallers.gList.gList.DeleteAllItems()
            gInstallers.RefreshDetails(None)

#------------------------------------------------------------------------------
class Installers_BsaRedirection(BoolLink):
    """Toggle BSA Redirection."""
    def __init__(self):
        BoolLink.__init__(self,
                          _(u'BSA Redirection'),
                          'bash.bsaRedirection',
                          )

    def AppendToMenu(self,menu,window,data):
        section,key = bush.game.ini.bsaRedirection
        if not section or not key:
            return
        BoolLink.AppendToMenu(self,menu,window,data)

    def Execute(self,event):
        """Handle selection."""
        BoolLink.Execute(self,event)
        if settings[self.key]:
            bsaPath = bosh.modInfos.dir.join(bosh.inisettings['OblivionTexturesBSAName'])
            bsaFile = bosh.BsaFile(bsaPath)
            bsaFile.scan()
            resetCount = bsaFile.reset()
            #balt.showOk(self,_(u"BSA Hashes reset: %d") % (resetCount,))
        bosh.oblivionIni.setBsaRedirection(settings[self.key])

#------------------------------------------------------------------------------
class Installers_ConflictsReportShowsInactive(BoolLink):
    """Toggles option to show inactive on conflicts report."""
    def __init__(self):
        BoolLink.__init__(self,
                          _(u'Show Inactive Conflicts'),
                          'bash.installers.conflictsReport.showInactive',
                          )

    def Execute(self,event):
        BoolLink.Execute(self,event)
        self.gTank.RefreshUI()

#------------------------------------------------------------------------------
class Installers_ConflictsReportShowsLower(BoolLink):
    """Toggles option to show lower on conflicts report."""
    def __init__(self):
        BoolLink.__init__(self,
                          _(u'Show Lower Conflicts'),
                          'bash.installers.conflictsReport.showLower',
                          )

    def Execute(self,event):
        BoolLink.Execute(self,event)
        self.gTank.RefreshUI()

#------------------------------------------------------------------------------
class Installers_AvoidOnStart(BoolLink):
    """Ensures faster bash startup by preventing Installers from being startup tab."""
    def __init__(self): BoolLink.__init__(self,
                                          _(u'Avoid at Startup'),
                                          'bash.installers.fastStart',
                                          _(u"Toggles Wrye Bash to avoid the Installers tab on startup, avoiding unnecessary data scanning.")
                                          )

#------------------------------------------------------------------------------
class Installers_Refresh(Link):
    """Refreshes all Installers data."""
    def __init__(self,fullRefresh=False):
        Link.__init__(self)
        self.fullRefresh = fullRefresh

    def AppendToMenu(self,menu,window,data):
        if not settings['bash.installers.enabled']: return
        Link.AppendToMenu(self,menu,window,data)
        self.title = (_(u'Refresh Data'),_(u'Full Refresh'))[self.fullRefresh]
        if self.fullRefresh:
            help = _(u"Perform a full refresh of all data files, recalculating all CRCs.  This can take 5-15 minutes.")
        else:
            help = _(u"Rescan the Data directory and all project directories.")
        menuItem = wx.MenuItem(menu,self.id,self.title,help)
        menu.AppendItem(menuItem)

    def Execute(self,event):
        """Handle selection."""
        if self.fullRefresh:
            message = balt.fill(_(u"Refresh ALL data from scratch? This may take five to ten minutes (or more) depending on the number of mods you have installed."))
            if not balt.askWarning(self.gTank,fill(message,80),self.title): return
        gInstallers.refreshed = False
        gInstallers.fullRefresh = self.fullRefresh
        gInstallers.OnShow()

#------------------------------------------------------------------------------
class Installers_RemoveEmptyDirs(BoolLink):
    """Toggles option to remove empty directories on file scan."""
    def __init__(self): BoolLink.__init__(self,
                                          _(u'Clean Data Directory'),
                                          'bash.installers.removeEmptyDirs',
                                          )

#------------------------------------------------------------------------------
class Installers_Skip(BoolLink):
    """Toggle various skip settings and update."""
    def Execute(self,event):
        BoolLink.Execute(self,event)
        with balt.Progress(_(u'Refreshing Packages...'),u'\n'+u' '*60, abort=False) as progress:
            progress.setFull(len(self.data))
            for index,dataItem in enumerate(self.data.iteritems()):
                progress(index,_(u'Refreshing Packages...')+u'\n'+dataItem[0].s)
                dataItem[1].refreshDataSizeCrc()
        self.data.refresh(what='NS')
        self.gTank.RefreshUI()

#------------------------------------------------------------------------------
class Installers_SkipScreenshots(Installers_Skip):
    """Toggle skipScreenshots setting and update."""
    def __init__(self): BoolLink.__init__(self,
                                          _(u'Skip Screenshots'),
                                          'bash.installers.skipScreenshots',
                                          )

#------------------------------------------------------------------------------
class Installers_SkipImages(Installers_Skip):
    """Toggle skipImages setting and update."""
    def __init__(self): BoolLink.__init__(self,
                                          _(u'Skip Images'),
                                          'bash.installers.skipImages',
                                          )

#------------------------------------------------------------------------------
class Installers_SkipDocs(Installers_Skip):
    """Toggle skipDocs setting and update."""
    def __init__(self): BoolLink.__init__(self,
                                          _(u'Skip Docs'),
                                          'bash.installers.skipDocs',
                                          )

#------------------------------------------------------------------------------
class Installers_SkipDistantLOD(Installers_Skip):
    """Toggle skipDistantLOD setting and update."""
    def __init__(self): BoolLink.__init__(self,
                                          _(u'Skip DistantLOD'),
                                          'bash.installers.skipDistantLOD',
                                          )

#------------------------------------------------------------------------------
class Installers_skipLandscapeLODMeshes(Installers_Skip):
    """Toggle skipLandscapeLODMeshes setting and update."""
    def __init__(self): BoolLink.__init__(self,
                                          _(u'Skip LOD Meshes'),
                                          'bash.installers.skipLandscapeLODMeshes',
                                          )

#------------------------------------------------------------------------------
class Installers_skipLandscapeLODTextures(Installers_Skip):
    """Toggle skipDistantLOD setting and update."""
    def __init__(self): BoolLink.__init__(self,
                                          _(u'Skip LOD Textures'),
                                          'bash.installers.skipLandscapeLODTextures',
                                          )

#------------------------------------------------------------------------------
class Installers_skipLandscapeLODNormals(Installers_Skip):
    """Toggle skipDistantLOD setting and update."""
    def __init__(self): BoolLink.__init__(self,
                                          _(u'Skip LOD Normals'),
                                          'bash.installers.skipLandscapeLODNormals',
                                          )

#------------------------------------------------------------------------------
class Installers_SkipOBSEPlugins(Installers_Skip):
    """Toggle allowOBSEPlugins setting and update."""
    def __init__(self):
        BoolLink.__init__(self,_(u'Skip %s Plugins') % bush.game.se_sd,
                          'bash.installers.allowOBSEPlugins')

    def AppendToMenu(self,menu,window,data):
        if not bush.game.se_sd: return
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,self.text,self.help,kind=wx.ITEM_CHECK)
        menu.AppendItem(menuItem)
        menuItem.Check(not settings[self.key])
        bosh.installersWindow = self.gTank

#------------------------------------------------------------------------------
class Installers_RenameStrings(Installers_Skip):
    """Toggle auto-renaming of .STRINGS files"""
    def __init__(self):
        BoolLink.__init__(self,
                          _(u'Auto-name String Translation Files'),
                          'bash.installers.renameStrings',
                          )

    def AppendToMenu(self,menu,window,data):
        if bush.game.esp.stringsFiles:
            Installers_Skip.AppendToMenu(self,menu,window,data)

#------------------------------------------------------------------------------
class Installers_SortActive(BoolLink):
    """Sort by type."""
    def __init__(self): BoolLink.__init__(self,
                                          _(u'Sort by Active'),
                                          'bash.installers.sortActive',
                                          _(u'If selected, active installers will be sorted to the top of the list.')
                                          )

    def Execute(self,event):
        BoolLink.Execute(self,event)
        self.gTank.SortItems()

#------------------------------------------------------------------------------
class Installers_SortProjects(BoolLink):
    """Sort dirs to the top."""
    def __init__(self): BoolLink.__init__(self,
                                          _(u'Projects First'),
                                          'bash.installers.sortProjects',
                                          _(u'If selected, projects will be sorted to the top of the list.')
                                          )

    def Execute(self,event):
        BoolLink.Execute(self,event)
        self.gTank.SortItems()

#------------------------------------------------------------------------------
class Installers_SortStructure(BoolLink):
    """Sort by type."""
    def __init__(self): BoolLink.__init__(self,
                                          _(u'Sort by Structure'),
                                          'bash.installers.sortStructure',
                                          )

    def Execute(self,event):
        BoolLink.Execute(self,event)
        self.gTank.SortItems()

# Installer Links -------------------------------------------------------------
#------------------------------------------------------------------------------
class InstallerLink(Link):
    """Common functions for installer links..."""

    def isSingleInstallable(self):
        if len(self.selected) == 1:
            installer = self.data[self.selected[0]]
            if not isinstance(installer,(bosh.InstallerProject,bosh.InstallerArchive)):
                return False
            elif installer.type not in (1,2):
                return False
            return True
        return False

    def filterInstallables(self):
        return [archive for archive in self.selected if archive in self.data and self.data[archive].type in (1,2) and (isinstance(self.data[archive], bosh.InstallerProject) or isinstance(self.data[archive], bosh.InstallerArchive))]

    def hasMarker(self):
        if len(self.selected) > 0:
            for i in self.selected:
                if isinstance(self.data[i],bosh.InstallerMarker):
                    return True
        return False

    def isSingle(self):
        """Indicates whether or not is single installer."""
        return len(self.selected) == 1

    def isSingleMarker(self):
        """Indicates wheter or not is single installer marker."""
        if len(self.selected) != 1: return False
        else: return isinstance(self.data[self.selected[0]],bosh.InstallerMarker)

    def isSingleProject(self):
        """Indicates whether or not is single project."""
        if len(self.selected) != 1: return False
        else: return isinstance(self.data[self.selected[0]],bosh.InstallerProject)

    def isSingleArchive(self):
        """Indicates whether or not is single archive."""
        if len(self.selected) != 1: return False
        else: return isinstance(self.data[self.selected[0]],bosh.InstallerArchive)

    def isSelectedArchives(self):
        """Indicates whether or not selected is all archives."""
        for selected in self.selected:
            if not isinstance(self.data[selected],bosh.InstallerArchive): return False
        return True

    def getProjectPath(self):
        """Returns whether build directory exists."""
        archive = self.selected[0]
        return bosh.dirs['builds'].join(archive.sroot)

    def projectExists(self):
        if not len(self.selected) == 1: return False
        return self.getProjectPath().exists()

#------------------------------------------------------------------------------
class Installer_EditWizard(InstallerLink):
    """Edit the wizard.txt associated with this project"""
    def AppendToMenu(self, menu, window, data):
        Link.AppendToMenu(self, menu, window, data)
        if self.isSingleArchive():
            title = _(u'View Wizard...')
        else:
            title = _(u'Edit Wizard...')
        menuItem = wx.MenuItem(menu, self.id, title,
            help=_(u"Edit the wizard.txt associated with this project."))
        menu.AppendItem(menuItem)
        if self.isSingleInstallable():
            menuItem.Enable(bool(self.data[self.selected[0]].hasWizard))
        else:
            menuItem.Enable(False)

    def Execute(self, event):
        path = self.selected[0]
        if self.isSingleProject():
            # Project, open for edit
            dir = self.data.dir
            dir.join(path.s, self.data[path].hasWizard).start()
        else:
            # Archive, open for viewing
            archive = self.data[path]
            with balt.BusyCursor():
                # This is going to leave junk temp files behind...
                archive.unpackToTemp(path, [archive.hasWizard])
            archive.tempDir.join(archive.hasWizard).start()
            try:
                archive.tempDir.rmtree(archive.tempDir.stail)
            except:
                pass

class Installer_OpenWizardInCommentsWizBAINEditor(InstallerLink):
    """Open the wizard.txt associated with this project in the comments"""
    def AppendToMenu(self, menu, window, data):
        Link.AppendToMenu(self, menu, window, data)
        if self.isSingleArchive():
            title = _(u'View Wizard In Comments...')
        else:
            title = _(u'Open Wizard In Comments...')
        menuItem = wx.MenuItem(menu, self.id, title,
            help=_(u"Open the wizard.txt associated with this project in the Comments / WizBAIN Editor."))
        menu.AppendItem(menuItem)
        if self.isSingleInstallable():
            menuItem.Enable(bool(self.data[self.selected[0]].hasWizard))
        else:
            menuItem.Enable(False)

    def Execute(self, event):
        path = self.selected[0]
        if self.isSingleProject():
            # Project, open for edit
            dir = self.data.dir
            wizpath = u'%s' %dir.join(path.s, self.data[path].hasWizard)
            gInstallers.gComments.LoadFile(wizpath)
        else:
            # Archive, open for viewing
            archive = self.data[path]
            with balt.BusyCursor():
                # This is going to leave junk temp files behind...
                archive.unpackToTemp(path, [archive.hasWizard])
            wizpath = u'%s' % archive.tempDir.join(archive.hasWizard)
            gInstallers.gComments.LoadFile(wizpath)
        try:
            archive.tempDir.rmtree(archive.tempDir.stail)
        except:
            pass

        gInstallers.gComments.ConvertEOLs(2)#Unix. LF. Fix for Mixed EOL problem
        gInstallers.gComments.AppendText(' ')#Need to set the modify flag manually so it saves when changing package selections. Also if the last word in the doc is a keyword(ex. Return) this updates the syntax highlighting.
        gInstallers.gComments.SetFocus()
        gInstallers.gComments.EnsureCaretVisible()

class Installer_Wizard(InstallerLink):
    """Runs the install wizard to select subpackages and esp/m filtering"""
    parentWindow = ''

    def __init__(self, bAuto):
        InstallerLink.__init__(self)
        self.bAuto = bAuto

    def AppendToMenu(self, menu, window, data):
        Link.AppendToMenu(self, menu, window, data)
        if not self.bAuto:
            menuItem = wx.MenuItem(menu, self.id, _(u'Wizard'),
                help=_(u"Run the install wizard."))
        else:
            menuItem = wx.MenuItem(menu, self.id, _(u'Auto Wizard'),
                help=_(u"Run the install wizard."))
        menu.AppendItem(menuItem)
        if self.isSingle():
            installer = self.data[self.selected[0]]
            menuItem.Enable(installer.hasWizard != False)
        else:
            menuItem.Enable(False)

    def Execute(self, event):
        with balt.BusyCursor():
            installer = self.data[self.selected[0]]
            subs = []
            oldRemaps = copy.copy(installer.remaps)
            installer.remaps = {}
            gInstallers.refreshCurrent(installer)
            for index in range(gInstallers.gSubList.GetCount()):
                subs.append(gInstallers.gSubList.GetString(index))
            saved = settings['bash.wizard.size']
            default = settingDefaults['bash.wizard.size']
            pos = settings['bash.wizard.pos']
            # Sanity checks on saved size/position
            if not isinstance(pos,tuple) or len(pos) != 2:
                deprint(_(u'Saved Wizard position (%s) was not a tuple (%s), reverting to default position.') % (pos,type(pos)))
                pos = wx.DefaultPosition
            if not isinstance(saved,tuple) or len(saved) != 2:
                deprint(_(u'Saved Wizard size (%s) was not a tuple (%s), reverting to default size.') % (saved, type(saved)))
                pageSize = tuple(default)
            else:
                pageSize = (max(saved[0],default[0]),max(saved[1],default[1]))
            try:
                wizard = belt.InstallerWizard(self, subs, pageSize, pos)
            except bolt.CancelError:
                return
            balt.ensureDisplayed(wizard)
        ret = wizard.Run()
        # Sanity checks on returned size/position
        if not isinstance(ret.Pos,wx.Point):
            deprint(_(u'Returned Wizard position (%s) was not a wx.Point (%s), reverting to default position.') % (ret.Pos, type(ret.Pos)))
            ret.Pos = wx.DefaultPosition
        if not isinstance(ret.PageSize,wx.Size):
            deprint(_(u'Returned Wizard size (%s) was not a wx.Size (%s), reverting to default size.') % (ret.PageSize, type(ret.PageSize)))
            ret.PageSize = tuple(default)
        settings['bash.wizard.size'] = (ret.PageSize[0],ret.PageSize[1])
        settings['bash.wizard.pos'] = (ret.Pos[0],ret.Pos[1])
        if ret.Canceled:
            installer.remaps = oldRemaps
            gInstallers.refreshCurrent(installer)
            return
        #Check the sub-packages that were selected by the wizard
        installer.resetAllEspmNames()
        for index in xrange(gInstallers.gSubList.GetCount()):
            select = installer.subNames[index + 1] in ret.SelectSubPackages
            gInstallers.gSubList.Check(index, select)
            installer.subActives[index + 1] = select
        gInstallers.refreshCurrent(installer)
        #Check the espms that were selected by the wizard
        espms = gInstallers.gEspmList.GetStrings()
        espms = [x.replace(u'&&',u'&') for x in espms]
        installer.espmNots = set()
        for index, espm in enumerate(gInstallers.espms):
            if espms[index] in ret.SelectEspms:
                gInstallers.gEspmList.Check(index, True)
            else:
                gInstallers.gEspmList.Check(index, False)
                installer.espmNots.add(espm)
        gInstallers.refreshCurrent(installer)
        #Rename the espms that need renaming
        for oldName in ret.RenameEspms:
            installer.setEspmName(oldName, ret.RenameEspms[oldName])
        gInstallers.refreshCurrent(installer)
        #Install if necessary
        if ret.Install:
            #If it's currently installed, anneal
            if self.data[self.selected[0]].isActive:
                #Anneal
                try:
                    with balt.Progress(_(u'Annealing...'), u'\n'+u' '*60) as progress:
                        self.data.anneal(self.selected, progress)
                finally:
                    self.data.refresh(what='NS')
                    gInstallers.RefreshUIMods()
            else:
                #Install, if it's not installed
                try:
                    with balt.Progress(_(u'Installing...'),u'\n'+u' '*60) as progress:
                        self.data.install(self.selected, progress)
                finally:
                    self.data.refresh(what='N')
                    gInstallers.RefreshUIMods()
            bashFrame.RefreshData()
        #Build any ini tweaks
        manuallyApply = []  # List of tweaks the user needs to  manually apply
        lastApplied = None
        #       iniList-> left    -> splitter ->INIPanel
        panel = iniList.GetParent().GetParent().GetParent()
        for iniFile in ret.IniEdits:
            outFile = bosh.dirs['tweaks'].join(u'%s - Wizard Tweak [%s].ini' % (installer.archive, iniFile.sbody))
            with outFile.open('w') as out:
                for line in belt.generateTweakLines(ret.IniEdits[iniFile],iniFile):
                    out.write(line+u'\n')
            bosh.iniInfos.refresh()
            bosh.iniInfos.table.setItem(outFile.tail, 'installer', installer.archive)
            iniList.RefreshUI()
            if iniFile in installer.data_sizeCrc or any([iniFile == x for x in bush.game.iniFiles]):
                if not ret.Install and not any([iniFile == x for x in bush.game.iniFiles]):
                    # Can only automatically apply ini tweaks if the ini was actually installed.  Since
                    # BAIN is setup to not auto install after the wizard, we'll show a message telling the
                    # User what tweaks to apply manually.
                    manuallyApply.append((outFile,iniFile))
                    continue
                # Editing an INI file from this installer is ok, but editing Oblivion.ini
                # give a warning message
                if any([iniFile == x for x in bush.game.iniFiles]):
                    message = (_(u'Apply an ini tweak to %s?')
                               + u'\n\n' +
                               _(u'WARNING: Incorrect tweaks can result in CTDs and even damage to you computer!')
                               ) % iniFile.sbody
                    if not balt.askContinue(self.gTank,message,'bash.iniTweaks.continue',_(u'INI Tweaks')):
                        continue
                panel.AddOrSelectIniDropDown(bosh.dirs['mods'].join(iniFile))
                if bosh.iniInfos[outFile.tail] == 20: continue
                iniList.data.ini.applyTweakFile(outFile)
                lastApplied = outFile.tail
            else:
                # We wont automatically apply tweaks to anything other than Oblivion.ini or an ini from
                # this installer
                manuallyApply.append((outFile,iniFile))
        #--Refresh after all the tweaks are applied
        if lastApplied is not None:
            iniList.RefreshUI('VALID')
            panel.iniContents.RefreshUI()
            panel.tweakContents.RefreshUI(lastApplied)
        if len(manuallyApply) > 0:
            message = balt.fill(_(u'The following INI Tweaks were not automatically applied.  Be sure to apply them after installing the package.'))
            message += u'\n\n'
            message += u'\n'.join([u' * ' + x[0].stail + u'\n   TO: ' + x[1].s for x in manuallyApply])
            balt.showInfo(self.gTank,message)

class Installer_OpenReadme(InstallerLink):
    """Opens the installer's readme if BAIN can find one"""

    def AppendToMenu(self, menu, window, data):
        Link.AppendToMenu(self, menu, window, data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Open Readme'),
            help=_(u"Opens the installer's readme."))
        menu.AppendItem(menuItem)
        if self.isSingle():
            installer = self.data[self.selected[0]]
            menuItem.Enable(bool(installer.hasReadme))
        else:
            menuItem.Enable(False)

    def Execute(self, event):
        installer = self.selected[0]
        if self.isSingleProject():
            # Project, open for edit
            dir = self.data.dir
            dir.join(installer.s, self.data[installer].hasReadme).start()
        else:
            # Archive, open for viewing
            archive = self.data[installer]
            with balt.BusyCursor():
                # This is going to leave junk temp files behind...
                archive.unpackToTemp(installer, [archive.hasReadme])
            archive.tempDir.join(archive.hasReadme).start()

#------------------------------------------------------------------------------
class Installer_Anneal(InstallerLink):
    """Anneal all packages."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Anneal'),
            help=_(u"Anneal all packages."))
        menu.AppendItem(menuItem)
        selected = self.filterInstallables()
        menuItem.Enable(len(selected))

    def Execute(self,event):
        """Handle selection."""
        try:
            with balt.Progress(_(u"Annealing..."),u'\n'+u' '*60) as progress:
                self.data.anneal(self.filterInstallables(),progress)
        finally:
            self.data.refresh(what='NS')
            gInstallers.RefreshUIMods()
            bashFrame.RefreshData()

#------------------------------------------------------------------------------
class Installer_Duplicate(InstallerLink):
    """Duplicate selected Installer."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        self.title = _(u'Duplicate...')
        menuItem = wx.MenuItem(menu,self.id,self.title,
            help=_(u"Duplicate selected %(installername)s.") % ({'installername':self.selected[0]}))
        menu.AppendItem(menuItem)
        menuItem.Enable(self.isSingle() and not self.isSingleMarker())

    def Execute(self,event):
        """Handle selection."""
        curName = self.selected[0]
        isdir = self.data.dir.join(curName).isdir()
        if isdir: root,ext = curName,u''
        else: root,ext = curName.rootExt
        newName = root+u' Copy'+ext
        index = 0
        while newName in self.data:
            newName = root + (_(u' Copy (%d)') % index) + ext
            index += 1
        result = balt.askText(self.gTank,_(u"Duplicate %s to:") % curName.s,
            self.title,newName.s)
        result = (result or u'').strip()
        if not result: return
        #--Error checking
        newName = GPath(result).tail
        if not newName.s:
            balt.showWarning(self.gTank,_(u"%s is not a valid name.") % result)
            return
        if newName in self.data:
            balt.showWarning(self.gTank,_(u"%s already exists.") % newName.s)
            return
        if self.data.dir.join(curName).isfile() and curName.cext != newName.cext:
            balt.showWarning(self.gTank,
                _(u"%s does not have correct extension (%s).") % (newName.s,curName.ext))
            return
        #--Duplicate
        with balt.BusyCursor():
            self.data.copy(curName,newName)
            self.data.refresh(what='N')
            self.gTank.RefreshUI()

#------------------------------------------------------------------------------
class Installer_Hide(InstallerLink):
    """Hide selected Installers."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        self.title = _(u'Hide...')
        menuItem = wx.MenuItem(menu,self.id,self.title,
            help=_(u"Hide selected installer(s)."))
        menu.AppendItem(menuItem)
        for item in window.GetSelected():
            if isinstance(window.data[item],bosh.InstallerMarker):
                menuItem.Enable(False)
                return
        menuItem.Enable(True)

    def Execute(self,event):
        """Handle selection."""
        if not bosh.inisettings['SkipHideConfirmation']:
            message = _(u'Hide these files? Note that hidden files are simply moved to the Bash\\Hidden subdirectory.')
            if not balt.askYes(self.gTank,message,_(u'Hide Files')): return
        destDir = bosh.dirs['modsBash'].join(u'Hidden')
        for curName in self.selected:
            newName = destDir.join(curName)
            if newName.exists():
                message = (_(u'A file named %s already exists in the hidden files directory. Overwrite it?')
                    % newName.stail)
                if not balt.askYes(self.gTank,message,_(u'Hide Files')): return
            #Move
            with balt.BusyCursor():
                file = bosh.dirs['installers'].join(curName)
                file.moveTo(newName)
        self.data.refresh(what='ION')
        self.gTank.RefreshUI()

#------------------------------------------------------------------------------
class Installer_Rename(InstallerLink):
    """Renames files by pattern."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Rename...'),
            help=_(u"Rename selected installer(s)."))
        menu.AppendItem(menuItem)
        self.InstallerType = None
        ##Only enable if all selected items are of the same type
        firstItem = window.data[window.GetSelected()[0]]
        if(isinstance(firstItem,bosh.InstallerMarker)):
            self.InstallerType = bosh.InstallerMarker
        elif(isinstance(firstItem,bosh.InstallerArchive)):
            self.InstallerType = bosh.InstallerArchive
        elif(isinstance(firstItem,bosh.InstallerProject)):
            self.InstallerType = bosh.InstallerProject

        if(self.InstallerType):
            for item in window.GetSelected():
                if not isinstance(window.data[item],self.InstallerType):
                    menuItem.Enable(False)
                    return

        menuItem.Enable(True)

    def Execute(self,event):
        if len(self.selected) > 0:
            index = self.gTank.GetIndex(self.selected[0])
            if index != -1:
                self.gTank.gList.EditLabel(index)

#------------------------------------------------------------------------------
class Installer_HasExtraData(InstallerLink):
    """Toggle hasExtraData flag on installer."""

    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Has Extra Directories'),kind=wx.ITEM_CHECK,
            help=_(u"Allow installation of files in non-standard directories."))
        menu.AppendItem(menuItem)
        if self.isSingleInstallable():
            installer = self.data[self.selected[0]]
            menuItem.Check(installer.hasExtraData)
            menuItem.Enable(True)
        else:
            menuItem.Enable(False)

    def Execute(self,event):
        """Handle selection."""
        installer = self.data[self.selected[0]]
        installer.hasExtraData ^= True
        installer.refreshDataSizeCrc()
        installer.refreshStatus(self.data)
        self.data.refresh(what='N')
        self.gTank.RefreshUI()

#------------------------------------------------------------------------------
class Installer_OverrideSkips(InstallerLink):
    """Toggle overrideSkips flag on installer."""

    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Override Skips'),kind=wx.ITEM_CHECK,
            help=_(u"Override global file type skipping for %(installername)s.") % ({'installername':self.selected[0]}))
        menu.AppendItem(menuItem)
        if self.isSingleInstallable():
            installer = self.data[self.selected[0]]
            menuItem.Check(installer.overrideSkips)
            menuItem.Enable(True)
        else:
            menuItem.Enable(False)

    def Execute(self,event):
        """Handle selection."""
        installer = self.data[self.selected[0]]
        installer.overrideSkips ^= True
        installer.refreshDataSizeCrc()
        installer.refreshStatus(self.data)
        self.data.refresh(what='N')
        self.gTank.RefreshUI()

#------------------------------------------------------------------------------
class Installer_SkipRefresh(InstallerLink):
    """Toggle skipRefresh flag on installer."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u"Don't Refresh"),kind=wx.ITEM_CHECK,
            help=_(u"Don't automatically refresh project."))
        menu.AppendItem(menuItem)
        if self.isSingleProject():
            installer = self.data[self.selected[0]]
            menuItem.Check(installer.skipRefresh)
            menuItem.Enable(True)
        else:
            menuItem.Enable(False)

    def Execute(self,event):
        """Handle selection."""
        installer = self.data[self.selected[0]]
        installer.skipRefresh ^= True
        if not installer.skipRefresh:
            # Check to see if we need to refresh this Project
            file = bosh.dirs['installers'].join(installer.archive)
            if (installer.size,installer.modified) != (file.size,file.getmtime(True)):
                installer.refreshDataSizeCrc()
                installer.refreshBasic(file)
                installer.refreshStatus(self.data)
                self.data.refresh(what='N')
                self.gTank.RefreshUI()

#------------------------------------------------------------------------------
class Installer_Install(InstallerLink):
    """Install selected packages."""
    mode_title = {'DEFAULT':_(u'Install'),'LAST':_(u'Install Last'),'MISSING':_(u'Install Missing')}

    def __init__(self,mode='DEFAULT'):
        Link.__init__(self)
        self.mode = mode

    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        self.title = self.mode_title[self.mode]
        menuItem = wx.MenuItem(menu,self.id,self.title)
        menu.AppendItem(menuItem)
        selected = self.filterInstallables()
        menuItem.Enable(len(selected))

    def Execute(self,event):
        """Handle selection."""
        dir = self.data.dir
        try:
            with balt.Progress(_(u'Installing...'),u'\n'+u' '*60) as progress:
                last = (self.mode == 'LAST')
                override = (self.mode != 'MISSING')
                tweaks = self.data.install(self.filterInstallables(),progress,last,override)
                if tweaks:
                    balt.showInfo(self.window,
                        _(u'The following INI Tweaks were created, because the existing INI was different than what BAIN installed:')
                        +u'\n' + u'\n'.join([u' * %s\n' % x.stail for (x,y) in tweaks]),
                        _(u'INI Tweaks')
                        )
        finally:
            self.data.refresh(what='N')
            gInstallers.RefreshUIMods()
            bashFrame.RefreshData()

#------------------------------------------------------------------------------
class Installer_ListPackages(InstallerLink):
    """Copies list of Bain files to clipboard."""
    def AppendToMenu(self,menu,window,data):
        InstallerLink.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'List Packages...'),
            _(u'Displays a list of all packages.  Also copies that list to the clipboard.  Useful for posting your package order on forums.'))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        #--Get masters list
        message = (_(u'Only show Installed Packages?')
                   + u'\n' +
                   _(u'(Else shows all packages)')
                   )
        if balt.askYes(self.gTank,message,_(u'Only Show Installed?')):
            text = self.data.getPackageList(False)
        else: text = self.data.getPackageList()
        if (wx.TheClipboard.Open()):
            wx.TheClipboard.SetData(wx.TextDataObject(text))
            wx.TheClipboard.Close()
        balt.showLog(self.gTank,text,_(u'BAIN Packages'),asDialog=False,fixedFont=False,icons=bashBlue)

#------------------------------------------------------------------------------
class Installer_ListStructure(InstallerLink):   # Provided by Waruddar
    """Copies folder structure of installer to clipboard."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        self.title = _(u"List Structure...")
        menuItem = wx.MenuItem(menu,self.id,self.title)
        menu.AppendItem(menuItem)
        if not self.isSingle() or isinstance(self.data[self.selected[0]], bosh.InstallerMarker):
            menuItem.Enable(False)
        else:
            menuItem.Enable(True)

    def Execute(self,event):
        archive = self.selected[0]
        installer = self.data[archive]
        text = installer.listSource(archive)

        #--Get masters list
        if (wx.TheClipboard.Open()):
            wx.TheClipboard.SetData(wx.TextDataObject(text))
            wx.TheClipboard.Close()
        balt.showLog(self.gTank,text,_(u'Package Structure'),asDialog=False,fixedFont=False,icons=bashBlue)

#------------------------------------------------------------------------------
class Installer_Move(InstallerLink):
    """Moves selected installers to desired spot."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Move To...'))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        """Handle selection."""
        curPos = min(self.data[x].order for x in self.selected)
        message = (_(u'Move selected archives to what position?')
                   + u'\n' +
                   _(u'Enter position number.')
                   + u'\n' +
                   _(u'Last: -1; First of Last: -2; Semi-Last: -3.')
                   )
        newPos = balt.askText(self.gTank,message,self.title,unicode(curPos))
        if not newPos: return
        newPos = newPos.strip()
        try:
            newPos = int(newPos)
        except:
            balt.showError(self.gTank,_(u'Position must be an integer.'))
            return
        if newPos == -3: newPos = self.data[self.data.lastKey].order
        elif newPos == -2: newPos = self.data[self.data.lastKey].order+1
        elif newPos < 0: newPos = len(self.data.data)
        self.data.moveArchives(self.selected,newPos)
        self.data.refresh(what='N')
        self.gTank.RefreshUI()

#------------------------------------------------------------------------------
class Installer_Open(balt.Tank_Open):
    """Open selected file(s)."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Open...'), _(u"Open '%s'") % (self.data.dir.tail))
        menu.AppendItem(menuItem)
        self.selected = [x for x in self.selected if not isinstance(self.data.data[x],bosh.InstallerMarker)]
        menuItem.Enable(bool(self.selected))

#------------------------------------------------------------------------------
class InstallerOpenAt_MainMenu(balt.MenuLink):
    """Main Open At Menu"""
    def AppendToMenu(self,menu,window,data):
        subMenu = wx.Menu()
        menu.AppendMenu(-1,self.name,subMenu)
        #--Only enable the menu and append the subMenu's if one archive is selected
        if len(window.GetSelected()) > 1:
            id = menu.FindItem(self.name)
            menu.Enable(id,False)
        else:
            for item in window.GetSelected():
                if not isinstance(window.data[item],bosh.InstallerArchive):
                    id = menu.FindItem(self.name)
                    menu.Enable(id,False)
                    break
            else:
                for link in self.links:
                    link.AppendToMenu(subMenu,window,data)

class Installer_OpenTesNexus(InstallerLink):
    """Open selected file(s)."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'TES Nexus...'))
        menu.AppendItem(menuItem)
        x = bosh.reTesNexus.search(data[0].s)
        menuItem.Enable(bool(self.isSingleArchive() and x and x.group(2)))

    def Execute(self,event):
        """Handle selection."""
        message = _(u"Attempt to open this as a mod at TES Nexus? This assumes that the trailing digits in the package's name are actually the id number of the mod at TES Nexus. If this assumption is wrong, you'll just get a random mod page (or error notice) at TES Nexus.")
        if balt.askContinue(self.gTank,message,'bash.installers.openTesNexus',_(u'Open at TES Nexus')):
            id = bosh.reTesNexus.search(self.selected[0].s).group(2)
            os.startfile(u'http://oblivion.nexusmods.com/mods/'+id)

class Installer_OpenSkyrimNexus(InstallerLink):
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Skyrim Nexus...'))
        menu.AppendItem(menuItem)
        x = bosh.reTesNexus.search(data[0].s)
        menuItem.Enable(bool(self.isSingleArchive() and x and x.group(2)))

    def Execute(self,event):
        message = _(u"Attempt to open this as a mod at Skyrim Nexus?  This assumes that the trailing digits in the package's name are actually the id number of the mod at Skyrim Nexus.  If this assumption is wrong, you'll just get a random mod page (or error notice) at Skyrim Nexus.")
        if balt.askContinue(self.gTank,message,'bash.installers.openSkyimNexus',_(u'Open at Skyrim Nexus')):
            id = bosh.reTesNexus.search(self.selected[0].s).group(2)
            os.startfile(u'http://skyrim.nexusmods.com/mods/'+id)

class Installer_OpenSearch(InstallerLink):
    """Open selected file(s)."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Google...'))
        menu.AppendItem(menuItem)
        x = bosh.reTesNexus.search(data[0].s)
        menuItem.Enable(bool(self.isSingleArchive() and x and x.group(1)))

    def Execute(self,event):
        """Handle selection."""
        message = _(u"Open a search for this on Google?")
        if balt.askContinue(self.gTank,message,'bash.installers.opensearch',_(u'Open a search')):
            os.startfile(u'http://www.google.com/search?hl=en&q='+u'+'.join(re.split(ur'\W+|_+',bosh.reTesNexus.search(self.selected[0].s).group(1))))

class Installer_OpenTESA(InstallerLink):
    """Open selected file(s)."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'TES Alliance...'))
        menu.AppendItem(menuItem)
        x = bosh.reTESA.search(data[0].s)
        menuItem.Enable(bool(self.isSingleArchive() and x and x.group(2)))

    def Execute(self,event):
        """Handle selection."""
        message = _(u"Attempt to open this as a mod at TES Alliance? This assumes that the trailing digits in the package's name are actually the id number of the mod at TES Alliance. If this assumption is wrong, you'll just get a random mod page (or error notice) at TES Alliance.")
        if balt.askContinue(self.gTank,message,'bash.installers.openTESA',_(u'Open at TES Alliance')):
            id = bosh.reTESA.search(self.selected[0].s).group(2)
            os.startfile(u'http://tesalliance.org/forums/index.php?app=downloads&showfile='+id)

class Installer_OpenPES(InstallerLink):
    """Open selected file(s)."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Planet Elderscrolls...'))
        menu.AppendItem(menuItem)
        x = bosh.reTESA.search(data[0].s)
        menuItem.Enable(bool(self.isSingleArchive() and x and x.group(2)))

    def Execute(self,event):
        """Handle selection."""
        message = _(u"Attempt to open this as a mod at Planet Elderscrolls? This assumes that the trailing digits in the package's name are actually the id number of the mod at Planet Elderscrolls. If this assumption is wrong, you'll just get a random mod page (or error notice) at Planet Elderscrolls.")
        if balt.askContinue(self.gTank,message,'bash.installers.openPES',_(u'Open at Planet Elderscrolls')):
            id = bosh.reTESA.search(self.selected[0].s).group(2)
            os.startfile(u'http://planetelderscrolls.gamespy.com/View.php?view=OblivionMods.Detail&id='+id)

#------------------------------------------------------------------------------
class Installer_Refresh(InstallerLink):
    """Rescans selected Installers."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Refresh'))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        """Handle selection."""
        dir = self.data.dir
        try:
            with balt.Progress(_(u'Refreshing Packages...'),u'\n'+u' '*60, abort=True) as progress:
                progress.setFull(len(self.selected))
                for index,archive in enumerate(self.selected):
                    progress(index,_(u'Refreshing Packages...')+u'\n'+archive.s)
                    installer = self.data[archive]
                    apath = bosh.dirs['installers'].join(archive)
                    installer.refreshBasic(apath,SubProgress(progress,index,index+1),True)
                    self.data.hasChanged = True
        except CancelError:
            # User canceled the refresh
            pass
        self.data.refresh(what='NSC')
        self.gTank.RefreshUI()

#------------------------------------------------------------------------------
class Installer_SkipVoices(InstallerLink):
    """Toggle skipVoices flag on installer."""

    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Skip Voices'),kind=wx.ITEM_CHECK)
        menu.AppendItem(menuItem)
        if self.isSingleInstallable():
            installer = self.data[self.selected[0]]
            menuItem.Check(installer.skipVoices)
            menuItem.Enable(True)
        else:
            menuItem.Enable(False)

    def Execute(self,event):
        """Handle selection."""
        installer = self.data[self.selected[0]]
        installer.skipVoices ^= True
        installer.refreshDataSizeCrc()
        self.data.refresh(what='NS')
        self.gTank.RefreshUI()

#------------------------------------------------------------------------------
class Installer_Uninstall(InstallerLink):
    """Uninstall selected Installers."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Uninstall'))
        menu.AppendItem(menuItem)
        selected = self.filterInstallables()
        menuItem.Enable(len(selected))

    def Execute(self,event):
        """Handle selection."""
        dir = self.data.dir
        try:
            with balt.Progress(_(u"Uninstalling..."),u'\n'+u' '*60) as progress:
                self.data.uninstall(self.filterInstallables(),progress)
        finally:
            self.data.refresh(what='NS')
            gInstallers.RefreshUIMods()
            bashFrame.RefreshData()

#------------------------------------------------------------------------------
class Installer_CopyConflicts(InstallerLink):
    """For Modders only - copy conflicts to a new project."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        self.title = _(u'Copy Conflicts to Project')
        menuItem = wx.MenuItem(menu,self.id,self.title)
        menu.AppendItem(menuItem)
        menuItem.Enable(self.isSingleInstallable())

    def Execute(self,event):
        """Handle selection."""
        dir = self.data.dir
        data = self.data
        srcConflicts = set()
        packConflicts = []
        with balt.Progress(_(u"Copying Conflicts..."),u'\n'+u' '*60) as progress:
            srcArchive = self.selected[0]
            srcInstaller = self.data[srcArchive]
            src_sizeCrc = srcInstaller.data_sizeCrc
            mismatched = set(src_sizeCrc)
            if mismatched:
                numFiles = 0
                curFile = 1
                srcOrder = srcInstaller.order
                destDir = GPath(u"%03d - Conflicts" % (srcOrder))
                getArchiveOrder =  lambda x: data[x].order
                for package in sorted(data.data,key=getArchiveOrder):
                    installer = data[package]
                    curConflicts = set()
                    for x,y in installer.refreshDataSizeCrc().iteritems():
                        if x in mismatched and installer.data_sizeCrc[x] != src_sizeCrc[x]:
                            curConflicts.add(y)
                            srcConflicts.add(src_sizeCrc[x])
                    numFiles += len(curConflicts)
                    if curConflicts: packConflicts.append((installer.order,installer,package,curConflicts))
                srcConflicts = set(src for src, size, crc in srcInstaller.fileSizeCrcs if (size,crc) in srcConflicts)
                numFiles += len(srcConflicts)
                if numFiles:
                    progress.setFull(numFiles)
                    if isinstance(srcInstaller,bosh.InstallerProject):
                        for src in srcConflicts:
                            srcFull = bosh.dirs['installers'].join(srcArchive,src)
                            destFull = bosh.dirs['installers'].join(destDir,GPath(srcArchive.s),src)
                            if srcFull.exists():
                                progress(curFile,srcArchive.s+u'\n'+_(u'Copying files...')+u'\n'++src)
                                srcFull.copyTo(destFull)
                                curFile += 1
                    else:
                        srcInstaller.unpackToTemp(srcArchive, srcConflicts,SubProgress(progress,0,len(srcConflicts),numFiles))
                        srcInstaller.tempDir.moveTo(bosh.dirs['installers'].join(destDir,GPath(srcArchive.s)))
                    curFile = len(srcConflicts)
                    for order, installer, package, curConflicts in packConflicts:
                        if isinstance(installer,bosh.InstallerProject):
                            for src in curConflicts:
                                srcFull = bosh.dirs['installers'].join(package,src)
                                destFull = bosh.dirs['installers'].join(destDir,GPath(u"%03d - %s" % (order, package.s)),src)
                                if srcFull.exists():
                                    progress(curFile,srcArchive.s+u'\n'+_(u'Copying files...')+u'\n'+src)
                                    srcFull.copyTo(destFull)
                                    curFile += 1
                        else:
                            installer.unpackToTemp(package, curConflicts,SubProgress(progress,curFile,curFile+len(curConflicts),numFiles))
                            installer.tempDir.moveTo(bosh.dirs['installers'].join(destDir,GPath(u"%03d - %s" % (order, package.s))))
                            curFile += len(curConflicts)
                    project = destDir.root
                    if project not in self.data:
                        self.data[project] = bosh.InstallerProject(project)
                    iProject = self.data[project]
                    pProject = bosh.dirs['installers'].join(project)
                    iProject.refreshed = False
                    iProject.refreshBasic(pProject,None,True)
                    if iProject.order == -1:
                        self.data.moveArchives([project],srcInstaller.order+1)
                    self.data.refresh(what='I')
                    self.gTank.RefreshUI()

# InstallerDetails Espm Links ------------------------------------------------------
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
class Installer_Espm_SelectAll(InstallerLink):
    """Select All Esp/ms in installer for installation."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Select All'))
        menu.AppendItem(menuItem)
        if len(gInstallers.espms) == 0:
            menuItem.Enable(False)

    def Execute(self,event):
        """Handle selection."""
        installer = gInstallers.data[gInstallers.detailsItem]
        installer.espmNots = set()
        for i in range(len(gInstallers.espms)):
            gInstallers.gEspmList.Check(i, True)
        gInstallers.refreshCurrent(installer)

class Installer_Espm_DeselectAll(InstallerLink):
    """Deselect All Esp/ms in installer for installation."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Deselect All'))
        menu.AppendItem(menuItem)
        if len(gInstallers.espms) == 0:
            menuItem.Enable(False)

    def Execute(self,event):
        """Handle selection."""
        installer = gInstallers.data[gInstallers.detailsItem]
        espmNots = installer.espmNots = set()
        for i in range(len(gInstallers.espms)):
            gInstallers.gEspmList.Check(i, False)
            espm = GPath(gInstallers.gEspmList.GetString(i).replace(u'&&',u'&'))
            espmNots.add(espm)
        gInstallers.refreshCurrent(installer)

class Installer_Espm_Rename(InstallerLink):
    """Changes the installed name for an Esp/m."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Rename...'))
        menu.AppendItem(menuItem)
        if data == -1:
            menuItem.Enable(False)

    def Execute(self,event):
        """Handle selection."""
        installer = gInstallers.data[gInstallers.detailsItem]
        curName = gInstallers.gEspmList.GetString(self.data).replace(u'&&',u'&')
        if curName[0] == u'*':
            curName = curName[1:]
        file = GPath(curName)
        newName = balt.askText(self.window,_(u"Enter new name (without the extension):"),
                               _(u"Rename Esp/m"), file.sbody)
        if not newName: return
        if newName in gInstallers.espms: return
        installer.setEspmName(curName,newName+file.cext)
        gInstallers.refreshCurrent(installer)

class Installer_Espm_Reset(InstallerLink):
    """Resets the installed name for an Esp/m."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Reset Name'))
        menu.AppendItem(menuItem)
        if data == -1:
            menuItem.Enable(False)
            return
        installer = gInstallers.data[gInstallers.detailsItem]
        curName = gInstallers.gEspmList.GetString(self.data).replace(u'&&',u'&')
        if curName[0] == u'*':
            curName = curName[1:]
        menuItem.Enable(installer.isEspmRenamed(curName))

    def Execute(self,event):
        """Handle selection."""
        installer = gInstallers.data[gInstallers.detailsItem]
        curName = gInstallers.gEspmList.GetString(self.data).replace(u'&&',u'&')
        if curName[0] == u'*':
            curName = curName[1:]
        installer.resetEspmName(curName)
        gInstallers.refreshCurrent(installer)

class Installer_Espm_ResetAll(InstallerLink):
    """Resets all renamed Esp/ms."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Reset All Names'))
        menu.AppendItem(menuItem)
        if len(gInstallers.espms) == 0:
            menuItem.Enable(False)

    def Execute(self,event):
        """Handle selection."""
        installer = gInstallers.data[gInstallers.detailsItem]
        installer.resetAllEspmNames()
        gInstallers.refreshCurrent(installer)

class Installer_Espm_List(InstallerLink):
    """Lists all Esp/ms in installer for user information/w/e."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'List Esp/ms'))
        menu.AppendItem(menuItem)
        if len(gInstallers.espms) == 0:
            menuItem.Enable(False)

    def Execute(self,event):
        """Handle selection."""
        subs = _(u'Esp/m List for %s:') % (gInstallers.data[gInstallers.detailsItem].archive) + u'\n[spoiler]\n'
        for index in range(gInstallers.gEspmList.GetCount()):
            subs += [u'   ',u'** '][gInstallers.gEspmList.IsChecked(index)] + gInstallers.gEspmList.GetString(index) + '\n'
        subs += u'[/spoiler]'
        if (wx.TheClipboard.Open()):
            wx.TheClipboard.SetData(wx.TextDataObject(subs))
            wx.TheClipboard.Close()
        balt.showLog(self.window,subs,_(u'Esp/m List'),asDialog=False,fixedFont=False,icons=bashBlue)

# InstallerDetails Subpackage Links --------------------------------------------
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
class Installer_Subs_SelectAll(InstallerLink):
    """Select All sub-packages in installer for installation."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Select All'))
        menu.AppendItem(menuItem)
        if gInstallers.gSubList.GetCount() < 2:
            menuItem.Enable(False)

    def Execute(self,event):
        """Handle selection."""
        installer = gInstallers.data[gInstallers.detailsItem]
        for index in xrange(gInstallers.gSubList.GetCount()):
            gInstallers.gSubList.Check(index, True)
            installer.subActives[index + 1] = True
        gInstallers.refreshCurrent(installer)

class Installer_Subs_DeselectAll(InstallerLink):
    """Deselect All sub-packages in installer for installation."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Deselect All'))
        menu.AppendItem(menuItem)
        if gInstallers.gSubList.GetCount() < 2:
            menuItem.Enable(False)

    def Execute(self,event):
        """Handle selection."""
        installer = gInstallers.data[gInstallers.detailsItem]
        for index in xrange(gInstallers.gSubList.GetCount()):
            gInstallers.gSubList.Check(index, False)
            installer.subActives[index + 1] = False
        gInstallers.refreshCurrent(installer)

class Installer_Subs_ToggleSelection(InstallerLink):
    """Toggles selection state of all sub-packages in installer for installation."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Toggle Selection'))
        menu.AppendItem(menuItem)
        if gInstallers.gSubList.GetCount() < 2:
            menuItem.Enable(False)

    def Execute(self,event):
        """Handle selection."""
        installer = gInstallers.data[gInstallers.detailsItem]
        for index in xrange(gInstallers.gSubList.GetCount()):
            check = not installer.subActives[index+1]
            gInstallers.gSubList.Check(index, check)
            installer.subActives[index + 1] = check
        gInstallers.refreshCurrent(installer)

class Installer_Subs_ListSubPackages(InstallerLink):
    """Lists all sub-packages in installer for user information/w/e."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'List Sub-packages'))
        menu.AppendItem(menuItem)
        if gInstallers.gSubList.GetCount() < 2:
            menuItem.Enable(False)

    def Execute(self,event):
        """Handle selection."""
        installer = gInstallers.data[gInstallers.detailsItem]
        subs = _(u'Sub-Packages List for %s:') % (installer.archive) + u'\n[spoiler]\n'
        for index in xrange(gInstallers.gSubList.GetCount()):
            subs += [u'   ',u'** '][gInstallers.gSubList.IsChecked(index)] + gInstallers.gSubList.GetString(index) + u'\n'
        subs += u'[/spoiler]'
        if (wx.TheClipboard.Open()):
            wx.TheClipboard.SetData(wx.TextDataObject(subs))
            wx.TheClipboard.Close()
        balt.showLog(self.window,subs,_(u'Sub-Package Lists'),asDialog=False,fixedFont=False,icons=bashBlue)
# InstallerArchive Links ------------------------------------------------------
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
class InstallerArchive_Unpack(InstallerLink):
    """Install selected packages."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        if self.isSelectedArchives():
            self.title = _(u'Unpack to Project(s)...')
            menuItem = wx.MenuItem(menu,self.id,self.title)
            menu.AppendItem(menuItem)

    def Execute(self,event):
        if self.isSingleArchive():
            archive = self.selected[0]
            installer = self.data[archive]
            project = archive.root
            result = balt.askText(self.gTank,_(u"Unpack %s to Project:") % archive.s,
                self.title,project.s)
            result = (result or u'').strip()
            if not result: return
            #--Error checking
            project = GPath(result).tail
            if not project.s or project.cext in bosh.readExts:
                balt.showWarning(self.gTank,_(u"%s is not a valid project name.") % result)
                return
            if self.data.dir.join(project).isfile():
                balt.showWarning(self.gTank,_(u"%s is a file.") % project.s)
                return
            if project in self.data:
                if not balt.askYes(self.gTank,_(u"%s already exists. Overwrite it?") % project.s,self.title,False):
                    return
        #--Copy to Build
        with balt.Progress(_(u"Unpacking to Project..."),u'\n'+u' '*60) as progress:
            if self.isSingleArchive():
                installer.unpackToProject(archive,project,SubProgress(progress,0,0.8))
                if project not in self.data:
                    self.data[project] = bosh.InstallerProject(project)
                iProject = self.data[project]
                pProject = bosh.dirs['installers'].join(project)
                iProject.refreshed = False
                iProject.refreshBasic(pProject,SubProgress(progress,0.8,0.99),True)
                if iProject.order == -1:
                    self.data.moveArchives([project],installer.order+1)
                self.data.refresh(what='NS')
                self.gTank.RefreshUI()
                #pProject.start()
            else:
                for archive in self.selected:
                    project = archive.root
                    installer = self.data[archive]
                    if project in self.data:
                        if not balt.askYes(self.gTank,_(u"%s already exists. Overwrite it?") % project.s,self.title,False):
                            continue
                    installer.unpackToProject(archive,project,SubProgress(progress,0,0.8))
                    if project not in self.data:
                        self.data[project] = bosh.InstallerProject(project)
                    iProject = self.data[project]
                    pProject = bosh.dirs['installers'].join(project)
                    iProject.refreshed = False
                    iProject.refreshBasic(pProject,SubProgress(progress,0.8,0.99),True)
                    if iProject.order == -1:
                        self.data.moveArchives([project],installer.order+1)
                self.data.refresh(what='NS')
                self.gTank.RefreshUI()

# InstallerProject Links ------------------------------------------------------
#------------------------------------------------------------------------------
class InstallerProject_OmodConfigDialog(wx.Frame):
    """Dialog for editing omod configuration data."""
    def __init__(self,parent,data,project):
        #--Data
        self.data = data
        self.project = project
        self.config = config = data[project].getOmodConfig(project)
        #--GUI
        wx.Frame.__init__(self,parent,wx.ID_ANY,_(u'Omod Config: ')+project.s,
            style=(wx.RESIZE_BORDER | wx.CAPTION | wx.CLIP_CHILDREN |wx.TAB_TRAVERSAL))
        self.SetIcons(bashBlue)
        self.SetSizeHints(300,300)
        self.SetBackgroundColour(wx.NullColour)
        #--Fields
        self.gName = wx.TextCtrl(self,wx.ID_ANY,config.name)
        self.gVersion = wx.TextCtrl(self,wx.ID_ANY,u'%d.%02d' % (config.vMajor,config.vMinor))
        self.gWebsite = wx.TextCtrl(self,wx.ID_ANY,config.website)
        self.gAuthor = wx.TextCtrl(self,wx.ID_ANY,config.author)
        self.gEmail = wx.TextCtrl(self,wx.ID_ANY,config.email)
        self.gAbstract = wx.TextCtrl(self,wx.ID_ANY,config.abstract,style=wx.TE_MULTILINE)
        #--Max Lenght
        self.gName.SetMaxLength(100)
        self.gVersion.SetMaxLength(32)
        self.gWebsite.SetMaxLength(512)
        self.gAuthor.SetMaxLength(512)
        self.gEmail.SetMaxLength(512)
        self.gAbstract.SetMaxLength(4*1024)
        #--Layout
        fgSizer = wx.FlexGridSizer(0,2,4,4)
        fgSizer.AddGrowableCol(1,1)
        fgSizer.AddMany([
            staticText(self,_(u"Name:")), (self.gName,1,wx.EXPAND),
            staticText(self,_(u"Version:")),(self.gVersion,1,wx.EXPAND),
            staticText(self,_(u"Website:")),(self.gWebsite,1,wx.EXPAND),
            staticText(self,_(u"Author:")),(self.gAuthor,1,wx.EXPAND),
            staticText(self,_(u"Email:")),(self.gEmail,1,wx.EXPAND),
            ])
        sizer = vSizer(
            (fgSizer,0,wx.EXPAND|wx.ALL^wx.BOTTOM,4),
            (staticText(self,_(u"Abstract")),0,wx.LEFT|wx.RIGHT,4),
            (self.gAbstract,1,wx.EXPAND|wx.ALL^wx.BOTTOM,4),
            (hSizer(
                spacer,
                (button(self,id=wx.ID_SAVE,onClick=self.DoSave),0,),
                (button(self,id=wx.ID_CANCEL,onClick=self.DoCancel),0,wx.LEFT,4),
                ),0,wx.EXPAND|wx.ALL,4),
            )
        #--Done
        self.FindWindowById(wx.ID_SAVE).SetDefault()
        self.SetSizerAndFit(sizer)
        self.SetSizer(sizer)
        self.SetSize((350,400))

    #--Save/Cancel
    def DoCancel(self,event):
        """Handle save button."""
        self.Destroy()

    def DoSave(self,event):
        """Handle save button."""
        config = self.config
        #--Text fields
        config.name = self.gName.GetValue().strip()
        config.website = self.gWebsite.GetValue().strip()
        config.author = self.gAuthor.GetValue().strip()
        config.email = self.gEmail.GetValue().strip()
        config.abstract = self.gAbstract.GetValue().strip()
        #--Version
        maVersion = re.match(ur'(\d+)\.(\d+)',self.gVersion.GetValue().strip(),flags=re.U)
        if maVersion:
            config.vMajor,config.vMinor = map(int,maVersion.groups())
        else:
            config.vMajor,config.vMinor = (0,0)
        #--Done
        self.data[self.project].writeOmodConfig(self.project,self.config)
        self.Destroy()

#------------------------------------------------------------------------------
class InstallerProject_OmodConfig(InstallerLink):
    """Install selected packages."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        self.title = _(u'Omod Info...')
        menuItem = wx.MenuItem(menu,self.id,self.title)
        menu.AppendItem(menuItem)
        menuItem.Enable(self.isSingleProject())

    def Execute(self,event):
        project = self.selected[0]
        dialog = InstallerProject_OmodConfigDialog(self.gTank,self.data,project)
        dialog.Show()

#------------------------------------------------------------------------------
class InstallerProject_Sync(InstallerLink):
    """Install selected packages."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        self.title = _(u'Sync from Data')
        menuItem = wx.MenuItem(menu,self.id,self.title)
        menu.AppendItem(menuItem)
        enabled = False
        if self.isSingleProject():
            project = self.selected[0]
            installer = self.data[project]
            enabled = bool(installer.missingFiles or installer.mismatchedFiles)
        menuItem.Enable(enabled)

    def Execute(self,event):
        project = self.selected[0]
        installer = self.data[project]
        missing = installer.missingFiles
        mismatched = installer.mismatchedFiles
        message = (_(u'Update %s according to data directory?')
                   + u'\n' +
                   _(u'Files to delete:')
                   + u'%d\n' +
                   _(u'Files to update:')
                   + u'%d') % (project.s,len(missing),len(mismatched))
        if not balt.askWarning(self.gTank,message,self.title): return
        #--Sync it, baby!
        with balt.Progress(self.title,u'\n'+u' '*60) as progress:
            progress(0.1,_(u'Updating files.'))
            installer.syncToData(project,missing|mismatched)
            pProject = bosh.dirs['installers'].join(project)
            installer.refreshed = False
            installer.refreshBasic(pProject,SubProgress(progress,0.1,0.99),True)
            self.data.refresh(what='NS')
            self.gTank.RefreshUI()

#------------------------------------------------------------------------------
class InstallerProject_SyncPack(InstallerLink):
    """Install selected packages."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Sync and Pack'))
        menu.AppendItem(menuItem)
        menuItem.Enable(self.projectExists())

    def Execute(self,event):
        raise UncodedError

#------------------------------------------------------------------------------
class InstallerProject_Pack(InstallerLink):
    """Pack project to an archive."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        #--Pack is appended whenever Unpack isn't, and vice-versa
        if self.isSingleProject():
            self.title = _(u'Pack to Archive...')
            menuItem = wx.MenuItem(menu,self.id,self.title)
            menu.AppendItem(menuItem)

    def Execute(self,event):
        #--Generate default filename from the project name and the default extension
        project = self.selected[0]
        installer = self.data[project]
        archive = bosh.GPath(project.s + bosh.defaultExt)
        #--Confirm operation
        result = balt.askText(self.gTank,_(u'Pack %s to Archive:') % project.s,
            self.title,archive.s)
        result = (result or u'').strip()
        if not result: return
        #--Error checking
        archive = GPath(result).tail
        if not archive.s:
            balt.showWarning(self.gTank,_(u'%s is not a valid archive name.') % result)
            return
        if self.data.dir.join(archive).isdir():
            balt.showWarning(self.gTank,_(u'%s is a directory.') % archive.s)
            return
        if archive.cext not in bosh.writeExts:
            balt.showWarning(self.gTank,_(u'The %s extension is unsupported. Using %s instead.') % (archive.cext, bosh.defaultExt))
            archive = GPath(archive.sroot + bosh.defaultExt).tail
        if archive in self.data:
            if not balt.askYes(self.gTank,_(u'%s already exists. Overwrite it?') % archive.s,self.title,False): return
        #--Archive configuration options
        blockSize = None
        if archive.cext in bosh.noSolidExts:
            isSolid = False
        else:
            if not u'-ms=' in bosh.inisettings['7zExtraCompressionArguments']:
                isSolid = balt.askYes(self.gTank,_(u'Use solid compression for %s?') % archive.s,self.title,False)
                if isSolid:
                    blockSize = balt.askNumber(self.gTank,
                        _(u'Use what maximum size for each solid block?')
                        + u'\n' +
                        _(u"Enter '0' to use 7z's default size.")
                        ,u'MB',self.title,0,0,102400)
            else: isSolid = True
        with balt.Progress(_(u'Packing to Archive...'),u'\n'+u' '*60) as progress:
            #--Pack
            installer.packToArchive(project,archive,isSolid,blockSize,SubProgress(progress,0,0.8))
            #--Add the new archive to Bash
            if archive not in self.data:
                self.data[archive] = bosh.InstallerArchive(archive)
            #--Refresh UI
            iArchive = self.data[archive]
            pArchive = bosh.dirs['installers'].join(archive)
            iArchive.blockSize = blockSize
            iArchive.refreshed = False
            iArchive.refreshBasic(pArchive,SubProgress(progress,0.8,0.99),True)
            if iArchive.order == -1:
                self.data.moveArchives([archive],installer.order+1)
            #--Refresh UI
            self.data.refresh(what='I')
            self.gTank.RefreshUI()

#------------------------------------------------------------------------------
class InstallerProject_ReleasePack(InstallerLink):
    """Pack project to an archive for release. Ignores dev files/folders."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        self.title = _(u'Package for Release...')
        menuItem = wx.MenuItem(menu,self.id,self.title)
        menu.AppendItem(menuItem)
        menuItem.Enable(self.isSingleProject())

    def Execute(self,event):
        #--Generate default filename from the project name and the default extension
        project = self.selected[0]
        installer = self.data[project]
        archive = bosh.GPath(project.s + bosh.defaultExt)
        #--Confirm operation
        result = balt.askText(self.gTank,_(u"Pack %s to Archive:") % project.s,
            self.title,archive.s)
        result = (result or u'').strip()
        if not result: return
        #--Error checking
        archive = GPath(result).tail
        if not archive.s:
            balt.showWarning(self.gTank,_(u"%s is not a valid archive name.") % result)
            return
        if self.data.dir.join(archive).isdir():
            balt.showWarning(self.gTank,_(u"%s is a directory.") % archive.s)
            return
        if archive.cext not in bosh.writeExts:
            balt.showWarning(self.gTank,_(u"The %s extension is unsupported. Using %s instead.") % (archive.cext, bosh.defaultExt))
            archive = GPath(archive.sroot + bosh.defaultExt).tail
        if archive in self.data:
            if not balt.askYes(self.gTank,_(u"%s already exists. Overwrite it?") % archive.s,self.title,False): return
        #--Archive configuration options
        blockSize = None
        if archive.cext in bosh.noSolidExts:
            isSolid = False
        else:
            if not u'-ms=' in bosh.inisettings['7zExtraCompressionArguments']:
                isSolid = balt.askYes(self.gTank,_(u"Use solid compression for %s?") % archive.s,self.title,False)
                if isSolid:
                    blockSize = balt.askNumber(self.gTank,
                        _(u'Use what maximum size for each solid block?')
                        + u'\n' +
                        _(u"Enter '0' to use 7z's default size."),'MB',self.title,0,0,102400)
            else: isSolid = True
        with balt.Progress(_(u"Packing to Archive..."),u'\n'+u' '*60) as progress:
            #--Pack
            installer.packToArchive(project,archive,isSolid,blockSize,SubProgress(progress,0,0.8),release=True)
            #--Add the new archive to Bash
            if archive not in self.data:
                self.data[archive] = bosh.InstallerArchive(archive)
            #--Refresh UI
            iArchive = self.data[archive]
            pArchive = bosh.dirs['installers'].join(archive)
            iArchive.blockSize = blockSize
            iArchive.refreshed = False
            iArchive.refreshBasic(pArchive,SubProgress(progress,0.8,0.99),True)
            if iArchive.order == -1:
                self.data.moveArchives([archive],installer.order+1)
            #--Refresh UI
            self.data.refresh(what='I')
            self.gTank.RefreshUI()

#------------------------------------------------------------------------------
class InstallerConverter_Apply(InstallerLink):
    """Apply a Bain Conversion File."""
    def __init__(self,converter,numAsterisks):
        InstallerLink.__init__(self)
        self.converter = converter
        #--Add asterisks to indicate the number of unselected archives that the BCF uses
        self.dispName = u''.join((self.converter.fullPath.sbody,u'*' * numAsterisks))

    def AppendToMenu(self,menu,window,data):
        InstallerLink.AppendToMenu(self,menu,window,data)
        self.title = _(u'Apply BCF...')
        menuItem = wx.MenuItem(menu,self.id,self.dispName)
        menu.AppendItem(menuItem)

    def Execute(self,event):
        #--Generate default filename from BCF filename
        result = self.converter.fullPath.sbody[:-4]
        #--List source archives
        message = _(u'Using:')+u'\n* '
        message += u'\n* '.join(sorted(u'(%08X) - %s' % (x,self.data.crc_installer[x].archive) for x in self.converter.srcCRCs)) + u'\n'
        #--Confirm operation
        result = balt.askText(self.gTank,message,self.title,result + bosh.defaultExt)
        result = (result or u'').strip()
        if not result: return
        #--Error checking
        destArchive = GPath(result).tail
        if not destArchive.s:
            balt.showWarning(self.gTank,_(u'%s is not a valid archive name.') % result)
            return
        if destArchive.cext not in bosh.writeExts:
            balt.showWarning(self.gTank,_(u'The %s extension is unsupported. Using %s instead.') % (destArchive.cext, bosh.defaultExt))
            destArchive = GPath(destArchive.sroot + bosh.defaultExt).tail
        if destArchive in self.data:
            if not balt.askYes(self.gTank,_(u'%s already exists. Overwrite it?') % destArchive.s,self.title,False): return
        with balt.Progress(_(u'Converting to Archive...'),u'\n'+u' '*60) as progress:
            #--Perform the conversion
            self.converter.apply(destArchive,self.data.crc_installer,SubProgress(progress,0.0,0.99))
            if not self.converter.hasBCF:
                deprint(u'An error occued while attempting to apply an Auto-BCF:',traceback=True)
                balt.showWarning(self.gTank,
                    _(u'%s: An error occured while applying an Auto-BCF.' %
                      (destArchive.s)))
                # hasBCF will be set to False if there is an error while rearranging files
                return
            #--Add the new archive to Bash
            if destArchive not in self.data:
                self.data[destArchive] = bosh.InstallerArchive(destArchive)
            #--Apply settings from the BCF to the new InstallerArchive
            iArchive = self.data[destArchive]
            self.converter.applySettings(iArchive)
            #--Refresh UI
            pArchive = bosh.dirs['installers'].join(destArchive)
            iArchive.refreshed = False
            iArchive.refreshBasic(pArchive,SubProgress(progress,0.99,1.0),True)
            if iArchive.order == -1:
                lastInstaller = self.data[self.selected[-1]]
                self.data.moveArchives([destArchive],lastInstaller.order+1)
            self.data.refresh(what='I')
            self.gTank.RefreshUI()

#------------------------------------------------------------------------------
class InstallerConverter_ApplyEmbedded(InstallerLink):
    def AppendToMenu(self,menu,window,data):
        InstallerLink.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Embedded BCF'))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        name = self.selected[0]
        archive = self.data[name]

        #--Ask for an output filename
        destArchive = balt.askText(self.gTank,_(u'Output file:'),_(u'Apply BCF...'),name.stail)
        destArchive = (destArchive if destArchive else u'').strip()
        if not destArchive: return
        destArchive = GPath(destArchive)

        #--Error checking
        if not destArchive.s:
            balt.showWarning(self.gTank,_(u'%s is not a valid archive name.') % result)
            return
        if destArchive.cext not in bosh.writeExts:
            balt.showWarning(self.gTank,_(u'The %s extension is unsupported. Using %s instead.') % (destArchive.cext, bosh.defaultExt))
            destArchive = GPath(destArchive.sroot + bosh.defaultExt).tail
        if destArchive in self.data:
            if not balt.askYes(self.gTank,_(u'%s already exists. Overwrite it?') % destArchive.s,_(u'Apply BCF...'),False):
                return

        with balt.Progress(_(u'Extracting BCF...'),u'\n'+u' '*60) as progress:
            self.data.applyEmbeddedBCFs([archive],[destArchive],progress)
            iArchive = self.data[destArchive]
            if iArchive.order == -1:
                lastInstaller = self.data[self.selected[-1]]
                self.data.moveArchives([destArchive],lastInstaller.order+1)
            self.data.refresh(what='I')
            self.gTank.RefreshUI()

#------------------------------------------------------------------------------
class InstallerConverter_ConvertMenu(balt.MenuLink):
    """Apply BCF SubMenu."""
    def AppendToMenu(self,menu,window,data):
        subMenu = wx.Menu()
        menu.AppendMenu(-1,self.name,subMenu)
        linkSet = set()
        #--Converters are linked by CRC, not archive name
        #--So, first get all the selected archive CRCs
        selected = window.GetSelected()
        selectedCRCs = set(window.data[archive].crc for archive in selected)
        crcInstallers = set(window.data.crc_installer)
        srcCRCs = set(window.data.srcCRC_converters)
        #--There is no point in testing each converter unless
        #--every selected archive has an associated converter
        if selectedCRCs <= srcCRCs:
            #--List comprehension is faster than unrolling the for loops, but readability suffers
            #--Test every converter for every selected archive
            #--Only add a link to the converter if it uses all selected archives,
            #--and all of its required archives are available (but not necessarily selected)
            linkSet = set([converter for installerCRC in selectedCRCs for converter in window.data.srcCRC_converters[installerCRC] if selectedCRCs <= converter.srcCRCs <= crcInstallers])
##            for installerCRC in selectedCRCs:
##                for converter in window.data.srcCRC_converters[installerCRC]:
##                    if selectedCRCs <= converter.srcCRCs <= set(window.data.crc_installer): linkSet.add(converter)
        #--If the archive is a single archive with an embedded BCF, add that
        if len(selected) == 1 and window.data[selected[0]].hasBCF:
            newMenu = InstallerConverter_ApplyEmbedded()
            newMenu.AppendToMenu(subMenu,window,data)
        #--Disable the menu if there were no valid converters found
        elif not linkSet:
            id = menu.FindItem(self.name)
            menu.Enable(id,False)
        #--Otherwise add each link in alphabetical order, and
        #--indicate the number of additional, unselected archives
        #--that the converter requires
        for converter in sorted(linkSet,key=lambda x: x.fullPath.stail.lower()):
            numAsterisks = len(converter.srcCRCs - selectedCRCs)
            newMenu = InstallerConverter_Apply(converter,numAsterisks)
            newMenu.AppendToMenu(subMenu,window,data)

#------------------------------------------------------------------------------
class InstallerConverter_Create(InstallerLink):
    """Create BAIN conversion file."""

    def AppendToMenu(self,menu,window,data):
        InstallerLink.AppendToMenu(self,menu,window,data)
        self.title = _(u'Create BCF...')
        menuItem = wx.MenuItem(menu,self.id,_(u'Create...'))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        #--Generate allowable targets
        readTypes = u'*%s' % u';*'.join(bosh.readExts)
        #--Select target archive
        destArchive = balt.askOpen(self.gTank,_(u"Select the BAIN'ed Archive:"),
                                   self.data.dir,u'', readTypes,mustExist=True)
        if not destArchive: return
        #--Error Checking
        BCFArchive = destArchive = destArchive.tail
        if not destArchive.s or destArchive.cext not in bosh.readExts:
            balt.showWarning(self.gTank,_(u'%s is not a valid archive name.') % destArchive.s)
            return
        if destArchive not in self.data:
            balt.showWarning(self.gTank,_(u'%s must be in the Bash Installers directory.') % destArchive.s)
            return
        if BCFArchive.csbody[-4:] != u'-bcf':
            BCFArchive = GPath(BCFArchive.sbody + u'-BCF' + bosh.defaultExt).tail
        #--List source archives and target archive
        message = _(u'Convert:')
        message += u'\n* ' + u'\n* '.join(sorted(u'(%08X) - %s' % (self.data[x].crc,x.s) for x in self.selected))
        message += (u'\n\n'+_(u'To:')+u'\n* (%08X) - %s') % (self.data[destArchive].crc,destArchive.s) + u'\n'
        #--Confirm operation
        result = balt.askText(self.gTank,message,self.title,BCFArchive.s)
        result = (result or u'').strip()
        if not result: return
        #--Error checking
        BCFArchive = GPath(result).tail
        if not BCFArchive.s:
            balt.showWarning(self.gTank,_(u'%s is not a valid archive name.') % result)
            return
        if BCFArchive.csbody[-4:] != u'-bcf':
            BCFArchive = GPath(BCFArchive.sbody + u'-BCF' + BCFArchive.cext).tail
        if BCFArchive.cext != bosh.defaultExt:
            balt.showWarning(self.gTank,_(u"BCF's only support %s. The %s extension will be discarded.") % (bosh.defaultExt, BCFArchive.cext))
            BCFArchive = GPath(BCFArchive.sbody + bosh.defaultExt).tail
        if bosh.dirs['converters'].join(BCFArchive).exists():
            if not balt.askYes(self.gTank,_(u'%s already exists. Overwrite it?') % BCFArchive.s,self.title,False): return
            #--It is safe to removeConverter, even if the converter isn't overwritten or removed
            #--It will be picked back up by the next refresh.
            self.data.removeConverter(BCFArchive)
        destInstaller = self.data[destArchive]
        blockSize = None
        if destInstaller.isSolid:
            blockSize = balt.askNumber(self.gTank,u'mb',
                _(u'Use what maximum size for each solid block?')
                + u'\n' +
                _(u"Enter '0' to use 7z's default size."),
                self.title,destInstaller.blockSize or 0,0,102400)
        progress = balt.Progress(_(u'Creating %s...') % BCFArchive.s,u'\n'+u' '*60)
        log = None
        try:
            #--Create the converter
            converter = bosh.InstallerConverter(self.selected, self.data, destArchive, BCFArchive, blockSize, progress)
            #--Add the converter to Bash
            self.data.addConverter(converter)
            #--Refresh UI
            self.data.refresh(what='C')
            #--Generate log
            log = bolt.LogFile(StringIO.StringIO())
            log.setHeader(u'== '+_(u'Overview')+u'\n')
##            log('{{CSS:wtxt_sand_small.css}}')
            log(u'. '+_(u'Name')+u': '+BCFArchive.s)
            log(u'. '+_(u'Size')+u': %s KB'%formatInteger(converter.fullPath.size/1024))
            log(u'. '+_(u'Remapped')+u': %s'%formatInteger(len(converter.convertedFiles))+(_(u'file'),_(u'files'))[len(converter.convertedFiles) > 1])
            log.setHeader(u'. '+_(u'Requires')+u': %s'%formatInteger(len(converter.srcCRCs))+(_(u'file'),_(u'files'))[len(converter.srcCRCs) > 1])
            log(u'  * '+u'\n  * '.join(sorted(u'(%08X) - %s' % (x, self.data.crc_installer[x].archive) for x in converter.srcCRCs if x in self.data.crc_installer)))
            log.setHeader(u'. '+_(u'Options:'))
            log(u'  * '+_(u'Skip Voices')+u'   = %s'%bool(converter.skipVoices))
            log(u'  * '+_(u'Solid Archive')+u' = %s'%bool(converter.isSolid))
            if converter.isSolid:
                if converter.blockSize:
                    log(u'    *  '+_(u'Solid Block Size')+u' = %d'%converter.blockSize)
                else:
                    log(u'    *  '+_(u'Solid Block Size')+u' = 7z default')
            log(u'  *  '+_(u'Has Comments')+u'  = %s'%bool(converter.comments))
            log(u'  *  '+_(u'Has Extra Directories')+u' = %s'%bool(converter.hasExtraData))
            log(u'  *  '+_(u'Has Esps Unselected')+u'   = %s'%bool(converter.espmNots))
            log(u'  *  '+_(u'Has Packages Selected')+u' = %s'%bool(converter.subActives))
            log.setHeader(u'. '+_(u'Contains')+u': %s'%formatInteger(len(converter.missingFiles))+ (_(u'file'),_(u'files'))[len(converter.missingFiles) > 1])
            log(u'  * '+u'\n  * '.join(sorted(u'%s' % (x) for x in converter.missingFiles)))
        finally:
            progress.Destroy()
            if log:
                balt.showLog(self.gTank, log.out.getvalue(), _(u'BCF Information'))

#------------------------------------------------------------------------------
class InstallerConverter_MainMenu(balt.MenuLink):
    """Main BCF Menu"""
    def AppendToMenu(self,menu,window,data):
        subMenu = wx.Menu()
        menu.AppendMenu(-1,self.name,subMenu)
        #--Only enable the menu and append the subMenu's if all of the selected items are archives
        for item in window.GetSelected():
            if not isinstance(window.data[item],bosh.InstallerArchive):
                id = menu.FindItem(self.name)
                menu.Enable(id,False)
                break
        else:
            for link in self.links:
                link.AppendToMenu(subMenu,window,data)

# Mods Links ------------------------------------------------------------------
class Mods_ReplacersData:
    """Empty version of a now removed class. Here for compatibility with
    older settings files."""
    pass

class Mod_MergedLists_Data:
    """Empty version of a now removed class. Here for compatibility with
    older settings files."""
    pass

#------------------------------------------------------------------------------
class Mods_LoadListData(balt.ListEditorData):
    """Data capsule for load list editing dialog."""
    def __init__(self,parent):
        """Initialize."""
        self.data = settings['bash.loadLists.data']
        self.data['Bethesda ESMs'] = [
            GPath(x) for x in bush.game.masterFiles
            if x.lower() in bush.game.bethDataFiles
            ]
        #--GUI
        balt.ListEditorData.__init__(self,parent)
        self.showRename = True
        self.showRemove = True

    def getItemList(self):
        """Returns load list keys in alpha order."""
        return sorted(self.data.keys(),key=lambda a: a.lower())

    def rename(self,oldName,newName):
        """Renames oldName to newName."""
        #--Right length?
        if len(newName) == 0 or len(newName) > 64:
            balt.showError(self.parent,
                _(u'Name must be between 1 and 64 characters long.'))
            return False
        #--Rename
        settings.setChanged('bash.loadLists.data')
        self.data[newName] = self.data[oldName]
        del self.data[oldName]
        return newName

    def remove(self,item):
        """Removes load list."""
        settings.setChanged('bash.loadLists.data')
        del self.data[item]
        return True

#------------------------------------------------------------------------------
class Mods_LoadList:
    """Add load list links."""
    def __init__(self):
        self.data = settings['bash.loadLists.data']
        self.data['Bethesda ESMs'] = [
            GPath(x) for x in bush.game.masterFiles
            if x.lower() in bush.game.bethDataFiles
            ]

    def GetItems(self):
        items = self.data.keys()
        items.sort(lambda a,b: cmp(a.lower(),b.lower()))
        return items

    def SortWindow(self):
        self.window.PopulateItems()

    def AppendToMenu(self,menu,window,data):
        self.window = window
        menu.Append(ID_LOADERS.ALL,_(u'All'))
        menu.Append(ID_LOADERS.NONE,_(u'None'))
        menu.Append(ID_LOADERS.SAVE,_(u'Save List...'))
        menu.Append(ID_LOADERS.EDIT,_(u'Edit Lists...'))
        menu.AppendSeparator()
        for id,item in zip(ID_LOADERS,self.GetItems()):
            menu.Append(id,item)
        #--Disable Save?
        if not bosh.modInfos.ordered:
            menu.FindItemById(ID_LOADERS.SAVE).Enable(False)
        #--Events
        wx.EVT_MENU(bashFrame,ID_LOADERS.NONE,self.DoNone)
        wx.EVT_MENU(bashFrame,ID_LOADERS.ALL,self.DoAll)
        wx.EVT_MENU(bashFrame,ID_LOADERS.SAVE,self.DoSave)
        wx.EVT_MENU(bashFrame,ID_LOADERS.EDIT,self.DoEdit)
        wx.EVT_MENU_RANGE(bashFrame,ID_LOADERS.BASE,ID_LOADERS.MAX,self.DoList)

    def DoNone(self,event):
        """Unselect all mods."""
        bosh.modInfos.selectExact([])
        modList.RefreshUI()

    def DoAll(self,event):
        """Select all mods."""
        modInfos = bosh.modInfos
        try:
            # first select the bashed patch(es) and their masters
            for bashedPatch in [GPath(modName) for modName in modList.items if modInfos[modName].header.author in (u'BASHED PATCH',u'BASHED LISTS')]:
                if not modInfos.isSelected(bashedPatch):
                    modInfos.select(bashedPatch)
            # then activate mods that are not tagged NoMerge or Deactivate or Filter
            for mod in [GPath(modName) for modName in modList.items if modName not in modInfos.mergeable and u'Deactivate' not in modInfos[modName].getBashTags() and u'Filter' not in modInfos[modName].getBashTags()]:
                if not modInfos.isSelected(mod):
                    modInfos.select(mod)
            # then activate as many of the remaining mods as we can
            for mod in modInfos.mergeable:
                if u'Deactivate' in modInfos[mod].getBashTags(): continue
                if u'Filter' in modInfos[mod].getBashTags(): continue
                if not modInfos.isSelected(mod):
                    modInfos.select(mod)
        except bosh.PluginsFullError:
            balt.showError(self.window, _(u"Mod list is full, so some mods were skipped"), _(u'Select All'))
        modList.RefreshUI()

    def DoList(self,event):
        """Select mods in list."""
        item = self.GetItems()[event.GetId()-ID_LOADERS.BASE]
        selectList = [GPath(modName) for modName in self.data[item]]
        errorMessage = bosh.modInfos.selectExact(selectList)
        modList.RefreshUI()
        if errorMessage:
            balt.showError(self.window,errorMessage,item)

    def DoSave(self,event):
        #--No slots left?
        if len(self.data) >= (ID_LOADERS.MAX - ID_LOADERS.BASE + 1):
            balt.showError(self,_(u'All load list slots are full. Please delete an existing load list before adding another.'))
            return
        #--Dialog
        newItem = (balt.askText(self.window,_(u'Save current load list as:'),u'Wrye Bash') or u'').strip()
        if not newItem: return
        if len(newItem) > 64:
            message = _(u'Load list name must be between 1 and 64 characters long.')
            return balt.showError(self.window,message)
        self.data[newItem] = bosh.modInfos.ordered[:]
        settings.setChanged('bash.loadLists.data')

    def DoEdit(self,event):
        data = Mods_LoadListData(self.window)
        dialog = balt.ListEditor(self.window,-1,_(u'Load Lists'),data)
        dialog.ShowModal()
        dialog.Destroy()

#------------------------------------------------------------------------------
class INI_SortValid(BoolLink):
    """Sort valid INI Tweaks to the top."""
    def __init__(self): BoolLink.__init__(self,
                                          _(u'Valid Tweaks First'),
                                          'bash.ini.sortValid',
                                          _(u'Valid tweak files will be shown first.')
                                          )

    def Execute(self,event):
        BoolLink.Execute(self,event)
        iniList.RefreshUI()

#-------------------------------------------------------------------------------
class INI_AllowNewLines(BoolLink):
    """Consider INI Tweaks with new lines valid."""
    def __init__(self): BoolLink.__init__(self,
                                          _(u'Allow Tweaks with New Lines'),
                                          'bash.ini.allowNewLines',
                                          _(u'Tweak files with new lines are considered valid..')
                                          )

    def Execute(self,event):
        BoolLink.Execute(self,event)
        iniList.RefreshUI()

#-------------------------------------------------------------------------------
class INI_ListINIs(Link):
    """List errors that make an INI Tweak invalid."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'List Active INIs...'),_(u'Lists all fully applied tweak files.'))
        menu.AppendItem(menuItem)
        menuItem.Enable(True)

    def Execute(self,event):
        """Handle printing out the errors."""
        text = iniList.ListTweaks()
        if (wx.TheClipboard.Open()):
            wx.TheClipboard.SetData(wx.TextDataObject(text))
            wx.TheClipboard.Close()
        balt.showLog(self.window,text,_(u'Active INIs'),asDialog=False,fixedFont=False,icons=bashBlue)

#-------------------------------------------------------------------------------
class INI_ListErrors(Link):
    """List errors that make an INI Tweak invalid."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'List Errors...'),_(u'Lists any errors in the tweak file causing it to be invalid.'))
        menu.AppendItem(menuItem)

        bEnable = False
        for i in data:
            if bosh.iniInfos[i].getStatus() < 0:
                bEnable = True
                break
        menuItem.Enable(bEnable)

    def Execute(self,event):
        """Handle printing out the errors."""
        if (wx.TheClipboard.Open()):
            text = u''
            for i in self.data:
                fileInfo = bosh.iniInfos[i]
                text += u'%s\n' % fileInfo.listErrors()
            wx.TheClipboard.SetData(wx.TextDataObject(text))
            wx.TheClipboard.Close()
        balt.showLog(self.window,text,_(u'INI Tweak Errors'),asDialog=False,fixedFont=False,icons=bashBlue)

#------------------------------------------------------------------------------
class INI_FileOpenOrCopy(Link):
    """Open specified file(s) only if they aren't Bash supplied defaults."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        if not len(data) == 1:
            label = _(u'Open/Copy...')
            help = _(u'Only one INI file can be opened or copied at a time.')
        elif bosh.dirs['tweaks'].join(data[0]).isfile():
            label = _(u'Open...')
            help = _(u"Open '%s' with the system's default program.") % data[0]
        else:
            label = _(u'Copy...')
            help = _(u"Make an editable copy of the default tweak '%s'.") % data[0]
        menuItem = wx.MenuItem(menu,self.id,label,help)
        menu.AppendItem(menuItem)
        menuItem.Enable(len(self.data)>0 and len(data) == 1)

    def Execute(self,event):
        """Handle selection."""
        dir = self.window.data.dir
        for file in self.data:
            if bosh.dirs['tweaks'].join(file).isfile():
                dir.join(file).start()
            else:
                bosh.iniInfos[file].dir.join(file).copyTo(bosh.dirs['tweaks'].join(file))
                iniList.data.refresh()
                iniList.RefreshUI()

#------------------------------------------------------------------------------
class INI_Delete(Link):
    """Delete the file and all backups."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        if bosh.dirs['tweaks'].join(data[0]).isfile():
            menu.AppendItem(wx.MenuItem(menu,self.id,_(u'Delete'),
                help=_(u"Delete %(filename)s.") % ({'filename':data[0]})))
        else:
            menuItem = wx.MenuItem(menu,self.id,_(u'Delete'),
                help=_(u'Bash default tweaks can\'t be deleted.'))
            menu.AppendItem(menuItem)
            menuItem.Enable(False)

    def Execute(self,event):
        message = [u'',_(u'Uncheck files to skip deleting them if desired.')]
        message.extend(sorted(self.data))
        dialog = ListBoxes(self.window,_(u'Delete Files'),
                     _(u'Delete these files? This operation cannot be undone.'),
                     [message])
        if dialog.ShowModal() != wx.ID_CANCEL:
            id = dialog.ids[message[0]]
            checks = dialog.FindWindowById(id)
            if checks:
                for i,mod in enumerate(self.data):
                    if checks.IsChecked(i) and bosh.dirs['tweaks'].join(mod).isfile():
                        self.window.data.delete(mod)
            self.window.RefreshUI()
        dialog.Destroy()

#-------------------------------------------------------------------------------
class INI_Apply(Link):
    """Apply an INI Tweak."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        ini = self.window.GetParent().GetParent().GetParent().comboBox.GetValue()
        tweak = data[0]
        menuItem = wx.MenuItem(menu,self.id,_(u'Apply'),_(u"Applies '%s' to '%s'.") % (tweak, ini))
        menu.AppendItem(menuItem)

        if not settings['bash.ini.allowNewLines']:
            for i in data:
                iniInfo = bosh.iniInfos[i]
                if iniInfo.status < 0:
                    menuItem.Enable(False) # temp disabled for testing
                    return

    def Execute(self,event):
        """Handle applying INI Tweaks."""
        #-- If we're applying to Oblivion.ini, show the warning
        iniPanel = self.window.GetParent().GetParent().GetParent()
        choice = iniPanel.GetChoice().tail
        if choice in bush.game.iniFiles:
            message = (_(u'Apply an ini tweak to %s?') % choice
                       + u'\n\n' +
                       _(u'WARNING: Incorrect tweaks can result in CTDs and even damage to your computer!')
                       )
            if not balt.askContinue(self.window,message,'bash.iniTweaks.continue',_(u'INI Tweaks')):
                return
        needsRefresh = False
        for item in self.data:
            #--No point applying a tweak that's already applied
            if bosh.iniInfos[item].status == 20: continue
            needsRefresh = True
            if bosh.dirs['tweaks'].join(item).isfile():
                iniList.data.ini.applyTweakFile(bosh.dirs['tweaks'].join(item))
            else:
                iniList.data.ini.applyTweakFile(bosh.dirs['defaultTweaks'].join(item))
        if needsRefresh:
            #--Refresh status of all the tweaks valid for this ini
            iniList.RefreshUI('VALID')
            iniPanel.iniContents.RefreshUI()
            iniPanel.tweakContents.RefreshUI(self.data[0])

#------------------------------------------------------------------------------
class INI_CreateNew(Link):
    """Create a new INI Tweak using the settings from the tweak file, but values from the target INI."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        ini = self.window.GetParent().GetParent().GetParent().comboBox.GetValue()
        tweak = data[0]
        menuItem = wx.MenuItem(menu,self.id,_(u'Create Tweak with current settings...'),_(u"Creates a new tweak based on '%s' but with values from '%s'.") % (tweak, ini))
        menu.AppendItem(menuItem)
        if len(data) != 1 or bosh.iniInfos[data[0]].status < 0:
            menuItem.Enable(False)

    def Execute(self,event):
        """Handle creating a new INI tweak."""
        pathFrom = self.data[0]
        fileName = pathFrom.sbody + u' - Copy' + pathFrom.ext
        path = balt.askSave(self.window,_(u'Copy Tweak with current settings...'),bosh.dirs['tweaks'],fileName,_(u'INI Tweak File (*.ini)|*.ini'))
        if not path: return
        bosh.iniInfos[pathFrom].dir.join(pathFrom).copyTo(path)
        # Now edit it with the values from the target INI
        iniList.data.refresh()
        oldTarget = iniList.data.ini
        target = bosh.BestIniFile(path)
        settings,deleted = target.getSettings()
        new_settings,deleted = oldTarget.getSettings()
        deleted = {}
        for section in settings:
            if section in new_settings:
                for setting in settings[section]:
                    if setting in new_settings[section]:
                        settings[section][setting] = new_settings[section][setting]
        target.saveSettings(settings)
        iniList.RefreshUI(detail=path)
        self.window.GetParent().GetParent().GetParent().tweakContents.RefreshUI(path.tail)

#------------------------------------------------------------------------------
class Mods_EsmsFirst(Link):
    """Sort esms to the top."""
    def __init__(self,prefix=u''):
        Link.__init__(self)
        self.prefix = prefix

    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,self.prefix+_(u'Type'),_(u'Sort masters by type'),kind=wx.ITEM_CHECK)
        menu.AppendItem(menuItem)
        menuItem.Check(window.esmsFirst)

    def Execute(self,event):
        self.window.esmsFirst = not self.window.esmsFirst
        self.window.PopulateItems()

#------------------------------------------------------------------------------
class Mods_SelectedFirst(Link):
    """Sort loaded mods to the top."""
    def __init__(self,prefix=u''):
        Link.__init__(self)
        self.prefix = prefix

    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,self.prefix+_(u'Selection'),kind=wx.ITEM_CHECK)
        menu.AppendItem(menuItem)
        if window.selectedFirst: menuItem.Check()

    def Execute(self,event):
        self.window.selectedFirst = not self.window.selectedFirst
        self.window.PopulateItems()

#------------------------------------------------------------------------------
class Mods_ScanDirty(BoolLink):
    """Read mod CRC's to check for dirty mods."""
    def __init__(self): BoolLink.__init__(self,
                                          _(u"Check mods against BOSS's dirty mod list"),
                                          'bash.mods.scanDirty',
                                          )

    def Execute(self,event):
        BoolLink.Execute(self,event)
        self.window.PopulateItems()

#------------------------------------------------------------------------------
class Mods_AutoGhost(BoolLink):
    """Toggle Auto-ghosting."""
    def __init__(self): BoolLink.__init__(self,
                                          _(u'Auto-Ghost'),
                                          'bash.mods.autoGhost',
                                          )

    def Execute(self,event):
        BoolLink.Execute(self,event)
        files = bosh.modInfos.autoGhost(True)
        self.window.RefreshUI(files)

#------------------------------------------------------------------------------
class Mods_AutoGroup(BoolLink):
    """Turn on autogrouping."""
    def __init__(self): BoolLink.__init__(self,
                                          _(u'Auto Group (Deprecated -- Please use BOSS instead)'),
                                          'bash.balo.autoGroup',
                                          )

    def Execute(self,event):
        BoolLink.Execute(self,event)
        bosh.modInfos.updateAutoGroups()

#------------------------------------------------------------------------------
class Mods_Deprint(Link):
    """Turn on deprint/delist."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Debug Mode'),kind=wx.ITEM_CHECK,
            help=_(u"Turns on extra debug prints to help debug an error or just for advanced testing."))
        menu.AppendItem(menuItem)
        menuItem.Check(bolt.deprintOn)

    def Execute(self,event):
        deprint(_(u'Debug Printing: Off'))
        bolt.deprintOn = not bolt.deprintOn
        deprint(_(u'Debug Printing: On'))

#------------------------------------------------------------------------------
class Mods_FullBalo(BoolLink):
    """Turn Full Balo off/on."""
    def __init__(self): BoolLink.__init__(self,
                                          _(u'Full Balo (Deprecated -- Please use BOSS instead)'),
                                          'bash.balo.full',
                                          )

    def Execute(self,event):
        if not settings[self.key]:
            message = (_(u'Activate Full Balo?')
                       + u'\n\n' +
                       _(u'Full Balo segregates mods by groups, and then autosorts mods within those groups by alphabetical order.  Full Balo is still in development and may have some rough edges.')
                       )
            if balt.askContinue(self.window,message,'bash.balo.full.continue',_(u'Balo Groups')):
                dialog = Mod_BaloGroups_Edit(self.window)
                dialog.ShowModal()
                dialog.Destroy()
            return
        else:
            settings[self.key] = False
            bosh.modInfos.fullBalo = False
            bosh.modInfos.refresh(doInfos=False)

#------------------------------------------------------------------------------
class Mods_DumpTranslator(Link):
    """Dumps new translation key file using existing key, value pairs."""
    def AppendToMenu(self,menu,window,data):
        if not hasattr(sys,'frozen'):
            # Can't dump the strings if the files don't exist.
            Link.AppendToMenu(self,menu,window,data)
            menuItem = wx.MenuItem(menu,self.id,_(u'Dump Translator'),
                help=_(u"Generate a new version of the translator file for your locale."))
            menu.AppendItem(menuItem)

    def Execute(self,event):
        message = (_(u'Generate Bash program translator file?')
                   + u'\n\n' +
                   _(u'This function is for translating Bash itself (NOT mods) into non-English languages.  For more info, see Internationalization section of Bash readme.')
                   )
        if not balt.askContinue(self.window,message,'bash.dumpTranslator.continue',_(u'Dump Translator')):
            return
        language = bass.language if bass.language else locale.getlocale()[0].split('_',1)[0]
        outPath = bosh.dirs['l10n']
        files = [GPath(u'bash').join(x+u'.py').s for x in (u'bolt',
                                                           u'balt',
                                                           u'bush',
                                                           u'bosh',
                                                           u'bash',
                                                           u'basher',
                                                           u'bashmon',
                                                           u'belt',
                                                           u'bish',
                                                           u'barg',
                                                           u'barb',
                                                           u'bass',
                                                           u'cint',
                                                           u'ScriptParser')]
        with balt.BusyCursor():
            outFile = bolt.dumpTranslator(outPath.s,language,*files)
        balt.showOk(self.window,
            _(u'Translation keys written to ')+u'Mopy\\bash\\l10n\\'+outFile,
            _(u'Dump Translator')+u': '+outPath.stail)

#------------------------------------------------------------------------------
class Mods_ListMods(Link):
    """Copies list of mod files to clipboard."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u"List Mods..."),
            help=_(u"Copies list of active mod files to clipboard."))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        #--Get masters list
        text = bosh.modInfos.getModList(showCRC=wx.GetKeyState(67))
        if (wx.TheClipboard.Open()):
            wx.TheClipboard.SetData(wx.TextDataObject(text))
            wx.TheClipboard.Close()
        balt.showLog(self.window,text,_(u"Active Mod Files"),asDialog=False,fixedFont=False,icons=bashBlue)

#------------------------------------------------------------------------------
class Mods_ListBashTags(Link):
    """Copies list of bash tags to clipboard."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u"List Bash Tags..."),
            help=_(u"Copies list of bash tags to clipboard."))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        #--Get masters list
        text = bosh.modInfos.getTagList()
        if (wx.TheClipboard.Open()):
            wx.TheClipboard.SetData(wx.TextDataObject(text))
            wx.TheClipboard.Close()
        balt.showLog(self.window,text,_(u"Bash Tags"),asDialog=False,fixedFont=False,icons=bashBlue)

#------------------------------------------------------------------------------
class Mods_LockTimes(Link):
    """Turn on resetMTimes feature."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Lock Load Order'),kind=wx.ITEM_CHECK,
            help=_(u"Will reset mod Load Order to whatever Wrye Bash has saved for them whenever Wrye Bash refreshs data/starts up."))
        menu.AppendItem(menuItem)
        menuItem.Check(bosh.modInfos.lockLO)

    def Execute(self,event):
        lockLO = not bosh.modInfos.lockLO
        if not lockLO: bosh.modInfos.mtimes.clear()
        settings['bosh.modInfos.resetMTimes'] = bosh.modInfos.lockLO = lockLO
        bosh.modInfos.refresh(doInfos=False)
        modList.RefreshUI()

#------------------------------------------------------------------------------
class Mods_OblivionVersion(Link):
    """Specify/set Oblivion version."""
    def __init__(self,key,setProfile=False):
        Link.__init__(self)
        self.key = key
        self.setProfile = setProfile

    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,self.key,kind=wx.ITEM_CHECK)
        menu.AppendItem(menuItem)
        menuItem.Enable(bosh.modInfos.voCurrent != None and self.key in bosh.modInfos.voAvailable)
        if bosh.modInfos.voCurrent == self.key: menuItem.Check()

    def Execute(self,event):
        """Handle selection."""
        if bosh.modInfos.voCurrent == self.key: return
        bosh.modInfos.setOblivionVersion(self.key)
        bosh.modInfos.refresh()
        modList.RefreshUI()
        if self.setProfile:
            bosh.saveInfos.profiles.setItem(bosh.saveInfos.localSave,'vOblivion',self.key)
        bashFrame.SetTitle()

#------------------------------------------------------------------------------
class Mods_Tes4ViewExpert(BoolLink):
    """Toggle Tes4Edit expert mode (when launched via Bash)."""
    def __init__(self): BoolLink.__init__(self,
                                          _(u'Tes4Edit Expert'),
                                          'tes4View.iKnowWhatImDoing',
                                          )

#------------------------------------------------------------------------------
class Mods_BOSSDisableLockTimes(BoolLink):
    """Toggle Lock Load Order disabling when launching BOSS through Bash."""
    def __init__(self): BoolLink.__init__(self,
                                          _(u'BOSS Disable Lock Load Order'),
                                          'BOSS.ClearLockTimes',
                                          _(u"If selected, will temporarily disable Bash's Lock Load Order when running BOSS through Bash.")
                                          )

#------------------------------------------------------------------------------
class Mods_BOSSLaunchGUI(Link):
    """If BOSS.exe is available then BOSS GUI.exe should be too."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Launch BOSS GUI'),
            help=_(u"Launch BOSS GUI to change settings or update the user rules list."))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        exePath = bosh.dirs['boss'].join(u'BOSS GUI.exe')
        if not exePath.exists(): return
        args = [exePath.s]
        statusBar.SetStatusText(u' '.join(args[1:]),1)
        cwd = bolt.Path.getcwd()
        exePath.head.setcwd()
        try:
            subprocess.Popen(args, close_fds=bolt.close_fds) #close_fds is needed for the one instance checker
        except Exception, error:
            balt.showError(
                bashFrame,
                (u'%s'%error + u'\n\n' +
                 _(u'Used Path: ') + self.exePath.s + u'\n' +
                 _(u'Used Arguments: ') + u'%s' % self.exeArgs),
                 _(u"Could not launch '%s'") % self.exePath.stail)
        finally:
            cwd.setcwd()

# Settings Links --------------------------------------------------------------
#------------------------------------------------------------------------------
class Settings_BackupSettings(Link):
    """Saves Bash's settings and user data.."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Backup Settings...'),
            help=_(u"Backup all of Wrye Bash's settings/data to an archive file."),
            kind=wx.ITEM_CHECK)
        menu.AppendItem(menuItem)

    def Execute(self,event):
        def OnClickAll(event):
            dialog.EndModal(2)
        def OnClickNone(event):
            dialog.EndModal(1)
        def PromptConfirm(msg=None):
            msg = msg or _(u'Do you want to backup your Bash settings now?')
            return balt.askYes(bashFrame,msg,_(u'Backup Bash Settings?'))

        BashFrame.SaveSettings(bashFrame)
        #backup = barb.BackupSettings(bashFrame)
        try:
            if PromptConfirm():
                dialog = wx.Dialog(bashFrame,wx.ID_ANY,_(u'Backup Images?'),size=(400,200),style=wx.DEFAULT_DIALOG_STYLE|wx.RESIZE_BORDER)
                icon = wx.StaticBitmap(dialog,wx.ID_ANY,wx.ArtProvider_GetBitmap(wx.ART_WARNING,wx.ART_MESSAGE_BOX, (32,32)))
                sizer = vSizer(
                    (hSizer(
                        (icon,0,wx.ALL,6),
                        (staticText(dialog,_(u'Do you want to backup any images?'),style=wx.ST_NO_AUTORESIZE),1,wx.EXPAND|wx.LEFT,6),
                        ),1,wx.EXPAND|wx.ALL,6),
                    (hSizer(
                        spacer,
                        button(dialog,label=_(u'Backup All Images'),onClick=OnClickAll),
                        (button(dialog,label=_(u'Backup Changed Images'),onClick=OnClickNone),0,wx.LEFT,4),
                        (button(dialog,id=wx.ID_CANCEL,label=_(u'None')),0,wx.LEFT,4),
                        ),0,wx.EXPAND|wx.LEFT|wx.RIGHT|wx.BOTTOM,6),
                    )
                dialog.SetSizer(sizer)
                backup = barb.BackupSettings(bashFrame,backup_images=dialog.ShowModal())
                backup.Apply()
        except StateError:
            backup.WarnFailed()
        except barb.BackupCancelled:
            pass
        #end try
        backup = None

#------------------------------------------------------------------------------
class Settings_RestoreSettings(Link):
    """Saves Bash's settings and user data.."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Restore Settings...'),
            help=_(u"Restore all of Wrye Bash's settings/data from a backup archive file."),
            kind=wx.ITEM_CHECK)
        menu.AppendItem(menuItem)

    def Execute(self,event):
        try:
            backup = barb.RestoreSettings(bashFrame)
            if backup.PromptConfirm():
                backup.restore_images = balt.askYes(bashFrame,
                    _(u'Do you want to restore saved images as well as settings?'),
                    _(u'Restore Settings'))
                backup.Apply()
        except barb.BackupCancelled: #cancelled
            pass
        #end try
        backup = None

#------------------------------------------------------------------------------
class Settings_SaveSettings(Link):
    """Saves Bash's settings and user data."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Save Settings'),
            help=_(u"Save all of Wrye Bash's settings/data now."),
            kind=wx.ITEM_CHECK)
        menu.AppendItem(menuItem)

    def Execute(self,event):
        BashFrame.SaveSettings(bashFrame)

#------------------------------------------------------------------------------
class Settings_ExportDllInfo(Link):
    """Exports list of good and bad dll's."""
    def AppendToMenu(self,menu,window,data):
        if not bush.game.se_sd: return
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,
            _(u"Export list of allowed/disallowed %s plugin dlls") % bush.game.se_sd,
            _(u"Export list of allowed/disallowed plugin dlls to a txt file (for BAIN)."))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        textDir = bosh.dirs['patches']
        textDir.makedirs()
        #--File dialog
        textPath = balt.askSave(self.window,
            _(u'Export list of allowed/disallowed %s plugin dlls to:') % bush.game.se_sd,
            textDir, bush.game.se.shortName+u' '+_(u'dll permissions')+u'.txt',
            u'*.txt')
        if not textPath: return
        with textPath.open('w',encoding='utf-8-sig') as out:
            out.write(u'goodDlls '+_(u'(those dlls that you have chosen to allow to be installed)')+u'\r\n')
            if settings['bash.installers.goodDlls']:
                for dll in settings['bash.installers.goodDlls']:
                    out.write(u'dll:'+dll+u':\r\n')
                    for index, version in enumerate(settings['bash.installers.goodDlls'][dll]):
                        out.write(u'version %02d: %s\r\n' % (index, version))
            else: out.write(u'None\r\n')
            out.write(u'badDlls '+_(u'(those dlls that you have chosen to NOT allow to be installed)')+u'\r\n')
            if settings['bash.installers.badDlls']:
                for dll in settings['bash.installers.badDlls']:
                    out.write(u'dll:'+dll+u':\r\n')
                    for index, version in enumerate(settings['bash.installers.badDlls'][dll]):
                        out.write(u'version %02d: %s\r\n' % (index, version))
            else: out.write(u'None\r\n')

#------------------------------------------------------------------------------
class Settings_ImportDllInfo(Link):
    """Imports list of good and bad dll's."""
    def AppendToMenu(self,menu,window,data):
        if not bush.game.se_sd: return
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,
            _(u"Import list of allowed/disallowed %s plugin dlls") % bush.game.se_sd,
            help=_(u"Import list of allowed/disallowed plugin dlls from a txt file (for BAIN)."))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        textDir = bosh.dirs['patches']
        textDir.makedirs()
        #--File dialog
        textPath = balt.askOpen(self.window,
            _(u'Import list of allowed/disallowed %s plugin dlls from:') % bush.game.se_sd,
            textDir, bush.game.se.shortName+u' '+_(u'dll permissions')+u'.txt',
            u'*.txt',mustExist=True)
        if not textPath: return
        message = (_(u'Merge permissions from file with current dll permissions?')
                   + u'\n' +
                   _(u"('No' Replaces current permissions instead.)")
                   )
        if not balt.askYes(self.window,message,_(u'Merge permissions?')): replace = True
        else: replace = False
        try:
            with textPath.open('r',encoding='utf-8-sig') as ins:
                Dlls = {'goodDlls':{},'badDlls':{}}
                for line in ins:
                    line = line.strip()
                    if line.startswith(u'goodDlls'):
                        current = Dlls['goodDlls']
                    if line.startswith(u'badDlls'):
                        current = Dlls['badDlls']
                    elif line.startswith(u'dll:'):
                        dll = line[4:-1]
                        current.setdefault(dll,[])
                    elif line.startswith(u'version'):
                        ver = line[13:-1].strip(u"'").split(u',')
                        current[dll].append([ver[0].strip(u"'"),long(ver[1]),long(ver[2])])
            if not replace:
                settings['bash.installers.goodDlls'].update(Dlls['goodDlls'])
                settings['bash.installers.badDlls'].update(Dlls['badDlls'])
            else:
                settings['bash.installers.goodDlls'], settings['bash.installers.badDlls'] = Dlls['goodDlls'], Dlls['badDlls']
        except UnicodeError:
            balt.showError(self.window,_(u'Wrye Bash could not load %s, because it is not saved in UTF-8 format.  Please resave it in UTF-8 format and try again.') % textPath.s)
        except Exception as e:
            deprint(u'Error reading', textPath.s, traceback=True)
            balt.showError(self.window,_(u'Wrye Bash could not load %s, because there was an error in the format of the file.') % textPath.s)

#------------------------------------------------------------------------------
class Settings_Colors(Link):
    """Shows the color configuration dialog."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Colors...'),
            help=_(u"Configure the custom colors used in the UI."))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        dialog = ColorDialog(bashFrame)
        dialog.ShowModal()
        dialog.Destroy()

#------------------------------------------------------------------------------
class UpdateDialog(wx.Dialog):
    CHECK_INDENT = 20
    GROUP_SPACING = 5
    ITEM_SPACING = 2

    def __init__(self,parent,title,updates):
        wx.Dialog.__init__(self,parent,wx.ID_ANY,title)
        self.SetIcons(bashBlue)
        versions = sorted(updates.keys(),reverse=True)
        #--Controls
        controls = []
        sizer = balt.vSizer(
            (balt.staticText(self,balt.fill(
                _(u"The following updates are available for Wrye Bash.  Please select which updates you would like to install, and click 'OK' to update Wrye Bash, or download the files manually and install them yourself."),
                70)
                ),0,wx.ALL,10),
            )
        itemSizer = wx.FlexGridSizer(
            (sum(len(updates[x][y]) for y in ('programs','definitions','languages') for x in versions)),
            3,self.ITEM_SPACING,self.ITEM_SPACING)
        itemSizer.AddGrowableCol(0)
        itemSizer.AddGrowableCol(1)
        itemSizer.AddGrowableCol(2)

        sbSizer = balt.vsbSizer((self,wx.ID_ANY,_(u'Updates')),
                                (itemSizer,2,wx.GROW|wx.ALL,5))
        sizer.Add(sbSizer,2,wx.GROW|wx.ALL,5)
        buttonSizer = self.CreateStdDialogButtonSizer(wx.OK|wx.CANCEL)
        self.askCheck = balt.checkBox(self,_(u'Always update to the latest version'))
        self.askCheck.SetValue(settings['bash.update.dontAsk'])
        sizer.Add(hSizer(
            (self.askCheck,0,wx.ALIGN_CENTER_VERTICAL|wx.LEFT,5),
            ((0,0),1,wx.GROW),
            (buttonSizer,0,wx.ALIGN_RIGHT),
            ),0,wx.GROW|wx.ALL^wx.TOP,5)

        self.allRadios = allRadios = []
        class radioWithChecks(wx.RadioButton):
            """Radio button that enables/disabled associated checkbuttons"""
            def __init__(self,checks,*args,**kwdargs):
                wx.RadioButton.__init__(self,*args,**kwdargs)
                self.checks = checks
                self.Bind(wx.EVT_RADIOBUTTON,self.OnRadio)

            def OnRadio(self,event):
                for radio,version in allRadios:
                    radio._OnRadio()
                event.Skip()

            def _OnRadio(self):
                parent = self.GetParent()
                for id in self.checks:
                    check = parent.FindWindowById(id[0])
                    if check: check.Enable(self.GetValue())
        class specialCheck(wx.CheckBox):
            """Check box that enables/disables associated checkbutton"""
            def __init__(self,check,*args,**kwdargs):
                wx.CheckBox.__init__(self,*args,**kwdargs)
                self.check = check
                self.oldValue = False
                self.Bind(wx.EVT_CHECKBOX,self.OnCheck)

            def OnCheck(self,event):
                enabled = not self.GetValue()
                self.check.Enable(enabled)
                if not enabled:
                    self.oldValue = self.check.GetValue()
                    self.check.SetValue(False)
                else:
                    self.check.SetValue(self.oldValue)
                event.Skip()

        first = True
        for version in versions:
            version_updates = updates[version]
            name = version_updates['name']
            url = version_updates['url']
            programs = version_updates['programs']
            definitions = version_updates['definitions']
            languages = version_updates['languages']

            if ((not bool(programs) and version != settings['bash.version']) or
                (not programs and not definitions and not languages)):
                continue
            ids = []
            radio = radioWithChecks(ids,self,wx.ID_ANY,name)
            radio.SetValue(first)
            if url:
                link = wx.HyperlinkCtrl(self,wx.ID_ANY,_(u'Download Page'),url)
                link.SetToolTip(balt.tooltip(u'https://sourceforge.net/projects/oblivionworks/'))
            else:
                link = (0,0)
            border = 0 if first else self.GROUP_SPACING-self.ITEM_SPACING
            itemSizer.Add(radio,0,wx.TOP,border)
            itemSizer.Add((0,0))
            itemSizer.Add(link,0,wx.ALIGN_RIGHT,0)

            for program in programs:
                check = balt.checkBox(self,program[0])
                check.Enable(False)
                subSizer = hSizer((check,0,wx.LEFT,self.CHECK_INDENT-self.ITEM_SPACING))
                if program[2]:
                    link = wx.HyperlinkCtrl(self,wx.ID_ANY,_(u'Manual Download'),program[2])
                    link.SetToolTip(balt.tooltip(u'https://sourceforge.net/projects/oblivionworks/'))
                    subSizer.Add((0,0),1,wx.GROW,0)
                    subSizer.Add(link,0,wx.ALIGN_RIGHT,0)
                else:
                    link = (0,0)

                itemSizer.Add(check,0,wx.LEFT,self.CHECK_INDENT)
                itemSizer.Add((0,0))
                itemSizer.Add(link,0,wx.ALIGN_RIGHT)

                installerName = program[0].lower()
                if 'standalone' in installerName:
                    check.SetLabel(u'Standalone Executable')
                    if settings['bash.standalone']:
                        ids.append((check.GetId(),program))
                        check.Enable(first)
                        check.SetValue(True)
                elif 'python' in installerName:
                    check.SetLabel(u'Python Source')
                    if not settings['bash.standalone']:
                        ids.append((check.GetId(),program))
                        check.Enable(first)
                        check.SetValue(True)
                elif 'installer' in installerName:
                    check.SetLabel(u'Installer')

            for items,text,key in ((definitions,_(u'Game Definitions:'),'bash.update.defs'),
                                   (languages,_(u'Language Pack:'),'bash.update.lang')):
                firstUpdate = True
                for update in items:
                    date_rev = update[1]
                    date_rev = ' '+date_rev[1]+'-'+date_rev[2]+'-'+date_rev[0]+date_rev[3]
                    check = balt.checkBox(self,text+date_rev)
                    if version == settings['bash.version'] and GPath(update[0]) in settings[key]:
                        # It's an update for the user's current version, and it's already
                        # been applied
                        check.Enable(False)
                        check.SetValue(False)
                    else:
                        check.Enable(first)
                        check.SetValue(firstUpdate)
                        ids.append((check.GetId(),update))
                    if GPath(update[0]) not in settings[key]:
                        button = specialCheck(check,self,wx.ID_ANY,_(u'Mark as Installed'))
                        button.SetToolTip(tooltip(u'Check this if you have already installed this update manually, to make Wrye Bash ignore this update in the future.'))
                        button.Enable(first)
                        ids.append((button.GetId(),None))
                    else:
                        button = (0,0)
                    firstUpdate = False
                    link = wx.HyperlinkCtrl(self,wx.ID_ANY,_(u'Manual Download'),update[2])
                    link.SetToolTip(balt.tooltip(u'https://sourceforge.net/projects/oblivionworks/'))
                    itemSizer.Add(check,0,wx.LEFT,self.CHECK_INDENT)
                    itemSizer.Add(button)
                    itemSizer.Add(link,0,wx.ALIGN_RIGHT)
            radio.checks = ids
            radio.Enable(bool(ids))
            allRadios.append((radio,version))
            first = False
        self.SetSizer(sizer)
        sizer.SetSizeHints(self)

    def ShowModal(self):
        if settings['bash.update.dontAsk']: return wx.ID_OK
        ret = wx.Dialog.ShowModal(self)
        if ret == wx.ID_OK:
            settings['bash.update.dontAsk'] = self.askCheck.GetValue()
        return ret

    def GetSelections(self):
        """Call after return from Modal to get what updates were selected"""
        selections = {}
        for radio,version in self.allRadios:
            if radio.GetValue():
                # Found the active one
                for id in radio.checks:
                    check = self.FindWindowById(id[0])
                    if not check: continue
                    if not check.Enabled: continue
                    if not check.GetValue(): continue
                    update = id[1]
                    if update:
                        selections.setdefault(version,[]).append(update)
        return selections

    def GetInstalled(self):
        """Call after return from Modal to get what updats the user says are
           already installed."""
        selections = []
        for radio,version in self.allRadios:
            if radio.GetValue():
                for id in radio.checks:
                    check = self.FindWindowById(id[0])
                    if not check: continue
                    if not check.GetValue(): continue
                    update = id[1]
                    if update is None:
                        updateCheckId = check.check.GetId()
                        for updateId in radio.checks:
                            if updateId[0] == updateCheckId:
                                selections.append(updateId[1][0])
                                break
        return selections

class Settings_CheckForUpdates_DontAsk(BoolLink):
    def __init__(self):
        BoolLink.__init__(
            self,_(u'Always update to the latest version.'),
            'bash.update.dontAsk',
            _(u'Always download and install the latest updates from SourceForge when detected.'))

class Settings_CheckForUpdates_BackupSFX(BoolLink):
    def __init__(self):
        BoolLink.__init__(
            self,_(u'Create Self Extracting Backups'),
            'bash.update.backupSFX',
            _(u'Create self extracting archives when backups are made.'))

class Settings_CheckForUpdatesFrequency(Link):
    """Change how often Wrye Bash checks for updates automatically."""
    def __init__(self,freq='00-01-0000 00:00',text=_(u'Every Day')):
        Link.__init__(self)
        self.freq = freq
        self.text = text

    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,self.text,kind=wx.ITEM_RADIO)
        menu.AppendItem(menuItem)
        if settings['bash.update.frequency'] == self.freq:
            menuItem.Check(True)

    def Execute(self,event):
        settings['bash.update.frequency'] = self.freq
        # Reset the updater
        bashFrame.updater.Start()
        event.Skip()

class Settings_ResetUpdateData(Link):
    """Clears information about updates"""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Reset Update Information'),
                               _(u'This will reset information Wrye Bash stores about what updates have been installed.'))
        try:
            enable = bool(settings['bash.update.lang']|settings['bash.update.defs'])
        except:
            enable = True
        menu.AppendItem(menuItem)
        menuItem.Enable(enable)

    def Execute(self,event):
        msg = _(u'Remove the following updates from install history?')
        msg += u'\n\n'
        try:
            defs = settings['bash.update.defs']
            langs = settings['bash.update.lang']
            if defs or langs:
                msg += u'\n'.join(u' * '+x.s for x in sorted(defs))+u'\n'
                msg += u'\n'.join(u' * '+x.s for x in sorted(langs))+u'\n'
                msg += _(u'NOTE: The updates will not be removed, this will just reset tracking of these updates.')
            else:
                msg += u' * ' + _(u'None')
        except:
            deprint(u'An error occured while formatting a message about installed updates:',traceback=True)
            msg += u'\n * '+_(u'Unable to determine installed updates.')+u'\n\n'
            msg += _(u'NOTE: The updates will not be removed, this will just reset tracking of these updates.')
        msg += u'\n\n' + _(u'Clear install history?')
        if balt.askYes(self.window,msg,_(u'Reset Update Information')):
            settings['bash.update.defs'] = settingDefaults['bash.update.defs']
            settings['bash.update.lang'] = settingDefaults['bash.update.lang']

class Settings_CheckForUpdates(Link):
    """Checks SourceForge for newer versions."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        enable = bashFrame.updater.status is None
        title = bashFrame.updater.GetStatus()
        if not title:
            try:
                lastCheck = settings['bash.update.last']
                last = time.localtime(lastCheck)
                if lastCheck == 0:
                    when = _(u'Unknown')
                else:
                    now = time.localtime()
                    deltaYear = now.tm_year - last.tm_year
                    deltaDays = now.tm_yday - last.tm_yday
                    when = None
                    if deltaYear == 1:
                        deltaDays += 365
                    if deltaDays == 0:
                        deltaHours = now.tm_hour - last.tm_hour
                        if deltaHours == 0:
                            deltaMinutes = now.tm_min - last.tm_min
                            if deltaMinutes == 0:
                                deltaSeconds = now.tm_sec - last.tm_sec
                                if deltaSeconds == 1:
                                    when = _(u'%(seconds)s second ago')
                                else:
                                    when = _(u'%(seconds)s seconds ago')
                                when = when % ({'seconds':deltaSeconds})
                            else:
                                if deltaMinutes == 1:
                                    when = _(u'%(minutes)s minute ago')
                                else:
                                    when = _(u'%(minutes)s minutes ago')
                                when = when % ({'minutes':deltaMinutes})
                        else:
                            if deltaHours == 1:
                                when = _(u'%(hours)s hour ago')
                            else:
                                when = _(u'%(hours)s hours ago')
                            when = when % ({'hours':deltaHours})
                    elif deltaDays == 1:
                        when = _(u'Yesterday, %(time)s') % ({'time':bosh.formatDate(lastCheck)})
                    else:
                        when = bosh.formatDate(lastCheck)
            except:
                deprint(u'Error getting time of last update:',traceback=True)
                when = _(u'Unknown')
            title = _(u'Now (Last Check: %s)...') % when
        menuItem = wx.MenuItem(menu,self.id,title)
        menu.AppendItem(menuItem)
        menuItem.Enable(enable)

    def Execute(self,event):
        bashFrame.updater.InitiateUpdate(True)
        return

        if main:
            maxMain = max([x[1] for x in main])
        else:
            maxMain = (0,)
        beta = versions.get('optional files',[])
        if beta:
            maxBeta = max([x[1] for x in beta])
        else:
            maxBeta = (0,)
        currentStr = u'.'.join([u'%s'%x for x in currentVersion])
        mainStr = u'.'.join([u'%s'%x for x in maxMain])
        betaStr = u'.'.join([u'%s'%x for x in maxBeta])

        msg = None
        title = _(u'Check for updates')
        if currentVersion > maxMain:
            # User has a Beta/RC/SVN version
            if currentVersion > maxBeta:
                # SVN
                balt.showOk(self.window,
                    _(u"No new versions of Wrye Bash are available at TESNexus, however you appear to be using an SVN release (%s).  Be sure to check for updates with your SVN client.")
                    % currentStr,
                    title)
                return
            elif currentVersion == maxBeta:
                # Beta/RC, up to date
                balt.showOk(self.window,
                    _(u"Wrye Bash is currently up to date (%s).")
                    % currentStr,
                    title)
                return
            else: # currentVersion < maxBeta
                # Beta/RC, not up to date
                msg = (_(u"You appear to be using a Beta/RC release of Wrye Bash (%s).  A newer Beta/RC is available (%s).")
                       + u'\n\n' +
                       _(u'Would you like to visit TESNexus to download the Beta/RC version?')
                       ) % (currentStr,betaStr)
        elif currentVersion == maxMain:
            # User has current Stable version
            if currentVersion >= maxBeta:
                # And it's >= whatever Beta/RC is available
                balt.showOk(self.window,
                    _(u"Wrye Bash is currently up to date (%s).")
                    % currentStr,
                    title)
                return
            else: # currentVersion < maxBeta
                # But there's a 'better' Beta/RC available
                msg = (_(u"Wrye Bash is currently up to date (%s), but a newer Beta/RC is available (%s).")
                       + u'\n\n' +
                       _(u'Would you like to visit TESNexus to download the Beta/RC version?')
                       ) % (currentStr, betaStr)
        else: # currentVersion < maxMain
            # Using an older version
            if currentVersion < maxBeta and maxBeta > maxMain:
                # There's also a new Beta/RC available
                msg = (_(u"You are using an older version of Wrye Bash (%s).  There is a newer stable release (%s) and a newer Beta/RC release (%s).")
                       + u'\n\n' +
                       _(u'Would you like to visit TESNexus to download one of these versions?')
                       ) % (currentStr, mainStr, betaStr)
            else:
                msg = (_(u'You are using an older version of Wrye Bash (%s).  There is a newer stable release available (%s).')
                       + u'\n\n' +
                       _(u'Would you like to visit TESNexus to download the updated version?')
                       ) % (currentStr, mainStr)
        if msg:
            if balt.askYes(self.window,msg,title):
                os.startfile(u'http://oblivion.nexusmods.com/mods/22368')

#------------------------------------------------------------------------------
class Settings_Tab(Link):
    """Handle hiding/unhiding tabs."""
    def __init__(self,tabKey,canDisable=True):
        Link.__init__(self)
        self.tabKey = tabKey
        self.enabled = canDisable

    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        className,title,item = tabInfo.get(self.tabKey,[None,None,None])
        if title is None: return
        help = _(u"Show/Hide the %s Tab.") % title
        check = settings['bash.tabs'][self.tabKey]
        menuItem = wx.MenuItem(menu,self.id,title,kind=wx.ITEM_CHECK,help=help)
        menu.AppendItem(menuItem)
        menuItem.Check(check)
        menuItem.Enable(self.enabled)

    def Execute(self,event):
        if settings['bash.tabs'][self.tabKey]:
            # It was enabled, disable it.
            iMods = None
            iInstallers = None
            iDelete = None
            for i in range(bashFrame.notebook.GetPageCount()):
                pageTitle = bashFrame.notebook.GetPageText(i)
                if pageTitle == tabInfo['Mods'][1]:
                    iMods = i
                elif pageTitle == tabInfo['Installers'][1]:
                    iInstallers = i
                if pageTitle == tabInfo[self.tabKey][1]:
                    iDelete = i
            if iDelete == bashFrame.notebook.GetSelection():
                # We're deleting the current page...
                if ((iDelete == 0 and iInstallers == 1) or
                    (iDelete - 1 == iInstallers)):
                    # The auto-page change will change to
                    # the 'Installers' tab.  Change to the
                    # 'Mods' tab instead.
                    bashFrame.notebook.SetSelection(iMods)
            page = bashFrame.notebook.GetPage(iDelete)
            bashFrame.notebook.RemovePage(iDelete)
            page.Show(False)
        else:
            # It was disabled, enable it
            insertAt = 0
            for i,key in enumerate(settings['bash.tabs.order']):
                if key == self.tabKey: break
                if settings['bash.tabs'][key]:
                    insertAt = i+1
            className,title,panel = tabInfo[self.tabKey]
            if not panel:
                panel = globals()[className](bashFrame.notebook)
                tabInfo[self.tabKey][2] = panel
            if insertAt > bashFrame.notebook.GetPageCount():
                bashFrame.notebook.AddPage(panel,title)
            else:
                bashFrame.notebook.InsertPage(insertAt,panel,title)
        settings['bash.tabs'][self.tabKey] ^= True
        settings.setChanged('bash.tabs')

#------------------------------------------------------------------------------
class Settings_IconSize(Link):
    def __init__(self, size):
        Link.__init__(self)
        self.size = size

    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,unicode(self.size),kind=wx.ITEM_RADIO,
            help=_(u"Sets the status bar icons to %(size)s pixels") % ({'size':unicode(self.size)}))
        menu.AppendItem(menuItem)
        menuItem.Check(self.size == settings['bash.statusbar.iconSize'])

    def Execute(self,event):
        settings['bash.statusbar.iconSize'] = self.size
        bashFrame.GetStatusBar().UpdateIconSizes()

#------------------------------------------------------------------------------
class Settings_StatusBar_ShowVersions(Link):
    """Show/Hide version numbers for buttons on the statusbar."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Show App Version'),kind=wx.ITEM_CHECK,
            help=_(u"Show/hide version numbers for buttons on the status bar."))
        menu.AppendItem(menuItem)
        menuItem.Check(settings['bash.statusbar.showversion'])

    def Execute(self,event):
        settings['bash.statusbar.showversion'] ^= True
        for button in BashStatusBar.buttons:
            if isinstance(button, App_Button):
                if button.gButton:
                    button.gButton.SetToolTip(tooltip(button.tip))
        if settings['bash.obse.on']:
            for button in App_Button.obseButtons:
                button.gButton.SetToolTip(tooltip(getattr(button,'obseTip',u'')))

#------------------------------------------------------------------------------
class Settings_Languages(Link):
    """Menu for available Languages."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        languages = []
        for file in bosh.dirs['l10n'].list():
            if file.cext == u'.txt' and file.csbody[-3:] != u'new':
                languages.append(file.body)
        if languages:
            subMenu = wx.Menu()
            menu.AppendMenu(self.id,_(u'Language'),subMenu)
            for language in languages:
                Settings_Language(language.s).AppendToMenu(subMenu,window,data)
            if bolt.Path('english') not in languages:
                Settings_Language('English').AppendToMenu(subMenu,window,data)
        else:
            menuItem = wx.MenuItem(menu,self.id,_(u'Language'),
                help=_("Wrye Bash was unable to detect any translation files."))
            menu.AppendItem(menuItem)
            menuItem.Enable(False)

#------------------------------------------------------------------------------
class Settings_Language(Link):
    """Specific language for Wrye Bash."""
    languageMap = {
        u'chinese (simplified)': _(u'Chinese (Simplified)') + u' ()',
        u'chinese (traditional)': _(u'Chinese (Traditional)') + u' ()',
        u'de': _(u'German') + u' (Deutsch)',
        u'pt_opt': _(u'Portuguese') + u' (portugus)',
        u'italian': _(u'Italian') + u' (italiano)',
        u'russian': _(u'Russian') + u' ( )',
        u'english': _(u'English') + u' (English)',
        }

    def __init__(self,language):
        Link.__init__(self)
        self.language = language

    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        label = self.__class__.languageMap.get(self.language.lower(),self.language)
        bassLang = bass.language if bass.language else locale.getlocale()[0].split('_',1)[0]
        if self.language == bassLang:
            menuItem = wx.MenuItem(menu,self.id,label,kind=wx.ITEM_RADIO,
                help=_("Currently using %(languagename)s as the active language.") % ({'languagename':label}))
        else:
            menuItem = wx.MenuItem(menu,self.id,label,
                help=_("Restart Wrye Bash and use %(languagename)s as the active language.") % ({'languagename':label}))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        bassLang = bass.language if bass.language else locale.getlocale()[0].split('_',1)[0]
        if self.language == bassLang: return
        if balt.askYes(bashFrame,
                       _(u'Wrye Bash needs to restart to change languages.  Do you want to restart?'),
                       _(u'Restart Wrye Bash')):
            bashFrame.Restart(('--Language',self.language))

#------------------------------------------------------------------------------
class Settings_PluginEncodings(Link):
    encodings = {
        'gbk': _(u'Chinese (Simplified)'),
        'big5': _(u'Chinese (Traditional)'),
        'cp1251': _(u'Russian'),
        'cp932': _(u'Japanese'),
        'cp1252': _(u'Western European (English, French, German, etc)'),
        }
    def __init__(self):
        Link.__init__(self)
        bolt.pluginEncoding = settings['bash.pluginEncoding']

    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        subMenu = wx.Menu()
        menu.AppendMenu(self.id,_(u'Plugin Encoding'),subMenu)
        Settings_PluginEncoding(_(u'Automatic'),None).AppendToMenu(subMenu,window,data)
        SeparatorLink().AppendToMenu(subMenu,window,data)
        enc_name = sorted(Settings_PluginEncodings.encodings.items(),key=lambda x: x[1])
        for encoding,name in enc_name:
            Settings_PluginEncoding(name,encoding).AppendToMenu(subMenu,window,data)

#------------------------------------------------------------------------------
class Settings_PluginEncoding(Link):
    def __init__(self,name,encoding):
        Link.__init__(self)
        self.name = name
        self.encoding = encoding

    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        if self.encoding == settings['bash.pluginEncoding']:
            menuItem = wx.MenuItem(menu,self.id,self.name,kind=wx.ITEM_RADIO,
                help=_("Select %(encodingname)s encoding for Wrye Bash to use.") % ({'encodingname':self.name}))
        else:
            menuItem = wx.MenuItem(menu,self.id,self.name,
                help=_("Select %(encodingname)s encoding for Wrye Bash to use.") % ({'encodingname':self.name}))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        settings['bash.pluginEncoding'] = self.encoding
        bolt.pluginEncoding = self.encoding

#------------------------------------------------------------------------------
class Settings_Games(Link):
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        foundGames,allGames,name = bush.detectGames()
        subMenu = wx.Menu()
        menu.AppendMenu(self.id,_(u'Game'),subMenu)
        for game in foundGames:
            game = game[0].upper()+game[1:]
            Settings_Game(game).AppendToMenu(subMenu,window,data)

class Settings_Game(Link):
    def __init__(self,game):
        Link.__init__(self)
        self.game = game

    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,self.game,kind=wx.ITEM_RADIO,
            help=_("Restart Wrye Bash to manage %(game)s.") % ({'game':self.game}))
        menu.AppendItem(menuItem)
        if self.game.lower() == bush.game.name.lower():
            menuItem.Check(True)

    def Execute(self,event):
        if self.game.lower() == bush.game.name.lower(): return
        bashFrame.Restart(('--game',self.game))

#------------------------------------------------------------------------------
class Settings_UnHideButtons(Link):
    """Menu to unhide a StatusBar button."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        hide = settings['bash.statusbar.hide']
        hidden = []
        for link in BashStatusBar.buttons:
            if link.uid in hide:
                hidden.append(link)
        if hidden:
            subMenu = wx.Menu()
            menu.AppendMenu(self.id,_(u'Unhide Buttons'),subMenu)
            for link in hidden:
                Settings_UnHideButton(link).AppendToMenu(subMenu,window,data)
        else:
            menuItem = wx.MenuItem(menu,self.id,_(u'Unhide Buttons'),
                help=_(u"No hidden buttons available to unhide."))
            menu.AppendItem(menuItem)
            menuItem.Enable(False)

#------------------------------------------------------------------------------
class Settings_UnHideButton(Link):
    """Unhide a specific StatusBar button."""
    def __init__(self,link):
        Link.__init__(self)
        self.link = link

    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        button = self.link.gButton
        # Get a title for the hidden button
        if button:
            # If the wx.Button object exists (it was hidden this session),
            # Use the tooltip from it
            tip = button.GetToolTip().GetTip()
        else:
            # If the link is an App_Button, it will have a 'tip' attribute
            tip = getattr(self.link,'tip',None)
        if tip is None:
            # No good, use it's uid as a last resort
            tip = self.link.uid
        help = _(u"Unhide the '%s' status bar button.") % tip
        menuItem = wx.MenuItem(menu,self.id,tip,help)
        menu.AppendItem(menuItem)

    def Execute(self,event):
        bashFrame.GetStatusBar().UnhideButton(self.link)

#------------------------------------------------------------------------------
class Settings_UseAltName(BoolLink):
    def __init__(self): BoolLink.__init__(
        self,_(u'Use Alternate Wrye Bash Name'),
        'bash.useAltName',
        _(u'Use an alternate display name for Wrye Bash based on the game it is managing.'))

    def Execute(self,event):
        BoolLink.Execute(self,event)
        bashFrame.SetTitle()

# StatusBar Links--------------------------------------------------------------
#------------------------------------------------------------------------------
class StatusBar_Hide(Link):
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        tip = window.GetToolTip().GetTip()
        menuItem = wx.MenuItem(menu,self.id,_(u"Hide '%s'") % tip,
                help=_(u"Hides %(buttonname)s's status bar button (can be restored through the settings menu).") % ({'buttonname':tip}))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        sb = bashFrame.GetStatusBar()
        sb.HideButton(self.window)

# Mod Links -------------------------------------------------------------------
#------------------------------------------------------------------------------
class Mod_ActorLevels_Export(Link):
    """Export actor levels from mod to text file."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'NPC Levels...'),
                help=_(u"Export NPC level info from mod to text file."))
        menu.AppendItem(menuItem)
        menuItem.Enable(bool(self.data))

    def Execute(self,event):
        message = (_(u'This command will export the level info for NPCs whose level is offset with respect to the PC.  The exported file can be edited with most spreadsheet programs and then reimported.')
                   + u'\n\n' +
                   _(u'See the Bash help file for more info.'))
        if not balt.askContinue(self.window,message,
                'bash.actorLevels.export.continue',
                _(u'Export NPC Levels')):
            return
        fileName = GPath(self.data[0])
        fileInfo = bosh.modInfos[fileName]
        textName = fileName.root+u'_NPC_Levels.csv'
        textDir = bosh.dirs['patches']
        textDir.makedirs()
        #--File dialog
        textPath = balt.askSave(self.window,_(u'Export NPC levels to:'),textDir,
                                textName, u'*_NPC_Levels.csv')
        if not textPath: return
        (textDir,textName) = textPath.headTail
        #--Export
        with balt.Progress(_(u'Export Factions')) as progress:
            if CBash:
                actorLevels = bosh.CBash_ActorLevels()
            else:
                actorLevels = bosh.ActorLevels()
            readProgress = SubProgress(progress,0.1,0.8)
            readProgress.setFull(len(self.data))
            for index,fileName in enumerate(map(GPath,self.data)):
                fileInfo = bosh.modInfos[fileName]
                readProgress(index,_(u'Reading')+u' '+fileName.s)
                actorLevels.readFromMod(fileInfo)
            progress(0.8,_(u'Exporting to')+u' '+textName.s+u'.')
            actorLevels.writeToText(textPath)
            progress(1.0,_(u'Done.'))

#------------------------------------------------------------------------------
class Mod_ActorLevels_Import(Link):
    """Imports actor levels from text file to mod."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'NPC Levels...'),
                help=_(u"Import NPC level info from text fiile to mod"))
        menu.AppendItem(menuItem)
        menuItem.Enable(len(self.data)==1)

    def Execute(self,event):
        message = (_(u'This command will import NPC level info from a previously exported file.')
                   + u'\n\n' +
                   _(u'See the Bash help file for more info.'))
        if not balt.askContinue(self.window,message,
                'bash.actorLevels.import.continue',
                _(u'Import NPC Levels')):
            return
        fileName = GPath(self.data[0])
        fileInfo = bosh.modInfos[fileName]
        textName = fileName.root+u'_NPC_Levels.csv'
        textDir = bosh.dirs['patches']
        #--File dialog
        textPath = balt.askOpen(self.window,_(u'Import NPC levels from:'),
            textDir,textName,u'*_NPC_Levels.csv',mustExist=True)
        if not textPath: return
        (textDir,textName) = textPath.headTail
        #--Extension error check
        ext = textName.cext
        if ext != u'.csv':
            balt.showError(self.window,_(u'Source file must be a _NPC_Levels.csv file.'))
            return
        #--Export
        changed = None
        with balt.Progress(_(u'Import NPC Levels')) as progress:
            if CBash:
                actorLevels = bosh.CBash_ActorLevels()
            else:
                actorLevels = bosh.ActorLevels()
            progress(0.1,_(u'Reading')+u' '+textName.s+u'.')
            actorLevels.readFromText(textPath)
            progress(0.2,_(u'Applying to')+u' '+fileName.s+u'.')
            changed = actorLevels.writeToMod(fileInfo)
            progress(1.0,_(u'Done.'))
        #--Log
        if not changed:
            balt.showOk(self.window,_(u'No relevant NPC levels to import.'),
                        _(u'Import NPC Levels'))
        else:
            buff = StringIO.StringIO()
            buff.write(u'* %03d  %s\n' % (changed, fileName.s))
            balt.showLog(self.window,buff.getvalue(),_(u'Import NPC Levels'),
                         icons=bashBlue)

#------------------------------------------------------------------------------
class MasterList_AddMasters(Link):
    """Adds a master."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Add Masters...'))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        message = _(u"WARNING!  For advanced modders only!  Adds specified master to list of masters, thus ceding ownership of new content of this mod to the new master.  Useful for splitting mods into esm/esp pairs.")
        if not balt.askContinue(self.window,message,'bash.addMaster.continue',_(u'Add Masters')):
            return
        modInfo = self.window.fileInfo
        wildcard = bush.game.name+u' '+_(u'Masters')+u' (*.esm;*.esp)|*.esm;*.esp'
        masterPaths = balt.askOpenMulti(self.window,_(u'Add masters:'),
                        modInfo.dir, u'', wildcard)
        if not masterPaths: return
        names = []
        for masterPath in masterPaths:
            (dir,name) = masterPath.headTail
            if dir != modInfo.dir:
                return balt.showError(self.window,
                    _(u"File must be selected from %s Data Files directory.")
                    % bush.game.name)
            if name in modInfo.header.masters:
                return balt.showError(self.window,
                    name.s+u' '+_(u"is already a master."))
            names.append(name)
        for masterName in bosh.modInfos.getOrdered(names, asTuple=False):
            if masterName in bosh.modInfos:
                masterName = bosh.modInfos[masterName].name
            modInfo.header.masters.append(masterName)
        modInfo.header.changed = True
        self.window.SetFileInfo(modInfo)
        self.window.InitEdit()

#------------------------------------------------------------------------------
class MasterList_CleanMasters(Link):
    """Remove unneeded masters."""
    def AppendToMenu(self,menu,window,data):
        if not settings['bash.CBashEnabled']: return
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Clean Masters...'))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        message = _(u"WARNING!  For advanced modders only!  Removes masters that are not referenced in any records.")
        if not balt.askContinue(self.window,message,'bash.cleanMaster.continue',
                                _(u'Clean Masters')):
            return
        modInfo = self.window.fileInfo
        path = modInfo.getPath()

        with ObCollection(ModsPath=bosh.dirs['mods'].s) as Current:
            modFile = Current.addMod(path.stail)
            Current.load()
            oldMasters = modFile.TES4.masters
            cleaned = modFile.CleanMasters()

            if cleaned:
                newMasters = modFile.TES4.masters
                removed = [GPath(x) for x in oldMasters if x not in newMasters]
                removeKey = _(u'Masters')
                group = [removeKey,
                              _(u'These master files are not referenced within the mod, and can safely be removed.'),
                              ]
                group.extend(remove)
                checklists = [group]
                dialog = ListBoxes(bashFrame,_(u'Remove these masters?'),
                                        _(u'The following master files can be safely removed.'),
                                        checklists)
                if dialog.ShowModal() == wx.ID_CANCEL:
                    dialog.Destroy()
                    return
                id = dialog.ids[removeKey]
                checks = dialog.FindWindowById(id)
                if checks:
                    for i,mod in enumerate(remove):
                        if not checks.IsChecked(i):
                            newMasters.append(mod)

                modFile.TES4.masters = newMasters
                modFile.save()
                dialog.Destroy()
                if toRemove:
                    print _(u'to remove:'), toRemove
            else:
                balt.showOk(self.window,_(u'No Masters to clean.'),
                            _(u'Clean Masters'))

#------------------------------------------------------------------------------
class Mod_FullLoad(Link):
    """Tests all record definitions against a specific mod"""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Test Full Record Definitions...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(len(data)==1)

    def Execute(self,event):
        fileName = GPath(self.data[0])
        with balt.Progress(_(u'Loading:')+u'\n%s'%fileName.stail) as progress:
            print bosh.MreRecord.type_class
            readClasses = bosh.MreRecord.type_class
            print readClasses.values()
            loadFactory = bosh.LoadFactory(False, *readClasses.values())
            modFile = bosh.ModFile(bosh.modInfos[fileName],loadFactory)
            try:
                modFile.load(True,progress)
            except:
                deprint('execption:\n', traceback=True)

#------------------------------------------------------------------------------
class Mod_AddMaster(Link):
    """Adds master."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Add Master...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(len(data)==1)

    def Execute(self,event):
        message = _(u"WARNING! For advanced modders only! Adds specified master to list of masters, thus ceding ownership of new content of this mod to the new master. Useful for splitting mods into esm/esp pairs.")
        if not balt.askContinue(self.window,message,'bash.addMaster.continue',_(u'Add Master')):
            return
        fileName = GPath(self.data[0])
        fileInfo = self.window.data[fileName]
        wildcard = _(u'%s Masters')%bush.game.name+u' (*.esm;*.esp)|*.esm;*.esp'
        masterPaths = balt.askOpenMulti(self.window,_(u'Add master:'),fileInfo.dir, u'', wildcard)
        if not masterPaths: return
        names = []
        for masterPath in masterPaths:
            (dir,name) = masterPath.headTail
            if dir != fileInfo.dir:
                return balt.showError(self.window,
                    _(u"File must be selected from %s Data Files directory.") % bush.game.name)
            if name in fileInfo.header.masters:
                return balt.showError(self.window,_(u"%s is already a master!") % name.s)
            names.append(name)
        # actually do the modification
        for masterName in bosh.modInfos.getOrdered(names, asTuple=False):
            if masterName in bosh.modInfos:
                #--Avoid capitalization errors by getting the actual name from modinfos.
                masterName = bosh.modInfos[masterName].name
            fileInfo.header.masters.append(masterName)
        fileInfo.header.changed = True
        fileInfo.writeHeader()
        bosh.modInfos.refreshFile(fileInfo.name)
        self.window.RefreshUI()

#------------------------------------------------------------------------------
class Mod_BaloGroups_Edit(wx.Dialog):
    """Dialog for editing Balo groups."""
    def __init__(self,parent):
        #--Data
        self.parent = parent
        self.groups = [list(x) for x in bosh.modInfos.getBaloGroups(True)]
        self.removed = set()
        #--GUI
        wx.Dialog.__init__(self,parent,wx.ID_ANY,_(u"Balo Groups"),style=wx.CAPTION|wx.RESIZE_BORDER)
        #--List
        self.gList = wx.ListBox(self,wx.ID_ANY,choices=self.GetItems(),style=wx.LB_SINGLE)
        self.gList.SetSizeHints(125,150)
        self.gList.Bind(wx.EVT_LISTBOX,self.DoSelect)
        #--Bounds
        self.gLowerBounds = spinCtrl(self,u'-10',size=(15,15),min=-10,max=0,onSpin=self.OnSpin)
        self.gUpperBounds = spinCtrl(self,u'10',size=(15,15),min=0,max=10, onSpin=self.OnSpin)
        self.gLowerBounds.SetSizeHints(35,-1)
        self.gUpperBounds.SetSizeHints(35,-1)
        #--Buttons
        self.gAdd = button(self,_(u'Add'),onClick=self.DoAdd)
        self.gRename = button(self,_(u'Rename'),onClick=self.DoRename)
        self.gRemove = button(self,_(u'Remove'),onClick=self.DoRemove)
        self.gMoveEarlier = button(self,_(u'Move Up'),onClick=self.DoMoveEarlier)
        self.gMoveLater = button(self,_(u'Move Down'),onClick=self.DoMoveLater)
        #--Layout
        topLeftCenter= wx.ALIGN_CENTER|wx.LEFT|wx.TOP
        sizer = hSizer(
            (self.gList,1,wx.EXPAND|wx.TOP,4),
            (vSizer(
                (self.gAdd,0,topLeftCenter,4),
                (self.gRename,0,topLeftCenter,4),
                (self.gRemove,0,topLeftCenter,4),
                (self.gMoveEarlier,0,topLeftCenter,4),
                (self.gMoveLater,0,topLeftCenter,4),
                (hsbSizer((self,wx.ID_ANY,_(u'Offsets')),
                    (self.gLowerBounds,1,wx.EXPAND|wx.LEFT|wx.TOP,4),
                    (self.gUpperBounds,1,wx.EXPAND|wx.TOP,4),
                    ),0,wx.LEFT|wx.TOP,4),
                    spacer,
                    (button(self,id=wx.ID_SAVE,onClick=self.DoSave),0,topLeftCenter,4),
                    (button(self,id=wx.ID_CANCEL,onClick=self.DoCancel),0,topLeftCenter|wx.BOTTOM,4),
                ),0,wx.EXPAND|wx.RIGHT,4),
            )
        #--Done
        self.SetSizeHints(200,300)
        className = self.__class__.__name__
        if className in balt.sizes:
            self.SetSizer(sizer)
            self.SetSize(balt.sizes[className])
        else:
            self.SetSizerAndFit(sizer)
        self.Refresh(0)

    #--Support
    def AskNewName(self,message,title):
        """Ask user for new/copy name."""
        newName = (balt.askText(self,message,title) or u'').strip()
        if not newName: return None
        maValid = re.match(u'([a-zA-Z][ _a-zA-Z]+)',newName,flags=re.U)
        if not maValid or maValid.group(1) != newName:
            balt.showWarning(self,
                _(u"Group name must be letters, spaces, underscores only!"),title)
            return None
        elif newName in self.GetItems():
            balt.showWarning(self,_(u"group %s already exists.") % newName,title)
            return None
        elif len(newName) >= 40:
            balt.showWarning(self,_(u"Group names must be less than forty characters."),title)
            return None
        else:
            return newName

    def GetItems(self):
        """Return a list of item strings."""
        return [x[5] for x in self.groups]

    def GetItemLabel(self,index):
        info = self.groups[index]
        lower,upper,group = info[1],info[2],info[5]
        if lower == upper:
            return group
        else:
            return u'%s  %d : %d' % (group,lower,upper)

    def Refresh(self,index):
        """Refresh items in list."""
        labels = [self.GetItemLabel(x) for x in range(len(self.groups))]
        self.gList.Set(labels)
        self.gList.SetSelection(index)
        self.RefreshButtons()

    def RefreshBounds(self,index):
        """Refresh bounds info."""
        if index < 0 or index >= len(self.groups):
            lower,upper = 0,0
        else:
            lower,upper,usedStart,usedStop = self.groups[index][1:5]
        self.gLowerBounds.SetRange(-10,usedStart)
        self.gUpperBounds.SetRange(usedStop-1,10)
        self.gLowerBounds.SetValue(lower)
        self.gUpperBounds.SetValue(upper)

    def RefreshButtons(self,index=None):
        """Updates buttons."""
        if index == None:
            index = (self.gList.GetSelections() or (0,))[0]
        self.RefreshBounds(index)
        usedStart,usedStop = self.groups[index][3:5]
        mutable = index <= len(self.groups) - 3
        self.gAdd.Enable(mutable)
        self.gRename.Enable(mutable)
        self.gRemove.Enable(mutable and usedStart == usedStop)
        self.gMoveEarlier.Enable(mutable and index > 0)
        self.gMoveLater.Enable(mutable and index <= len(self.groups) - 4)
        self.gLowerBounds.Enable(index != len(self.groups) - 2)
        self.gUpperBounds.Enable(index != len(self.groups) - 2)

    #--Event Handling
    def DoAdd(self,event):
        """Adds a new item."""
        title = _(u"Add Balo Group")
        index = (self.gList.GetSelections() or (0,))[0]
        if index < 0 or index >= len(self.groups) - 2: return bell()
        #--Ask for and then check new name
        oldName = self.groups[index][0]
        message = _(u"Name of new group (spaces and letters only):")
        newName = self.AskNewName(message,title)
        if newName:
            self.groups.insert(index+1,[u'',0,0,0,0,newName])
            self.Refresh(index+1)

    def DoMoveEarlier(self,event):
        """Moves selected group up (earlier) in order.)"""
        index = (self.gList.GetSelections() or (0,))[0]
        if index < 1 or index >= (len(self.groups)-2): return bell()
        swapped = [self.groups[index],self.groups[index-1]]
        self.groups[index-1:index+1] = swapped
        self.Refresh(index-1)

    def DoMoveLater(self,event):
        """Moves selected group down (later) in order.)"""
        index = (self.gList.GetSelections() or (0,))[0]
        if index < 0 or index >= (len(self.groups) - 3): return bell()
        swapped = [self.groups[index+1],self.groups[index]]
        self.groups[index:index+2] = swapped
        self.Refresh(index+1)

    def DoRename(self,event):
        """Renames selected item."""
        title = _(u"Rename Balo Group")
        index = (self.gList.GetSelections() or (0,))[0]
        if index < 0 or index >= len(self.groups): return bell()
        #--Ask for and then check new name
        oldName = self.groups[index][5]
        message = _(u"Rename %s to (spaces, letters and underscores only):") % oldName
        newName = self.AskNewName(message,title)
        if newName:
            self.groups[index][5] = newName
            self.gList.SetString(index,self.GetItemLabel(index))

    def DoRemove(self,event):
        """Removes selected item."""
        index = (self.gList.GetSelections() or (0,))[0]
        if index < 0 or index >= len(self.groups): return bell()
        name = self.groups[index][0]
        if name: self.removed.add(name)
        del self.groups[index]
        self.gList.Delete(index)
        self.Refresh(index)

    def DoSelect(self,event):
        """Handle select event."""
        self.Refresh(event.GetSelection())
        self.gList.SetFocus()

    def OnSpin(self,event):
        """Show label editing dialog."""
        index = (self.gList.GetSelections() or (0,))[0]
        self.groups[index][1] = self.gLowerBounds.GetValue()
        self.groups[index][2] = self.gUpperBounds.GetValue()
        self.gList.SetString(index,self.GetItemLabel(index))
        event.Skip()

    #--Save/Cancel
    def DoSave(self,event):
        """Handle save button."""
        balt.sizes[self.__class__.__name__] = self.GetSizeTuple()
        settings['bash.balo.full'] = True
        bosh.modInfos.setBaloGroups(self.groups,self.removed)
        bosh.modInfos.updateAutoGroups()
        bosh.modInfos.refresh()
        modList.RefreshUI()
        self.EndModal(wx.ID_OK)

    def DoCancel(self,event):
        """Handle save button."""
        balt.sizes[self.__class__.__name__] = self.GetSizeTuple()
        self.EndModal(wx.ID_CANCEL)

#------------------------------------------------------------------------------
class Mod_BaloGroups:
    """Select Balo group to use."""
    def __init__(self):
        """Initialize."""
        self.id_group = {}
        self.idList = ID_GROUPS

    def GetItems(self):
        items = self.labels[:]
        items.sort(key=lambda a: a.lower())
        return items

    def AppendToMenu(self,menu,window,data):
        """Append label list to menu."""
        if not settings.get('bash.balo.full'): return
        self.window = window
        self.data = data
        id_group = self.id_group
        menu.Append(self.idList.EDIT,_(u'Edit...'))
        setableMods = [GPath(x) for x in self.data if GPath(x) not in bosh.modInfos.autoHeaders]
        if setableMods:
            menu.AppendSeparator()
            ids = iter(self.idList)
            if len(setableMods) == 1:
                modGroup = bosh.modInfos.table.getItem(setableMods[0],'group')
            else:
                modGroup = None
            for group,lower,upper in bosh.modInfos.getBaloGroups():
                if lower == upper:
                    id = ids.next()
                    id_group[id] = group
                    menu.AppendCheckItem(id,group)
                    menu.Check(id,group == modGroup)
                else:
                    subMenu = wx.Menu()
                    for x in range(lower,upper+1):
                        offGroup = bosh.joinModGroup(group,x)
                        id = ids.next()
                        id_group[id] = offGroup
                        subMenu.AppendCheckItem(id,offGroup)
                        subMenu.Check(id,offGroup == modGroup)
                    menu.AppendMenu(-1,group,subMenu)
        #--Events
        wx.EVT_MENU(bashFrame,self.idList.EDIT,self.DoEdit)
        wx.EVT_MENU_RANGE(bashFrame,self.idList.BASE,self.idList.MAX,self.DoList)

    def DoList(self,event):
        """Handle selection of label."""
        label = self.id_group[event.GetId()]
        mod_group = bosh.modInfos.table.getColumn('group')
        for mod in self.data:
            if mod not in bosh.modInfos.autoHeaders:
                mod_group[mod] = label
        if bosh.modInfos.refresh(doInfos=False):
            modList.SortItems()
        self.window.RefreshUI()

    def DoEdit(self,event):
        """Show label editing dialog."""
        dialog = Mod_BaloGroups_Edit(self.window)
        dialog.ShowModal()
        dialog.Destroy()

#------------------------------------------------------------------------------
class Mod_AllowAllGhosting(Link):
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u"Allow Ghosting"))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        files = []
        for fileName in self.data:
            fileInfo = bosh.modInfos[fileName]
            allowGhosting = True
            bosh.modInfos.table.setItem(fileName,'allowGhosting',allowGhosting)
            toGhost = fileName not in bosh.modInfos.ordered
            oldGhost = fileInfo.isGhost
            if fileInfo.setGhost(toGhost) != oldGhost:
                files.append(fileName)
        self.window.RefreshUI(files)

#------------------------------------------------------------------------------
class Mod_CreateBOSSReport(Link):
    """Copies appropriate information for making a report in the BOSS thread."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u"Create BOSS Report..."))
        menu.AppendItem(menuItem)
        menuItem.Enable(len(self.data) != 1 or (not bosh.reOblivion.match(self.data[0].s)))

    def Execute(self,event):
        text = u''
        if len(self.data) > 5:
            spoiler = True
            text += u'[spoiler]\n'
        else:
            spoiler = False
        # Scan for ITM and UDR's
        modInfos = [bosh.modInfos[x] for x in self.data]
        try:
            with balt.Progress(_(u"Dirty Edits"),u'\n'+u' '*60,abort=True) as progress:
                udr_itm_fog = bosh.ModCleaner.scan_Many(modInfos,progress=progress)
        except bolt.CancelError:
            return
        # Create the report
        for i,fileName in enumerate(self.data):
            if fileName == u'Oblivion.esm': continue
            fileInfo = bosh.modInfos[fileName]
            #-- Name of file, plus a link if we can figure it out
            installer = bosh.modInfos.table.getItem(fileName,'installer',u'')
            if not installer:
                text += fileName.s
            else:
                # Try to get the url of the file
                # Order of priority will be:
                #  TESNexus
                #  TESAlliance
                url = None
                ma = bosh.reTesNexus.search(installer)
                if ma and ma.group(2):
                    url = bush.game.nexusUrl+u'downloads/file.php?id='+ma.group(2)
                if not url:
                    ma = bosh.reTESA.search(installer)
                    if ma and ma.group(2):
                        url = u'http://tesalliance.org/forums/index.php?app=downloads&showfile='+ma.group(2)
                if url:
                    text += u'[url='+url+u']'+fileName.s+u'[/url]'
                else:
                    text += fileName.s
            #-- Version, if it exists
            version = bosh.modInfos.getVersion(fileName)
            if version:
                text += u'\n'+_(u'Version')+u': %s' % version
            #-- CRC
            text += u'\n'+_(u'CRC')+u': %08X' % fileInfo.cachedCrc()
            #-- Dirty edits
            if udr_itm_fog:
                udrs,itms,fogs = udr_itm_fog[i]
                if udrs or itms:
                    if settings['bash.CBashEnabled']:
                        text += (u'\nUDR: %i, ITM: %i%s '+_(u'(via Wrye Bash)')) % (len(udrs),len(itms))
                    else:
                        text += (u'\nUDR: %i, ITM not scanned '+_(u'(via Wrye Bash)')) % len(udrs)
            text += u'\n\n'
        if spoiler: text += u'[/spoiler]'

        # Show results + copy to clipboard
        if (wx.TheClipboard.Open()):
            wx.TheClipboard.SetData(wx.TextDataObject(text))
            wx.TheClipboard.Close()
        balt.showLog(self.window,text,_(u'BOSS Report'),asDialog=False,fixedFont=False,icons=bashBlue)

#------------------------------------------------------------------------------
class Mod_CopyModInfo(Link):
    """Copies the basic info about selected mod(s)."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Copy Mod Info...'))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        text = u''
        if len(self.data) > 5:
            spoiler = True
            text += u'[spoiler]'
        else:
            spoiler = False
        # Create the report
        isFirst = True
        for i,fileName in enumerate(self.data):
            # add a blank line in between mods
            if isFirst: isFirst = False
            else: text += u'\n\n'
            fileInfo = bosh.modInfos[fileName]
            #-- Name of file, plus a link if we can figure it out
            installer = bosh.modInfos.table.getItem(fileName,'installer',u'')
            if not installer:
                text += fileName.s
            else:
                # Try to get the url of the file
                # Order of priority will be:
                #  TESNexus
                #  TESAlliance
                url = None
                ma = bosh.reTesNexus.search(installer)
                if ma and ma.group(2):
                    url = bush.game.nexusUrl+u'downloads/file.php?id='+ma.group(2)
                if not url:
                    ma = bosh.reTESA.search(installer)
                    if ma and ma.group(2):
                        url = u'http://tesalliance.org/forums/index.php?app=downloads&showfile='+ma.group(2)
                if url:
                    text += u'[url=%s]%s[/url]' % (url, fileName.s)
                else:
                    text += fileName.s
            for col in settings['bash.mods.cols']:
                if col == 'File': continue
                elif col == 'Rating':
                    value = bosh.modInfos.table.getItem(fileName,'rating',u'')
                elif col == 'Group':
                    value = bosh.modInfos.table.getItem(fileName,'group',u'')
                elif col == 'Installer':
                    value = bosh.modInfos.table.getItem(fileName,'installer', u'')
                elif col == 'Modified':
                    value = formatDate(fileInfo.mtime)
                elif col == 'Size':
                    value = formatInteger(fileInfo.size/1024)+u' KB'
                elif col == 'Author' and fileInfo.header:
                    value = fileInfo.header.author
                elif col == 'Load Order':
                    ordered = bosh.modInfos.ordered
                    if fileName in ordered:
                        value = u'%02X' % list(ordered).index(fileName)
                    else:
                        value = u''
                elif col == 'CRC':
                    value = u'%08X' % fileInfo.cachedCrc()
                elif col == 'Mod Status':
                    value = fileInfo.txt_status()
                text += u'\n%s: %s' % (col, value)
            #-- Version, if it exists
            version = bosh.modInfos.getVersion(fileName)
            if version:
                text += u'\n'+_(u'Version')+u': %s' % version
        if spoiler: text += u'[/spoiler]'

        # Show results + copy to clipboard
        if (wx.TheClipboard.Open()):
            wx.TheClipboard.SetData(wx.TextDataObject(text))
            wx.TheClipboard.Close()
        balt.showLog(self.window,text,_(u'Mod Info Report'),asDialog=False,
                     fixedFont=False,icons=bashBlue)

#------------------------------------------------------------------------------
class Mod_ListBashTags(Link):
    """Copies list of bash tags to clipboard."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u"List Bash Tags..."))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        #--Get masters list
        files = []
        for fileName in self.data:
            files.append(bosh.modInfos[fileName])
        text = bosh.modInfos.getTagList(files)
        if (wx.TheClipboard.Open()):
            wx.TheClipboard.SetData(wx.TextDataObject(text))
            wx.TheClipboard.Close()
        balt.showLog(self.window,text,_(u"Bash Tags"),asDialog=False,fixedFont=False,icons=bashBlue)

#------------------------------------------------------------------------------
class Mod_AllowNoGhosting(Link):
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u"Disallow Ghosting"))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        files = []
        for fileName in self.data:
            fileInfo = bosh.modInfos[fileName]
            allowGhosting = False
            bosh.modInfos.table.setItem(fileName,'allowGhosting',allowGhosting)
            toGhost = False
            oldGhost = fileInfo.isGhost
            if fileInfo.setGhost(toGhost) != oldGhost:
                files.append(fileName)
        self.window.RefreshUI(files)

#------------------------------------------------------------------------------
class Mod_Ghost(Link):
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u"Ghost"))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        files = []
        for fileName in self.data:
            fileInfo = bosh.modInfos[fileName]
            allowGhosting = True
            bosh.modInfos.table.setItem(fileName,'allowGhosting',allowGhosting)
            toGhost = fileName not in bosh.modInfos.ordered
            oldGhost = fileInfo.isGhost
            if fileInfo.setGhost(toGhost) != oldGhost:
                files.append(fileName)
        self.window.RefreshUI(files)

#------------------------------------------------------------------------------
class Mod_AllowInvertGhosting(Link):
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u"Invert Ghosting"))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        files = []
        for fileName in self.data:
            fileInfo = bosh.modInfos[fileName]
            allowGhosting = bosh.modInfos.table.getItem(fileName,'allowGhosting',True) ^ True
            bosh.modInfos.table.setItem(fileName,'allowGhosting',allowGhosting)
            toGhost = allowGhosting and fileName not in bosh.modInfos.ordered
            oldGhost = fileInfo.isGhost
            if fileInfo.setGhost(toGhost) != oldGhost:
                files.append(fileName)
        self.window.RefreshUI(files)

#------------------------------------------------------------------------------
class Mod_AllowGhosting(Link):
    """Toggles Ghostability."""

    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        if len(data) == 1:
            menuItem = wx.MenuItem(menu,self.id,_(u"Don't Ghost"),kind=wx.ITEM_CHECK)
            menu.AppendItem(menuItem)
            self.allowGhosting = bosh.modInfos.table.getItem(data[0],'allowGhosting',True)
            menuItem.Check(not self.allowGhosting)
        else:
            subMenu = wx.Menu()
            menu.AppendMenu(-1,_(u"Ghosting"),subMenu)
            Mod_AllowAllGhosting().AppendToMenu(subMenu,window,data)
            Mod_AllowNoGhosting().AppendToMenu(subMenu,window,data)
            Mod_AllowInvertGhosting().AppendToMenu(subMenu,window,data)

    def Execute(self,event):
        fileName = self.data[0]
        fileInfo = bosh.modInfos[fileName]
        allowGhosting = self.allowGhosting ^ True
        bosh.modInfos.table.setItem(fileName,'allowGhosting',allowGhosting)
        toGhost = allowGhosting and fileName not in bosh.modInfos.ordered
        oldGhost = fileInfo.isGhost
        if fileInfo.setGhost(toGhost) != oldGhost:
            self.window.RefreshUI(fileName)

#------------------------------------------------------------------------------
class Mod_SkipDirtyCheckAll(Link):
    def __init__(self, bSkip):
        Link.__init__(self)
        self.skip = bSkip

    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        if self.skip:
            menuItem = wx.MenuItem(menu,self.id,_(u"Don't check against BOSS's dirty mod list"),kind=wx.ITEM_CHECK)
        else:
            menuItem = wx.MenuItem(menu,self.id,_(u"Check against BOSS's dirty mod list"),kind=wx.ITEM_CHECK)
        menu.AppendItem(menuItem)
        for fileName in self.data:
            if bosh.modInfos.table.getItem(fileName,'ignoreDirty',self.skip) != self.skip:
                menuItem.Check(False)
                break
        else: menuItem.Check(True)

    def Execute(self,event):
        for fileName in self.data:
            fileInfo = bosh.modInfos[fileName]
            bosh.modInfos.table.setItem(fileName,'ignoreDirty',self.skip)
        self.window.RefreshUI(self.data)

#------------------------------------------------------------------------------
class Mod_SkipDirtyCheckInvert(Link):
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u"Invert checking against BOSS's dirty mod list"))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        for fileName in self.data:
            fileInfo = bosh.modInfos[fileName]
            ignoreDiry = bosh.modInfos.table.getItem(fileName,'ignoreDirty',False) ^ True
            bosh.modInfos.table.setItem(fileName,'ignoreDirty',ignoreDiry)
        self.window.RefreshUI(files)

#------------------------------------------------------------------------------
class Mod_SkipDirtyCheck(Link):
    """Toggles scanning for dirty mods on a per-mod basis."""

    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        if len(data) == 1:
            menuItem = wx.MenuItem(menu,self.id,_(u"Don't check against BOSS's dirty mod list"),kind=wx.ITEM_CHECK)
            menu.AppendItem(menuItem)
            self.ignoreDirty = bosh.modInfos.table.getItem(data[0],'ignoreDirty',False)
            menuItem.Check(self.ignoreDirty)
        else:
            subMenu = wx.Menu()
            menu.AppendMenu(-1,_(u"Dirty edit scanning"),subMenu)
            Mod_SkipDirtyCheckAll(True).AppendToMenu(subMenu,window,data)
            Mod_SkipDirtyCheckAll(False).AppendToMenu(subMenu,window,data)
            Mod_SkipDirtyCheckInvert().AppendToMenu(subMenu,window,data)

    def Execute(self,event):
        fileName = self.data[0]
        fileInfo = bosh.modInfos[fileName]
        self.ignoreDirty ^= True
        bosh.modInfos.table.setItem(fileName,'ignoreDirty',self.ignoreDirty)
        self.window.RefreshUI(fileName)

#------------------------------------------------------------------------------
class Mod_CleanMod(Link):
    """Fix fog on selected csll."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Nvidia Fog Fix'))
        menu.AppendItem(menuItem)
        menuItem.Enable(bool(self.data))

    def Execute(self,event):
        message = _(u'Apply Nvidia fog fix.  This modify fog values in interior cells to avoid the Nvidia black screen bug.')
        if not balt.askContinue(self.window,message,'bash.cleanMod.continue',
            _(u'Nvidia Fog Fix')):
            return
        with balt.Progress(_(u'Nvidia Fog Fix')) as progress:
            progress.setFull(len(self.data))
            fixed = []
            for index,fileName in enumerate(map(GPath,self.data)):
                if fileName.cs in bush.game.masterFiles: continue
                progress(index,_(u'Scanning')+fileName.s)
                fileInfo = bosh.modInfos[fileName]
                cleanMod = bosh.CleanMod(fileInfo)
                cleanMod.clean(SubProgress(progress,index,index+1))
                if cleanMod.fixedCells:
                    fixed.append(u'* %4d %s' % (len(cleanMod.fixedCells),fileName.s))
        if fixed:
            message = u'==='+_(u'Cells Fixed')+u':\n'+u'\n'.join(fixed)
            balt.showWryeLog(self.window,message,_(u'Nvidia Fog Fix'),
                             icons=bashBlue)
        else:
            message = _(u'No changes required.')
            balt.showOk(self.window,message,_(u'Nvidia Fog Fix'))

#------------------------------------------------------------------------------
class Mod_CreateBlankBashedPatch(Link):
    """Create a new bashed patch."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'New Bashed Patch...'))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        newPatchName = bosh.PatchFile.generateNextBashedPatch(self.window)
        if newPatchName is not None:
            self.window.RefreshUI(detail=newPatchName)

#------------------------------------------------------------------------------
class Mod_CreateBlank(Link):
    """Create a new blank mod."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'New Mod...'))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        data = self.window.GetSelected()
        fileInfos = self.window.data
        count = 0
        newName = GPath(u'New Mod.esp')
        while newName in fileInfos:
            count += 1
            newName = GPath(u'New Mod %d.esp' % count)
        newInfo = fileInfos.factory(fileInfos.dir,newName)
        if data:
            newTime = max(fileInfos[x].mtime for x in data)
        else:
            newTime = max(fileInfos[x].mtime for x in fileInfos.data)
        newInfo.mtime = fileInfos.getFreeTime(newTime,newTime)
        newFile = bosh.ModFile(newInfo,bosh.LoadFactory(True))
        newFile.tes4.masters = [GPath(bush.game.masterFiles[0])]
        newFile.safeSave()
        mod_group = fileInfos.table.getColumn('group')
        mod_group[newName] = mod_group.get(newName,u'')
        bosh.modInfos.refresh()
        self.window.RefreshUI(detail=newName)

#------------------------------------------------------------------------------
class Mod_CreateDummyMasters(Link):
    """TES4Edit tool, makes dummy plugins for each missing master, for use if looking at a 'Filter' patch."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Create Dummy Masters...'))
        menu.AppendItem(menuItem)
        if len(data) == 1 and bosh.modInfos[data[0]].getStatus() == 30: # Missing masters
            menuItem.Enable(True)
        else:
            menuItem.Enable(False)

    def Execute(self,event):
        """Handle execution."""
        if not balt.askYes(self.window,
                           _(u"This is an advanced feature for editing 'Filter' patches in TES4Edit.  It will create dummy plugins for each missing master.  Are you sure you want to continue?")
                           + u'\n\n' +
                           _(u"To remove these files later, use 'Clean Dummy Masters...'"),
                           _(u'Create Files')):
            return
        doCBash = False #settings['bash.CBashEnabled'] - something odd's going on, can't rename temp names
        modInfo = bosh.modInfos[self.data[0]]
        lastTime = modInfo.mtime - 1
        if doCBash:
            newFiles = []
        refresh = []
        for master in modInfo.header.masters:
            if master in bosh.modInfos:
                lastTime = bosh.modInfos[master].mtime
                continue
            # Missing master, create a dummy plugin for it
            newInfo = bosh.ModInfo(modInfo.dir,master)
            newTime = lastTime
            newInfo.mtime = bosh.modInfos.getFreeTime(newTime,newTime)
            refresh.append(master)
            if doCBash:
                # TODO: CBash doesn't handle unicode.  Make this make temp unicode safe
                # files, then rename them to the correct unicode name later
                newFiles.append(newInfo.getPath().stail)
            else:
                newFile = bosh.ModFile(newInfo,bosh.LoadFactory(True))
                newFile.tes4.author = u'BASHED DUMMY'
                newFile.safeSave()
        if doCBash:
            with ObCollection(ModsPath=bosh.dirs['mods'].s) as Current:
                tempname = u'_DummyMaster.esp.tmp'
                modFile = Current.addMod(tempname, CreateNew=True)
                Current.load()
                modFile.TES4.author = u'BASHED DUMMY'
                for newFile in newFiles:
                    modFile.save(CloseCollection=False,DestinationName=newFile)
        bashFrame.RefreshData()
        self.window.RefreshUI()

class Mods_CleanDummyMasters(Link):
    """Clean up after using a 'Create Dummy Masters...' command"""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Remove Dummy Masters...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(False)
        for fileName in bosh.modInfos.data:
            fileInfo = bosh.modInfos[fileName]
            if fileInfo.header.author == u'BASHED DUMMY':
                menuItem.Enable(True)
                break

    def Execute(self,event):
        """Handle execution."""
        remove = []
        for fileName in bosh.modInfos.data:
            fileInfo = bosh.modInfos[fileName]
            if fileInfo.header.author == u'BASHED DUMMY':
                remove.append(fileName)
        remove = bosh.modInfos.getOrdered(remove)
        message = [u'',_(u'Uncheck items to skip deleting them if desired.')]
        message.extend(remove)
        dialog = ListBoxes(bashFrame,_(u'Delete Dummy Masters'),
                     _(u'Delete these items? This operation cannot be undone.'),
                     [message])
        if dialog.ShowModal() == wx.ID_CANCEL:
            dialog.Destroy()
            return
        id = dialog.ids[u'']
        checks = dialog.FindWindowById(id)
        if checks:
            for i,mod in enumerate(remove):
                if checks.IsChecked(i):
                    self.window.data.delete(mod)
        dialog.Destroy()
        bashFrame.RefreshData()
        self.window.RefreshUI()

#------------------------------------------------------------------------------
class Mod_FactionRelations_Export(Link):
    """Export faction relations from mod to text file."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Relations...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(bool(self.data))

    def Execute(self,event):
        fileName = GPath(self.data[0])
        fileInfo = bosh.modInfos[fileName]
        textName = fileName.root+u'_Relations.csv'
        textDir = bosh.dirs['patches']
        textDir.makedirs()
        #--File dialog
        textPath = balt.askSave(self.window,_(u'Export faction relations to:'),
                                textDir,textName, u'*_Relations.csv')
        if not textPath: return
        (textDir,textName) = textPath.headTail
        #--Export
        with balt.Progress(_(u'Export Relations')) as progress:
            if CBash:
                factionRelations = bosh.CBash_FactionRelations()
            else:
                factionRelations = bosh.FactionRelations()
            readProgress = SubProgress(progress,0.1,0.8)
            readProgress.setFull(len(self.data))
            for index,fileName in enumerate(map(GPath,self.data)):
                fileInfo = bosh.modInfos[fileName]
                readProgress(index,_(u'Reading')+u' '+fileName.s+u'.')
                factionRelations.readFromMod(fileInfo)
            progress(0.8,_(u'Exporting to')+u' '+textName.s+u'.')
            factionRelations.writeToText(textPath)
            progress(1.0,_(u'Done.'))

#------------------------------------------------------------------------------
class Mod_FactionRelations_Import(Link):
    """Imports faction relations from text file to mod."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Relations...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(len(self.data)==1)

    def Execute(self,event):
        message = (_(u"This command will import faction relation info from a previously exported file.")
                   + u'\n\n' +
                   _(u"See the Bash help file for more info."))
        if not balt.askContinue(self.window,message,
                'bash.factionRelations.import.continue',_(u'Import Relations')):
            return
        fileName = GPath(self.data[0])
        fileInfo = bosh.modInfos[fileName]
        textName = fileName.root+u'_Relations.csv'
        textDir = bosh.dirs['patches']
        #--File dialog
        textPath = balt.askOpen(self.window,_(u'Import faction relations from:'),
            textDir, textName, u'*_Relations.csv',mustExist=True)
        if not textPath: return
        (textDir,textName) = textPath.headTail
        #--Extension error check
        ext = textName.cext
        if ext != u'.csv':
            balt.showError(self.window,_(u'Source file must be a _Relations.csv file.'))
            return
        #--Export
        changed = None
        with balt.Progress(_(u'Import Relations')) as progress:
            if CBash:
                factionRelations = bosh.CBash_FactionRelations()
            else:
                factionRelations = bosh.FactionRelations()
            progress(0.1,_(u'Reading')+u' '+textName.s+u'.')
            factionRelations.readFromText(textPath)
            progress(0.2,_(u'Applying to')+u' '+fileName.s+u'.')
            changed = factionRelations.writeToMod(fileInfo)
            progress(1.0,_(u'Done.'))
        #--Log
        if not changed:
            balt.showOk(self.window,
                _(u'No relevant faction relations to import.'),
                _(u'Import Relations'))
        else:
            buff = StringIO.StringIO()
            buff.write(u'* %03d  %s\n' % (changed, fileName.s))
            text = buff.getvalue()
            buff.close()
            balt.showLog(self.window,text,_(u'Import Relations'),icons=bashBlue)

#------------------------------------------------------------------------------
class Mod_Factions_Export(Link):
    """Export factions from mod to text file."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Factions...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(bool(self.data))

    def Execute(self,event):
        fileName = GPath(self.data[0])
        fileInfo = bosh.modInfos[fileName]
        textName = fileName.root+u'_Factions.csv'
        textDir = bosh.dirs['patches']
        textDir.makedirs()
        #--File dialog
        textPath = balt.askSave(self.window,_(u'Export factions to:'),textDir,
                                textName, u'*_Factions.csv')
        if not textPath: return
        (textDir,textName) = textPath.headTail
        #--Export
        with balt.Progress(_(u'Export Factions')) as progress:
            if CBash:
                actorFactions = bosh.CBash_ActorFactions()
            else:
                actorFactions = bosh.ActorFactions()
            readProgress = SubProgress(progress,0.1,0.8)
            readProgress.setFull(len(self.data))
            for index,fileName in enumerate(map(GPath,self.data)):
                fileInfo = bosh.modInfos[fileName]
                readProgress(index,_(u'Reading')+u' '+fileName.s+u'.')
                actorFactions.readFromMod(fileInfo)
            progress(0.8,_(u'Exporting to ')+u' '+textName.s+u'.')
            actorFactions.writeToText(textPath)
            progress(1.0,_(u'Done.'))

#------------------------------------------------------------------------------
class Mod_Factions_Import(Link):
    """Imports factions from text file to mod."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Factions...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(len(self.data)==1)

    def Execute(self,event):
        message = (_(u"This command will import faction ranks from a previously exported file.")
                   + u'\n\n' +
                   _(u'See the Bash help file for more info.'))
        if not balt.askContinue(self.window,message,
                'bash.factionRanks.import.continue',_(u'Import Factions')):
            return
        fileName = GPath(self.data[0])
        fileInfo = bosh.modInfos[fileName]
        textName = fileName.root+u'_Factions.csv'
        textDir = bosh.dirs['patches']
        #--File dialog
        textPath = balt.askOpen(self.window,_(u'Import Factions from:'),
            textDir, textName, u'*_Factions.csv',mustExist=True)
        if not textPath: return
        (textDir,textName) = textPath.headTail
        #--Extension error check
        ext = textName.cext
        if ext != u'.csv':
            balt.showError(self.window,
                _(u'Source file must be a _Factions.csv file.'))
            return
        #--Export
        changed = None
        with balt.Progress(_(u'Import Factions')) as progress:
            if CBash:
                actorFactions = bosh.CBash_ActorFactions()
            else:
                actorFactions = bosh.ActorFactions()
            progress(0.1,_(u'Reading')+u' '+textName.s+u'.')
            actorFactions.readFromText(textPath)
            progress(0.2,_(u'Applying to')+u' '+fileName.s+u'.')
            changed = actorFactions.writeToMod(fileInfo)
            progress(1.0,_(u'Done.'))
        #--Log
        if not changed:
            balt.showOk(self.window,_(u'No relevant faction ranks to import.'),
                        _(u'Import Factions'))
        else:
            buff = StringIO.StringIO()
            for groupName in sorted(changed):
                buff.write(u'* %s : %03d  %s\n' % (groupName,changed[groupName],fileName.s))
            text = buff.getvalue()
            buff.close()
            balt.showLog(self.window,text,_(u'Import Factions'),icons=bashBlue)

#------------------------------------------------------------------------------
class Mod_MarkLevelers(Link):
    """Marks (tags) selected mods as Delevs and/or Relevs according to Leveled Lists.csv."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Mark Levelers...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(bool(data))

    def Execute(self,event):
        message = _(u'Obsolete. Mods are now automatically tagged when possible.')
        balt.showInfo(self.window,message,_(u'Mark Levelers'))

#------------------------------------------------------------------------------
class Mod_MarkMergeable(Link):
    """Returns true if can act as patch mod."""
    def __init__(self,doCBash):
        Link.__init__(self)
        self.doCBash = doCBash

    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        if self.doCBash:
            title = _(u'Mark Mergeable (CBash)...')
        else:
            title = _(u'Mark Mergeable...')
        menuItem = wx.MenuItem(menu,self.id,title)
        menu.AppendItem(menuItem)
        menuItem.Enable(bool(data))

    def Execute(self,event):
        yes,no = [],[]
        mod_mergeInfo = bosh.modInfos.table.getColumn('mergeInfo')
        for fileName in map(GPath,self.data):
            if not self.doCBash and bosh.reOblivion.match(fileName.s): continue
            fileInfo = bosh.modInfos[fileName]
            if self.doCBash:
                if fileName == u"Oscuro's_Oblivion_Overhaul.esp":
                    reason = u'\n.    '+_(u'Marked non-mergeable at request of mod author.')
                else:
                    reason = bosh.CBash_PatchFile.modIsMergeable(fileInfo,True)
            else:
                reason = bosh.PatchFile.modIsMergeable(fileInfo,True)

            if reason == True:
                mod_mergeInfo[fileName] = (fileInfo.size,True)
                yes.append(fileName)
            else:
                if (u'\n.    '+_(u"Has 'NoMerge' tag.")) in reason:
                    mod_mergeInfo[fileName] = (fileInfo.size,True)
                else:
                    mod_mergeInfo[fileName] = (fileInfo.size,False)
                no.append(u"%s:%s" % (fileName.s,reason))
        message = u'== %s ' % ([u'Python',u'CBash'][self.doCBash])+_(u'Mergeability')+u'\n\n'
        if yes:
            message += u'=== '+_(u'Mergeable')+u'\n* '+u'\n\n* '.join(x.s for x in yes)
        if yes and no:
            message += u'\n\n'
        if no:
            message += u'=== '+_(u'Not Mergeable')+u'\n* '+'\n\n* '.join(no)
        self.window.RefreshUI(yes)
        self.window.RefreshUI(no)
        if message != u'':
            balt.showWryeLog(self.window,message,_(u'Mark Mergeable'),icons=bashBlue)

#------------------------------------------------------------------------------
class Mod_CopyToEsmp(Link):
    """Create an esp(esm) copy of selected esm(esp)."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        fileInfo = bosh.modInfos[data[0]]
        isEsm = fileInfo.isEsm()
        self.label = _(u'Copy to Esp') if fileInfo.isEsm() else _(u'Copy to Esm')
        menuItem = wx.MenuItem(menu,self.id,self.label)
        menu.AppendItem(menuItem)
        for item in data:
            fileInfo = bosh.modInfos[item]
            if fileInfo.isInvertedMod() or fileInfo.isEsm() != isEsm:
                menuItem.Enable(False)
                return

    def Execute(self,event):
        for item in self.data:
            fileInfo = bosh.modInfos[item]
            newType = (fileInfo.isEsm() and u'esp') or u'esm'
            modsDir = fileInfo.dir
            curName = fileInfo.name
            newName = curName.root+u'.'+newType
            #--Replace existing file?
            if modsDir.join(newName).exists():
                if not balt.askYes(self.window,_(u'Replace existing %s?') % (newName.s,),self.label):
                    continue
                bosh.modInfos[newName].makeBackup()
            #--New Time
            modInfos = bosh.modInfos
            timeSource = (curName,newName)[newName in modInfos]
            newTime = modInfos[timeSource].mtime
            #--Copy, set type, update mtime.
            modInfos.copy(curName,modsDir,newName,newTime)
            modInfos.table.copyRow(curName,newName)
            newInfo = modInfos[newName]
            newInfo.setType(newType)
            newInfo.setmtime(newTime)
            #--Repopulate
            self.window.RefreshUI(detail=newName)

#------------------------------------------------------------------------------
class Mod_Face_Import(Link):
    """Imports a face from a save to an esp."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Face...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(len(data) == 1)

    def Execute(self,event):
        #--Select source face file
        srcDir = bosh.saveInfos.dir
        wildcard = _(u'%s Files')%bush.game.name+u' (*.ess;*.esr)|*.ess;*.esr'
        #--File dialog
        srcPath = balt.askOpen(self.window,_(u'Face Source:'),srcDir, u'', wildcard,mustExist=True)
        if not srcPath: return
        #--Get face
        srcDir,srcName = srcPath.headTail
        srcInfo = bosh.SaveInfo(srcDir,srcName)
        srcFace = bosh.PCFaces.save_getFace(srcInfo)
        #--Save Face
        fileName = GPath(self.data[0])
        fileInfo = self.window.data[fileName]
        npc = bosh.PCFaces.mod_addFace(fileInfo,srcFace)
        #--Save Face picture?
        imagePath = bosh.modInfos.dir.join(u'Docs',u'Images',npc.eid+u'.jpg')
        if not imagePath.exists():
            srcInfo.getHeader()
            width,height,data = srcInfo.header.image
            image = wx.EmptyImage(width,height)
            image.SetData(data)
            imagePath.head.makedirs()
            image.SaveFile(imagePath.s,wx.BITMAP_TYPE_JPEG)
        self.window.RefreshUI()
        balt.showOk(self.window,_(u'Imported face to: %s') % npc.eid,fileName.s)

#------------------------------------------------------------------------------
class Mod_FlipMasters(Link):
    """Swaps masters between esp and esm versions."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Esmify Masters'))
        menu.AppendItem(menuItem)
        #--FileInfo
        fileInfo = self.fileInfo = window.data[data[0]]
        menuItem.Enable(False)
        self.toEsp = False
        if len(data) == 1 and len(fileInfo.header.masters) > 1:
            espMasters = [master for master in fileInfo.header.masters if bosh.reEspExt.search(master.s)]
            if not espMasters: return
            for masterName in espMasters:
                masterInfo = bosh.modInfos.get(GPath(masterName),None)
                if masterInfo and masterInfo.isInvertedMod():
                    menuItem.SetText(_(u'Espify Masters'))
                    self.toEsm = False
                    break
            else:
                self.toEsm = True
            menuItem.Enable(True)

    def Execute(self,event):
        message = _(u"WARNING! For advanced modders only! Flips esp/esm bit of esp masters to convert them to/from esm state. Useful for building/analyzing esp mastered mods.")
        if not balt.askContinue(self.window,message,'bash.flipMasters.continue'):
            return
        fileName = GPath(self.data[0])
        fileInfo = bosh.modInfos[fileName]
        updated = [fileName]
        espMasters = [GPath(master) for master in fileInfo.header.masters
            if bosh.reEspExt.search(master.s)]
        for masterPath in espMasters:
            masterInfo = bosh.modInfos.get(masterPath,None)
            if masterInfo:
                masterInfo.header.flags1.esm = self.toEsm
                masterInfo.writeHeader()
                updated.append(masterPath)
        self.window.RefreshUI(updated,fileName)

#------------------------------------------------------------------------------
class Mod_FlipSelf(Link):
    """Flip an esp(esm) to an esm(esp)."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        fileInfo = bosh.modInfos[data[0]]
        isEsm = fileInfo.isEsm()
        self.label = _(u'Espify Self') if isEsm else _(u'Esmify Self')
        menuItem = wx.MenuItem(menu,self.id,self.label)
        menu.AppendItem(menuItem)
        for item in data:
            fileInfo = bosh.modInfos[item]
            if fileInfo.isEsm() != isEsm or not item.cext[-1] == u'p':
                menuItem.Enable(False)
                return

    def Execute(self,event):
        message = (_(u'WARNING! For advanced modders only!')
                   + u'\n\n' +
                   _(u'This command flips an internal bit in the mod, converting an esp to an esm and vice versa.  Note that it is this bit and NOT the file extension that determines the esp/esm state of the mod.')
                   )
        if not balt.askContinue(self.window,message,'bash.flipToEsmp.continue',_(u'Flip to Esm')):
            return
        for item in self.data:
            fileInfo = bosh.modInfos[item]
            header = fileInfo.header
            header.flags1.esm = not header.flags1.esm
            fileInfo.writeHeader()
            #--Repopulate
            self.window.RefreshUI(detail=fileInfo.name)


#------------------------------------------------------------------------------
class Mod_LabelsData(balt.ListEditorData):
    """Data capsule for label editing dialog."""
    def __init__(self,parent,strings):
        """Initialize."""
        #--Strings
        self.column = strings.column
        self.setKey = strings.setKey
        self.addPrompt = strings.addPrompt
        #--Key/type
        self.data = settings[self.setKey]
        #--GUI
        balt.ListEditorData.__init__(self,parent)
        self.showAdd = True
        self.showRename = True
        self.showRemove = True

    def getItemList(self):
        """Returns load list keys in alpha order."""
        return sorted(self.data,key=lambda a: a.lower())

    def add(self):
        """Adds a new group."""
        #--Name Dialog
        #--Dialog
        dialog = wx.TextEntryDialog(self.parent,self.addPrompt)
        result = dialog.ShowModal()
        #--Okay?
        if result != wx.ID_OK:
            dialog.Destroy()
            return
        newName = dialog.GetValue()
        dialog.Destroy()
        if newName in self.data:
            balt.showError(self.parent,_(u'Name must be unique.'))
            return False
        elif len(newName) == 0 or len(newName) > 64:
            balt.showError(self.parent,
                _(u'Name must be between 1 and 64 characters long.'))
            return False
        settings.setChanged(self.setKey)
        self.data.append(newName)
        self.data.sort()
        return newName

    def rename(self,oldName,newName):
        """Renames oldName to newName."""
        #--Right length?
        if len(newName) == 0 or len(newName) > 64:
            balt.showError(self.parent,
                _(u'Name must be between 1 and 64 characters long.'))
            return False
        #--Rename
        settings.setChanged(self.setKey)
        self.data.remove(oldName)
        self.data.append(newName)
        self.data.sort()
        #--Edit table entries.
        colGroup = bosh.modInfos.table.getColumn(self.column)
        for fileName in colGroup.keys():
            if colGroup[fileName] == oldName:
                colGroup[fileName] = newName
        self.parent.PopulateItems()
        #--Done
        return newName

    def remove(self,item):
        """Removes group."""
        settings.setChanged(self.setKey)
        self.data.remove(item)
        #--Edit table entries.
        colGroup = bosh.modInfos.table.getColumn(self.column)
        for fileName in colGroup.keys():
            if colGroup[fileName] == item:
                del colGroup[fileName]
        self.parent.PopulateItems()
        #--Done
        return True

#------------------------------------------------------------------------------
class Mod_Labels:
    """Add mod label links."""
    def __init__(self):
        """Initialize."""
        self.labels = settings[self.setKey]

    def GetItems(self):
        items = self.labels[:]
        items.sort(key=lambda a: a.lower())
        return items

    def AppendToMenu(self,menu,window,data):
        """Append label list to menu."""
        self.window = window
        self.data = data
        menu.Append(self.idList.EDIT,self.editMenu)
        menu.AppendSeparator()
        menu.Append(self.idList.NONE,_(u'None'))
        for id,item in zip(self.idList,self.GetItems()):
            menu.Append(id,item)
        #--Events
        wx.EVT_MENU(bashFrame,self.idList.EDIT,self.DoEdit)
        wx.EVT_MENU(bashFrame,self.idList.NONE,self.DoNone)
        wx.EVT_MENU_RANGE(bashFrame,self.idList.BASE,self.idList.MAX,self.DoList)

    def DoNone(self,event):
        """Handle selection of None."""
        fileLabels = bosh.modInfos.table.getColumn(self.column)
        for fileName in self.data:
            fileLabels[fileName] = u''
        self.window.PopulateItems()

    def DoList(self,event):
        """Handle selection of label."""
        label = self.GetItems()[event.GetId()-self.idList.BASE]
        fileLabels = bosh.modInfos.table.getColumn(self.column)
        for fileName in self.data:
            fileLabels[fileName] = label
        if isinstance(self,Mod_Groups) and bosh.modInfos.refresh(doInfos=False):
            modList.SortItems()
        self.window.RefreshUI()

    def DoEdit(self,event):
        """Show label editing dialog."""
        data = Mod_LabelsData(self.window,self)
        dialog = balt.ListEditor(self.window,-1,self.editWindow,data)
        dialog.ShowModal()
        dialog.Destroy()

#------------------------------------------------------------------------------
class Mod_Groups(Mod_Labels):
    """Add mod group links."""
    def __init__(self):
        """Initialize."""
        self.column     = 'group'
        self.setKey     = 'bash.mods.groups'
        self.editMenu   = _(u'Edit Groups...')
        self.editWindow = _(u'Groups')
        self.addPrompt  = _(u'Add group:')
        self.idList     = ID_GROUPS
        Mod_Labels.__init__(self)

    def AppendToMenu(self,menu,window,data):
        """Append label list to menu."""
        #--For group labels
        if not settings.get('bash.balo.full'):
            Mod_Labels.AppendToMenu(self,menu,window,data)

#------------------------------------------------------------------------------
class Mod_Groups_Export(Link):
    """Export mod groups to text file."""
    def AppendToMenu(self,menu,window,data):
        data = bosh.ModGroups.filter(data)
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Groups...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(bool(self.data))

    def Execute(self,event):
        fileName = GPath(self.data[0])
        fileInfo = bosh.modInfos[fileName]
        textName = u'My_Groups.csv'
        textDir = bosh.dirs['patches']
        textDir.makedirs()
        #--File dialog
        textPath = balt.askSave(self.window,_(u'Export groups to:'),textDir,textName, u'*_Groups.csv')
        if not textPath: return
        (textDir,textName) = textPath.headTail
        #--Export
        modGroups = bosh.ModGroups()
        modGroups.readFromModInfos(self.data)
        modGroups.writeToText(textPath)
        balt.showOk(self.window,
            _(u"Exported %d mod/groups.") % (len(modGroups.mod_group),),
            _(u"Export Groups"))

#------------------------------------------------------------------------------
class Mod_Groups_Import(Link):
    """Import editor ids from text file or other mod."""
    def AppendToMenu(self,menu,window,data):
        data = bosh.ModGroups.filter(data)
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Groups...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(bool(self.data))

    def Execute(self,event):
        message = _(u"Import groups from a text file. Any mods that are moved into new auto-sorted groups will be immediately reordered.")
        if not balt.askContinue(self.window,message,'bash.groups.import.continue',
            _(u'Import Groups')):
            return
        textDir = bosh.dirs['patches']
        #--File dialog
        textPath = balt.askOpen(self.window,_(u'Import names from:'),textDir,
            u'', u'*_Groups.csv',mustExist=True)
        if not textPath: return
        (textDir,textName) = textPath.headTail
        #--Extension error check
        if textName.cext != u'.csv':
            balt.showError(self.window,_(u'Source file must be a csv file.'))
            return
        #--Import
        modGroups = bosh.ModGroups()
        modGroups.readFromText(textPath)
        changed = modGroups.writeToModInfos(self.data)
        bosh.modInfos.refresh()
        self.window.RefreshUI()
        balt.showOk(self.window,
            _(u"Imported %d mod/groups (%d changed).") % (len(modGroups.mod_group),changed),
            _(u"Import Groups"))

#------------------------------------------------------------------------------
class Mod_EditorIds_Export(Link):
    """Export editor ids from mod to text file."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Editor Ids...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(bool(self.data))

    def Execute(self,event):
        fileName = GPath(self.data[0])
        fileInfo = bosh.modInfos[fileName]
        textName = fileName.root+u'_Eids.csv'
        textDir = bosh.dirs['patches']
        textDir.makedirs()
        #--File dialog
        textPath = balt.askSave(self.window,_(u'Export eids to:'),textDir,textName, u'*_Eids.csv')
        if not textPath: return
        (textDir,textName) = textPath.headTail
        #--Export
        with balt.Progress(_(u"Export Editor Ids")) as progress:
            if CBash:
                editorIds = bosh.CBash_EditorIds()
            else:
                editorIds = bosh.EditorIds()
            readProgress = SubProgress(progress,0.1,0.8)
            readProgress.setFull(len(self.data))
            for index,fileName in enumerate(map(GPath,self.data)):
                fileInfo = bosh.modInfos[fileName]
                readProgress(index,_(u"Reading %s.") % (fileName.s,))
                editorIds.readFromMod(fileInfo)
            progress(0.8,_(u"Exporting to %s.") % (textName.s,))
            editorIds.writeToText(textPath)
            progress(1.0,_(u"Done."))

#------------------------------------------------------------------------------
class Mod_EditorIds_Import(Link):
    """Import editor ids from text file or other mod."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Editor Ids...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(len(self.data)==1)

    def Execute(self,event):
        message = (_(u"Import editor ids from a text file. This will replace existing ids and is not reversible!"))
        if not balt.askContinue(self.window,message,'bash.editorIds.import.continue',
            _(u'Import Editor Ids')):
            return
        fileName = GPath(self.data[0])
        fileInfo = bosh.modInfos[fileName]
        textName = fileName.root+u'_Eids.csv'
        textDir = bosh.dirs['patches']
        #--File dialog
        textPath = balt.askOpen(self.window,_(u'Import names from:'),textDir,
            textName, u'*_Eids.csv',mustExist=True)
        if not textPath: return
        (textDir,textName) = textPath.headTail
        #--Extension error check
        if textName.cext != u'.csv':
            balt.showError(self.window,_(u'Source file must be a csv file.'))
            return
        #--Import
        questionableEidsSet = set()
        badEidsList = []
        try:
            changed = None
            with balt.Progress(_(u"Import Editor Ids")) as progress:
                if CBash:
                    editorIds = bosh.CBash_EditorIds()
                else:
                    editorIds = bosh.EditorIds()
                progress(0.1,_(u"Reading %s.") % (textName.s,))
                editorIds.readFromText(textPath,questionableEidsSet,badEidsList)
                progress(0.2,_(u"Applying to %s.") % (fileName.s,))
                changed = editorIds.writeToMod(fileInfo)
                progress(1.0,_(u"Done."))
            #--Log
            if not changed:
                balt.showOk(self.window,_(u"No changes required."))
            else:
                buff = StringIO.StringIO()
                format = u"%s'%s' >> '%s'\n"
                for old,new in sorted(changed):
                    if new in questionableEidsSet:
                        prefix = u'* '
                    else:
                        prefix = u''
                    buff.write(format % (prefix,old,new))
                if questionableEidsSet:
                    buff.write(u'\n* '+_(u'These editor ids begin with numbers and may therefore cause the script compiler to generate unexpected results')+u'\n')
                if badEidsList:
                    buff.write(u'\n'+_(u'The following EIDs are malformed and were not imported:')+u'\n')
                    for badEid in badEidsList:
                        buff.write(u"  '%s'\n" % badEid)
                text = buff.getvalue()
                buff.close()
                balt.showLog(self.window,text,_(u'Objects Changed'),icons=bashBlue)
        except bolt.BoltError as e:
            balt.showWarning(self.window,'%'%e)

#------------------------------------------------------------------------------
class Mod_DecompileAll(Link):
    """Removes effects of a "recompile all" on the mod."""

    def AppendToMenu(self,menu,window,data):
        """Append link to a menu."""
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Decompile All'))
        menu.AppendItem(menuItem)
        menuItem.Enable(len(self.data) != 1 or (not bosh.reOblivion.match(self.data[0].s)))


    def Execute(self,event):
        message = _(u"This command will remove the effects of a 'compile all' by removing all scripts whose texts appear to be identical to the version that they override.")
        if not balt.askContinue(self.window,message,'bash.decompileAll.continue',_(u'Decompile All')):
            return
        for item in self.data:
            fileName = GPath(item)
            if bosh.reOblivion.match(fileName.s):
                balt.showWarning(self.window,_(u"Skipping %s") % fileName.s,_(u'Decompile All'))
                continue
            fileInfo = bosh.modInfos[fileName]
            loadFactory = bosh.LoadFactory(True,bosh.MreRecord.type_class['SCPT'])
            modFile = bosh.ModFile(fileInfo,loadFactory)
            modFile.load(True)
            badGenericLore = False
            removed = []
            id_text = {}
            if modFile.SCPT.getNumRecords(False):
                loadFactory = bosh.LoadFactory(False,bosh.MreRecord.type_class['SCPT'])
                for master in modFile.tes4.masters:
                    masterFile = bosh.ModFile(bosh.modInfos[master],loadFactory)
                    masterFile.load(True)
                    mapper = masterFile.getLongMapper()
                    for record in masterFile.SCPT.getActiveRecords():
                        id_text[mapper(record.fid)] = record.scriptText
                mapper = modFile.getLongMapper()
                newRecords = []
                for record in modFile.SCPT.records:
                    fid = mapper(record.fid)
                    #--Special handling for genericLoreScript
                    if (fid in id_text and record.fid == 0x00025811 and
                        record.compiledSize == 4 and record.lastIndex == 0):
                        removed.append(record.eid)
                        badGenericLore = True
                    elif fid in id_text and id_text[fid] == record.scriptText:
                        removed.append(record.eid)
                    else:
                        newRecords.append(record)
                modFile.SCPT.records = newRecords
                modFile.SCPT.setChanged()
            if len(removed) >= 50 or badGenericLore:
                modFile.safeSave()
                balt.showOk(self.window,
                            (_(u'Scripts removed: %d.')
                             + u'\n' +
                             _(u'Scripts remaining: %d')
                             ) % (len(removed),len(modFile.SCPT.records)),
                            fileName.s)
            elif removed:
                balt.showOk(self.window,_(u"Only %d scripts were identical.  This is probably intentional, so no changes have been made.") % len(removed),fileName.s)
            else:
                balt.showOk(self.window,_(u"No changes required."),fileName.s)

#------------------------------------------------------------------------------
class Mod_Fids_Replace(Link):
    """Replace fids according to text file."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Form IDs...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(len(self.data)==1)

    def Execute(self,event):
        message = _(u"For advanced modders only! Systematically replaces one set of Form Ids with another in npcs, creatures, containers and leveled lists according to a Replacers.csv file.")
        if not balt.askContinue(self.window,message,'bash.formIds.replace.continue',
            _(u'Import Form IDs')):
            return
        fileName = GPath(self.data[0])
        fileInfo = bosh.modInfos[fileName]
        textDir = bosh.dirs['patches']
        #--File dialog
        textPath = balt.askOpen(self.window,_(u'Form ID mapper file:'),textDir,
            u'', u'*_Formids.csv',mustExist=True)
        if not textPath: return
        (textDir,textName) = textPath.headTail
        #--Extension error check
        if textName.cext != u'.csv':
            balt.showError(self.window,_(u'Source file must be a csv file.'))
            return
        #--Export
        changed = None
        with balt.Progress(_(u"Import Form IDs")) as progress:
            if CBash:
                replacer = bosh.CBash_FidReplacer()
            else:
                replacer = bosh.FidReplacer()
            progress(0.1,_(u"Reading %s.") % textName.s)
            replacer.readFromText(textPath)
            progress(0.2,_(u"Applying to %s.") % fileName.s)
            changed = replacer.updateMod(fileInfo)
            progress(1.0,_(u"Done."))
        #--Log
        if not changed:
            balt.showOk(self.window,_(u"No changes required."))
        else:
            balt.showLog(self.window,changed,_(u'Objects Changed'),icons=bashBlue)

#------------------------------------------------------------------------------
class Mod_FullNames_Export(Link):
    """Export full names from mod to text file."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Names...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(bool(self.data))

    def Execute(self,event):
        fileName = GPath(self.data[0])
        fileInfo = bosh.modInfos[fileName]
        textName = fileName.root+u'_Names.csv'
        textDir = bosh.dirs['patches']
        textDir.makedirs()
        #--File dialog
        textPath = balt.askSave(self.window,_(u'Export names to:'),
            textDir,textName, u'*_Names.csv')
        if not textPath: return
        (textDir,textName) = textPath.headTail
        #--Export
        with balt.Progress(_(u"Export Names")) as progress:
            if CBash:
                fullNames = bosh.CBash_FullNames()
            else:
                fullNames = bosh.FullNames()
            readProgress = SubProgress(progress,0.1,0.8)
            readProgress.setFull(len(self.data))
            for index,fileName in enumerate(map(GPath,self.data)):
                fileInfo = bosh.modInfos[fileName]
                readProgress(index,_(u"Reading %s.") % fileName.s)
                fullNames.readFromMod(fileInfo)
            progress(0.8,_(u"Exporting to %s.") % textName.s)
            fullNames.writeToText(textPath)
            progress(1.0,_(u"Done."))

#------------------------------------------------------------------------------
class Mod_FullNames_Import(Link):
    """Import full names from text file or other mod."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Names...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(len(self.data)==1)

    def Execute(self,event):
        message = (_(u"Import record names from a text file. This will replace existing names and is not reversible!"))
        if not balt.askContinue(self.window,message,'bash.fullNames.import.continue',
            _(u'Import Names')):
            return
        fileName = GPath(self.data[0])
        fileInfo = bosh.modInfos[fileName]
        textName = fileName.root+u'_Names.csv'
        textDir = bosh.dirs['patches']
        #--File dialog
        textPath = balt.askOpen(self.window,_(u'Import names from:'),
            textDir,textName, _(u'Mod/Text File')+u'|*_Names.csv;*.esp;*.esm',mustExist=True)
        if not textPath: return
        (textDir,textName) = textPath.headTail
        #--Extension error check
        ext = textName.cext
        if ext not in (u'.esp',u'.esm',u'.csv'):
            balt.showError(self.window,_(u'Source file must be mod (.esp or .esm) or csv file.'))
            return
        #--Export
        renamed = None
        with balt.Progress(_(u"Import Names")) as progress:
            if CBash:
                fullNames = bosh.CBash_FullNames()
            else:
                fullNames = bosh.FullNames()
            progress(0.1,_(u"Reading %s.") % textName.s)
            if ext == u'.csv':
                fullNames.readFromText(textPath)
            else:
                srcInfo = bosh.ModInfo(textDir,textName)
                fullNames.readFromMod(srcInfo)
            progress(0.2,_(u"Applying to %s.") % fileName.s)
            renamed = fullNames.writeToMod(fileInfo)
            progress(1.0,_(u"Done."))
        #--Log
        if not renamed:
            balt.showOk(self.window,_(u"No changes required."))
        else:
            with sio() as buff:
                format = u'%s:   %s >> %s\n'
                #buff.write(format % (_(u'Editor Id'),_(u'Name')))
                for eid in sorted(renamed.keys()):
                    full,newFull = renamed[eid]
                    try:
                        buff.write(format % (eid,full,newFull))
                    except:
                        print u'unicode error:', (format, eid, full, newFull)
                balt.showLog(self.window,buff.getvalue(),_(u'Objects Renamed'),icons=bashBlue)

#------------------------------------------------------------------------------
class Mod_Patch_Update(Link):
    """Updates a Bashed Patch."""
    def __init__(self,doCBash=False):
        Link.__init__(self)
        self.doCBash = doCBash
        self.CBashMismatch = False

    def AppendToMenu(self,menu,window,data):
        """Append link to a menu."""
        Link.AppendToMenu(self,menu,window,data)
        if self.doCBash:
            title = _(u'Rebuild Patch (CBash *BETA*)...')
        else:
            title = _(u'Rebuild Patch...')
        enable = (len(self.data) == 1 and
            bosh.modInfos[self.data[0]].header.author in (u'BASHED PATCH',u'BASHED LISTS'))
        check = False
        # Detect if the patch was build with Python or CBash
        config = bosh.modInfos.table.getItem(self.data[0],'bash.patch.configs',{})
        thisIsCBash = bosh.CBash_PatchFile.configIsCBash(config)
        self.CBashMismatch = bool(thisIsCBash != self.doCBash)
        if enable and settings['bash.CBashEnabled']:
            menuItem = wx.MenuItem(menu,self.id,title,kind=wx.ITEM_RADIO)
        else:
            menuItem = wx.MenuItem(menu,self.id,title)
        menu.AppendItem(menuItem)
        menuItem.Enable(enable)
        if enable and settings['bash.CBashEnabled']:
            menuItem.Check(not self.CBashMismatch)

    def Execute(self,event):
        """Handle activation event."""
        # Create plugin dictionaries -- used later. Speeds everything up! Yay!
        fullLoadOrder   = bosh.modInfos.plugins.LoadOrder   #CDC used this cached value no need to requery

        index = 0
        for name in fullLoadOrder:
            bush.fullLoadOrder[name] = index
            index = index + 1

        fileName = GPath(self.data[0])
        fileInfo = bosh.modInfos[fileName]
        if not bosh.modInfos.ordered:
            balt.showWarning(self.window,
                             (_(u'That which does not exist cannot be patched.')
                              + u'\n' +
                              _(u'Load some mods and try again.')
                              ),
                              _(u'Existential Error'))
            return
        # Verify they want to build a previous Python patch in CBash mode, or vice versa
        if self.doCBash and not balt.askContinue(self.window,
            _(u"Building with CBash is cool.  It's faster and allows more things to be handled, but it is still in BETA.  If you have problems, post them in the official thread, then use the non-CBash build function."),
            'bash.patch.ReallyUseCBash.295'): # We'll re-enable this warning for each release, until CBash isn't beta anymore
            return
        importConfig = True
        if self.CBashMismatch:
            if not balt.askYes(self.window,
                    _(u"The patch you are rebuilding (%s) was created in %s mode.  You are trying to rebuild it using %s mode.  Should Wrye Bash attempt to import your settings (some may not be copied correctly)?  Selecting 'No' will load the bashed patch defaults.")
                        % (self.data[0].s,[u'CBash',u'Python'][self.doCBash],[u'Python',u'CBash'][self.doCBash]),
                    'bash.patch.CBashMismatch'):
                importConfig = False
        with balt.BusyCursor(): # just to show users that it hasn't stalled but is doing stuff.
            if self.doCBash:
                bosh.CBash_PatchFile.patchTime = fileInfo.mtime
                bosh.CBash_PatchFile.patchName = fileInfo.name
                nullProgress = bolt.Progress()
                bosh.modInfos.rescanMergeable(bosh.modInfos.data,nullProgress,True)
                self.window.RefreshUI()
            else:
                bosh.PatchFile.patchTime = fileInfo.mtime
                bosh.PatchFile.patchName = fileInfo.name
                if settings['bash.CBashEnabled']:
                    # CBash is enabled, so it's very likely that the merge info currently is from a CBash mode scan
                    with balt.Progress(_(u"Mark Mergeable")+u' '*30) as progress:
                        bosh.modInfos.rescanMergeable(bosh.modInfos.data,progress,False)
                    self.window.RefreshUI()

        #--Check if we should be deactivating some plugins
        ActivePriortoPatch = [x for x in bosh.modInfos.ordered if bosh.modInfos[x].mtime < fileInfo.mtime]
        unfiltered = [x for x in ActivePriortoPatch if u'Filter' in bosh.modInfos[x].getBashTags()]
        merge = [x for x in ActivePriortoPatch if u'NoMerge' not in bosh.modInfos[x].getBashTags() and x in bosh.modInfos.mergeable and x not in unfiltered]
        noMerge = [x for x in ActivePriortoPatch if u'NoMerge' in bosh.modInfos[x].getBashTags() and x in bosh.modInfos.mergeable and x not in unfiltered and x not in merge]
        deactivate = [x for x in ActivePriortoPatch if u'Deactivate' in bosh.modInfos[x].getBashTags() and not 'Filter' in bosh.modInfos[x].getBashTags() and x not in unfiltered and x not in merge and x not in noMerge]

        checklists = []
        unfilteredKey = _(u"Tagged 'Filter'")
        mergeKey = _(u"Mergeable")
        noMergeKey = _(u"Mergeable, but tagged 'NoMerge'")
        deactivateKey = _(u"Tagged 'Deactivate'")
        if unfiltered:
            group = [unfilteredKey,
                     _(u"These mods should be deactivated before building the patch, and then merged or imported into the Bashed Patch."),
                     ]
            group.extend(unfiltered)
            checklists.append(group)
        if merge:
            group = [mergeKey,
                     _(u"These mods are mergeable.  While it is not important to Wrye Bash functionality or the end contents of the Bashed Patch, it is suggested that they be deactivated and merged into the patch.  This helps avoid the Oblivion maximum esp/esm limit."),
                     ]
            group.extend(merge)
            checklists.append(group)
        if noMerge:
            group = [noMergeKey,
                     _(u"These mods are mergeable, but tagged 'NoMerge'.  They should be deactivated before building the patch and imported into the Bashed Patch."),
                     ]
            group.extend(noMerge)
            checklists.append(group)
        if deactivate:
            group = [deactivateKey,
                     _(u"These mods are tagged 'Deactivate'.  They should be deactivated before building the patch, and merged or imported into the Bashed Patch."),
                     ]
            group.extend(deactivate)
            checklists.append(group)
        if checklists:
            dialog = ListBoxes(bashFrame,_(u"Deactivate these mods prior to patching"),
                _(u"The following mods should be deactivated prior to building the patch."),
                checklists,changedlabels={wx.ID_CANCEL:_(u'Skip')})
            if dialog.ShowModal() != wx.ID_CANCEL:
                deselect = set()
                for (list,key) in [(unfiltered,unfilteredKey),
                                   (merge,mergeKey),
                                   (noMerge,noMergeKey),
                                   (deactivate,deactivateKey),
                                   ]:
                    if list:
                        id = dialog.ids[key]
                        checks = dialog.FindWindowById(id)
                        if checks:
                            for i,mod in enumerate(list):
                                if checks.IsChecked(i):
                                    deselect.add(mod)
                dialog.Destroy()
                if deselect:
                    with balt.BusyCursor():
                        for mod in deselect:
                            bosh.modInfos.unselect(mod,False)
                        bosh.modInfos.refreshInfoLists()
                        bosh.modInfos.plugins.save()
                        self.window.RefreshUI(detail=fileName)

        previousMods = set()
        missing = {}
        delinquent = {}
        for mod in bosh.modInfos.ordered:
            if mod == fileName: break
            for master in bosh.modInfos[mod].header.masters:
                if master not in bosh.modInfos.ordered:
                    missing.setdefault(mod,[]).append(master)
                elif master not in previousMods:
                    delinquent.setdefault(mod,[]).append(master)
            previousMods.add(mod)
        if missing or delinquent:
            warning = ListBoxes(bashFrame,_(u'Master Errors'),
                _(u'WARNING!')+u'\n'+_(u'The following mod(s) have master file error(s).  Please adjust your load order to rectify those problem(s) before continuing.  However you can still proceed if you want to.  Proceed?'),
                [[_(u'Missing Master Errors'),_(u'These mods have missing masters; which will make your game unusable, and you will probably have to regenerate your patch after fixing them.  So just go fix them now.'),missing],
                [_(u'Delinquent Master Errors'),_(u'These mods have delinquent masters which will make your game unusable and you quite possibly will have to regenerate your patch after fixing them.  So just go fix them now.'),delinquent]],
                liststyle='tree',style=wx.DEFAULT_DIALOG_STYLE|wx.RESIZE_BORDER,changedlabels={wx.ID_OK:_(u'Continue Despite Errors')})
            if warning.ShowModal() == wx.ID_CANCEL:
                return
        try:
            patchDialog = PatchDialog(self.window,fileInfo,self.doCBash,importConfig)
        except CancelError:
            return
        patchDialog.ShowModal()
        self.window.RefreshUI(detail=fileName)
        # save data to disc in case of later improper shutdown leaving the user guessing as to what options they built the patch with
        BashFrame.SaveSettings(bashFrame)

#------------------------------------------------------------------------------
class Mod_ListPatchConfig(Link):
    """Lists the Bashed Patch configuration and copies to the clipboard."""
    def AppendToMenu(self,menu,window,data):
        """Append link to a menu."""
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'List Patch Config...'))
        menu.AppendItem(menuItem)
        enable = (len(self.data) == 1 and
            bosh.modInfos[self.data[0]].header.author in (u'BASHED PATCH',
                                                          u'BASHED LISTS'))
        menuItem.Enable(enable)

    def Execute(self,event):
        """Handle execution."""
        #--Patcher info
        groupOrder = dict([(group,index) for index,group in
            enumerate((_(u'General'),_(u'Importers'),
                       _(u'Tweakers'),_(u'Special')))])
        #--Config
        config = bosh.modInfos.table.getItem(self.data[0],'bash.patch.configs',{})
        # Detect CBash/Python mode patch
        doCBash = bosh.CBash_PatchFile.configIsCBash(config)
        if doCBash:
            patchers = [copy.deepcopy(x) for x in PatchDialog.CBash_patchers]
        else:
            patchers = [copy.deepcopy(x) for x in PatchDialog.patchers]
        patchers.sort(key=lambda a: a.__class__.name)
        patchers.sort(key=lambda a: groupOrder[a.__class__.group])
        patcherNames = [x.__class__.__name__ for x in patchers]
        #--Log & Clipboard text
        log = bolt.LogFile(StringIO.StringIO())
        log.setHeader(u'= %s %s' % (self.data[0],_(u'Config')))
        log(_(u'This is the current configuration of this Bashed Patch.  This report has also been copied into your clipboard.')+u'\n')
        clip = StringIO.StringIO()
        clip.write(u'%s %s:\n' % (self.data[0],_(u'Config')))
        clip.write(u'[spoiler][xml]\n')
        # CBash/Python patch?
        log.setHeader(u'== '+_(u'Patch Mode'))
        clip.write(u'== '+_(u'Patch Mode')+u'\n')
        if doCBash:
            if settings['bash.CBashEnabled']:
                msg = u'CBash v%u.%u.%u' % (CBash.GetVersionMajor(),CBash.GetVersionMinor(),CBash.GetVersionRevision())
            else:
                # It's a CBash patch config, but CBash.dll is unavailable (either by -P command line, or it's not there)
                msg = u'CBash'
            log(msg)
            clip.write(u' ** %s\n' % msg)
        else:
            log(u'Python')
            clip.write(u' ** Python\n')
        for patcher in patchers:
            className = patcher.__class__.__name__
            humanName = patcher.__class__.name
            # Patcher in the config?
            if not className in config: continue
            # Patcher active?
            conf = config[className]
            if not conf.get('isEnabled',False): continue
            # Active
            log.setHeader(u'== '+humanName)
            clip.write(u'\n')
            clip.write(u'== '+humanName+u'\n')
            if isinstance(patcher, (bosh.CBash_MultiTweaker, bosh.MultiTweaker)):
                # Tweak patcher
                patcher.getConfig(config)
                for tweak in patcher.tweaks:
                    if tweak.key in conf:
                        enabled,value = conf.get(tweak.key,(False,u''))
                        label = tweak.getListLabel().replace(u'[[',u'[').replace(u']]',u']')
                        if enabled:
                            log(u'* __%s__' % label)
                            clip.write(u' ** %s\n' % label)
                        else:
                            log(u'. ~~%s~~' % label)
                            clip.write(u'    %s\n' % label)
            elif isinstance(patcher, (bosh.CBash_ListsMerger,bosh.ListsMerger)):
                # Leveled Lists
                patcher.configChoices = conf.get('configChoices',{})
                for item in conf.get('configItems',[]):
                    log(u'. __%s__' % patcher.getItemLabel(item))
                    clip.write(u'    %s\n' % patcher.getItemLabel(item))
            elif isinstance(patcher, (bosh.CBash_AliasesPatcher,bosh.AliasesPatcher)):
                # Alias mod names
                aliases = conf.get('aliases',{})
                for mod in aliases:
                    log(u'* __%s__ >> %s' % (mod.s, aliases[mod].s))
                    clip.write(u'  %s >> %s\n' % (mod.s, aliases[mod].s))
            else:
                items = conf.get('configItems',[])
                if len(items) == 0:
                    log(u' ')
                for item in conf.get('configItems',[]):
                    checks = conf.get('configChecks',{})
                    checked = checks.get(item,False)
                    if checked:
                        log(u'* __%s__' % item)
                        clip.write(u' ** %s\n' % item)
                    else:
                        log(u'. ~~%s~~' % item)
                        clip.write(u'    %s\n' % item)
        #-- Show log
        clip.write(u'[/xml][/spoiler]')
        if (wx.TheClipboard.Open()):
            wx.TheClipboard.SetData(wx.TextDataObject(clip.getvalue()))
            wx.TheClipboard.Close()
        clip.close()
        text = log.out.getvalue()
        log.out.close()
        balt.showWryeLog(self.window,text,_(u'Bashed Patch Configuration'),
                         icons=bashBlue)

#------------------------------------------------------------------------------
class Mod_ExportPatchConfig(Link):
    """Exports the Bashed Patch configuration to a Wrye Bash readable file."""
    def AppendToMenu(self,menu,window,data):
        """Append link to a menu."""
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Export Patch Config...'))
        menu.AppendItem(menuItem)
        enable = (len(self.data) == 1 and
            bosh.modInfos[self.data[0]].header.author in (u'BASHED PATCH',
                                                          u'BASHED LISTS'))
        menuItem.Enable(enable)

    def Execute(self,event):
        """Handle execution."""
        #--Config
        config = bosh.modInfos.table.getItem(self.data[0],'bash.patch.configs',{})
        patchName = self.data[0].s + u'_Configuration.dat'
        outDir = bosh.dirs['patches']
        outDir.makedirs()
        #--File dialog
        outPath = balt.askSave(self.window,_(u'Export Bashed Patch configuration to:'),outDir,patchName, u'*_Configuration.dat')
        if not outPath: return
        pklPath = outPath+u'.pkl'
        table = bolt.Table(bosh.PickleDict(outPath, pklPath))
        table.setItem(bolt.Path(u'Saved Bashed Patch Configuration (%s)' % ([u'Python',u'CBash'][bosh.CBash_PatchFile.configIsCBash(config)])),'bash.patch.configs',config)
        table.save()

#------------------------------------------------------------------------------
class Mod_Ratings(Mod_Labels):
    """Add mod rating links."""
    def __init__(self):
        """Initialize."""
        self.column     = 'rating'
        self.setKey     = 'bash.mods.ratings'
        self.editMenu   = _(u'Edit Ratings...')
        self.editWindow = _(u'Ratings')
        self.addPrompt  = _(u'Add rating:')
        self.idList     = ID_RATINGS
        Mod_Labels.__init__(self)

#------------------------------------------------------------------------------
class Mod_SetVersion(Link):
    """Sets version of file back to 0.8."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        self.fileInfo = window.data[data[0]]
        menuItem = wx.MenuItem(menu,self.id,_(u'Version 0.8'))
        menu.AppendItem(menuItem)
        #print self.fileInfo.header.version
        menuItem.Enable((len(data) == 1) and (int(10*self.fileInfo.header.version) != 8))

    def Execute(self,event):
        message = _(u"WARNING! For advanced modders only! This feature allows you to edit newer official mods in the TES Construction Set by resetting the internal file version number back to 0.8. While this will make the mod editable, it may also break the mod in some way.")
        if not balt.askContinue(self.window,message,'bash.setModVersion.continue',_(u'Set File Version')):
            return
        self.fileInfo.header.version = 0.8
        self.fileInfo.header.setChanged()
        self.fileInfo.writeHeader()
        #--Repopulate
        self.window.RefreshUI(detail=self.fileInfo.name)

#------------------------------------------------------------------------------
class Mod_Details(Link):
    """Show Mod Details"""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        self.fileInfo = window.data[data[0]]
        menuItem = wx.MenuItem(menu,self.id,_(u'Details...'))
        menu.AppendItem(menuItem)
        menuItem.Enable((len(data) == 1))

    def Execute(self,event):
        modName = GPath(self.data[0])
        modInfo = bosh.modInfos[modName]
        with balt.Progress(modName.s) as progress:
            modDetails = bosh.ModDetails()
            modDetails.readFromMod(modInfo,SubProgress(progress,0.1,0.7))
            buff = StringIO.StringIO()
            progress(0.7,_(u'Sorting records.'))
            for group in sorted(modDetails.group_records):
                buff.write(group+u'\n')
                if group in ('CELL','WRLD','DIAL'):
                    buff.write(u'  '+_(u'(Details not provided for this record type.)')+u'\n\n')
                    continue
                records = modDetails.group_records[group]
                records.sort(key = lambda a: a[1].lower())
                #if group != 'GMST': records.sort(key = lambda a: a[0] >> 24)
                for fid,eid in records:
                    buff.write(u'  %08X %s\n' % (fid,eid))
                buff.write(u'\n')
            balt.showLog(self.window,buff.getvalue(), modInfo.name.s,
                asDialog=False, fixedFont=True, icons=bashBlue)
            buff.close()

#------------------------------------------------------------------------------
class Mod_RemoveWorldOrphans(Link):
    """Remove orphaned cell records."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Remove World Orphans'))
        menu.AppendItem(menuItem)
        menuItem.Enable(len(self.data) != 1 or (not bosh.reOblivion.match(self.data[0].s)))

    def Execute(self,event):
        message = _(u"In some circumstances, editing a mod will leave orphaned cell records in the world group. This command will remove such orphans.")
        if not balt.askContinue(self.window,message,'bash.removeWorldOrphans.continue',_(u'Remove World Orphans')):
            return
        for item in self.data:
            fileName = GPath(item)
            if bosh.reOblivion.match(fileName.s):
                balt.showWarning(self.window,_(u"Skipping %s") % fileName.s,_(u'Remove World Orphans'))
                continue
            fileInfo = bosh.modInfos[fileName]
            #--Export
            orphans = 0
            with balt.Progress(_(u"Remove World Orphans")) as progress:
                loadFactory = bosh.LoadFactory(True,bosh.MreRecord.type_class['CELL'],bosh.MreRecord.type_class['WRLD'])
                modFile = bosh.ModFile(fileInfo,loadFactory)
                progress(0,_(u"Reading %s.") % fileName.s)
                modFile.load(True,SubProgress(progress,0,0.7))
                orphans = ('WRLD' in modFile.tops) and modFile.WRLD.orphansSkipped
                if orphans:
                    progress(0.1,_(u"Saving %s.") % fileName.s)
                    modFile.safeSave()
                progress(1.0,_(u"Done."))
            #--Log
            if orphans:
                balt.showOk(self.window,_(u"Orphan cell blocks removed: %d.") % orphans,fileName.s)
            else:
                balt.showOk(self.window,_(u"No changes required."),fileName.s)

#------------------------------------------------------------------------------
class Mod_ShowReadme(Link):
    """Open the readme."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Readme...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(len(data) == 1)

    def Execute(self,event):
        fileName = GPath(self.data[0])
        fileInfo = self.window.data[fileName]
        if not docBrowser:
            DocBrowser().Show()
            settings['bash.modDocs.show'] = True
        #balt.ensureDisplayed(docBrowser)
        docBrowser.SetMod(fileInfo.name)
        docBrowser.Raise()

#------------------------------------------------------------------------------
class Mod_Scripts_Export(Link):
    """Export scripts from mod to text file."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Scripts...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(bool(self.data))

    def Execute(self,event):
        fileName = GPath(self.data[0])
        fileInfo = bosh.modInfos[fileName]
        defaultPath = bosh.dirs['patches'].join(fileName.s+u' Exported Scripts')
        def OnOk(event):
            dialog.EndModal(1)
            settings['bash.mods.export.deprefix'] = gdeprefix.GetValue().strip()
            settings['bash.mods.export.skip'] = gskip.GetValue().strip()
            settings['bash.mods.export.skipcomments'] = gskipcomments.GetValue()
        dialog = wx.Dialog(bashFrame,wx.ID_ANY,_(u'Export Scripts Options'),
                           size=(400,180),style=wx.DEFAULT_DIALOG_STYLE)
        gskip = textCtrl(dialog)
        gdeprefix = textCtrl(dialog)
        gskipcomments = toggleButton(dialog,_(u'Filter Out Comments'),
            tip=_(u"If active doesn't export comments in the scripts"))
        gskip.SetValue(settings['bash.mods.export.skip'])
        gdeprefix.SetValue(settings['bash.mods.export.deprefix'])
        gskipcomments.SetValue(settings['bash.mods.export.skipcomments'])
        sizer = vSizer(
            staticText(dialog,_(u"Skip prefix (leave blank to not skip any), non-case sensitive):"),style=wx.ST_NO_AUTORESIZE),
            gskip,
            spacer,
            staticText(dialog,(_(u'Remove prefix from file names i.e. enter cob to save script cobDenockInit')
                               + u'\n' +
                               _(u'as DenockInit.ext rather than as cobDenockInit.ext')
                               + u'\n' +
                               _(u'(Leave blank to not cut any prefix, non-case sensitive):')
                               ),style=wx.ST_NO_AUTORESIZE),
            gdeprefix,
            spacer,
            gskipcomments,
            (hSizer(
                spacer,
                button(dialog,id=wx.ID_OK,onClick=OnOk),
                (button(dialog,id=wx.ID_CANCEL),0,wx.LEFT,4),
                ),0,wx.EXPAND|wx.LEFT|wx.RIGHT|wx.BOTTOM,6),
            )
        dialog.SetSizer(sizer)
        questions = dialog.ShowModal()
        if questions != 1: return #because for some reason cancel/close dialogue is returning 5101!
        if not defaultPath.exists():
            defaultPath.makedirs()
        textDir = balt.askDirectory(self.window,
            _(u'Choose directory to export scripts to'),defaultPath)
        if textDir != defaultPath:
            for asDir,sDirs,sFiles in os.walk(defaultPath.s):
                if not (sDirs or sFiles):
                    defaultPath.removedirs()
        if not textDir: return
        #--Export
        #try:
        if CBash:
            ScriptText = bosh.CBash_ScriptText()
        else:
            ScriptText = bosh.ScriptText()
        ScriptText.readFromMod(fileInfo,fileName.s)
        exportedScripts = ScriptText.writeToText(fileInfo,settings['bash.mods.export.skip'],textDir,settings['bash.mods.export.deprefix'],fileName.s,settings['bash.mods.export.skipcomments'])
        #finally:
        balt.showLog(self.window,exportedScripts,_(u'Export Scripts'),
                     icons=bashBlue)

#------------------------------------------------------------------------------
class Mod_Scripts_Import(Link):
    """Import scripts from text file or other mod."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Scripts...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(len(self.data)==1)

    def Execute(self,event):
        message = (_(u"Import script from a text file.  This will replace existing scripts and is not reversible (except by restoring from backup)!"))
        if not balt.askContinue(self.window,message,'bash.scripts.import.continue',
            _(u'Import Scripts')):
            return
        fileName = GPath(self.data[0])
        fileInfo = bosh.modInfos[fileName]
        defaultPath = bosh.dirs['patches'].join(fileName.s+u' Exported Scripts')
        if not defaultPath.exists():
            defaultPath = bosh.dirs['patches']
        textDir = balt.askDirectory(self.window,
            _(u'Choose directory to import scripts from'),defaultPath)
        if textDir is None:
            return
        message = (_(u"Import scripts that don't exist in the esp as new scripts?")
                   + u'\n' +
                   _(u'(If not they will just be skipped).')
                   )
        makeNew = balt.askYes(self.window,message,_(u'Import Scripts'),icon=wx.ICON_QUESTION)
        if CBash:
            ScriptText = bosh.CBash_ScriptText()
        else:
            ScriptText = bosh.ScriptText()
        ScriptText.readFromText(textDir.s,fileInfo)
        changed, added = ScriptText.writeToMod(fileInfo,makeNew)
    #--Log
        if not (len(changed) or len(added)):
            balt.showOk(self.window,_(u"No changed or new scripts to import."),
                        _(u"Import Scripts"))
        else:
            if changed:
                changedScripts = (_(u'Imported %d changed scripts from %s:')
                                  + u'\n%s') % (len(changed),textDir.s,u'*'+u'\n*'.join(sorted(changed)))
            else:
                changedScripts = u''
            if added:
                addedScripts = (_(u'Imported %d new scripts from %s:')
                                + u'\n%s') % (len(added),textDir.s,u'*'+u'\n*'.join(sorted(added)))
            else:
                addedScripts = u''
            if changed and added:
                report = changedScripts + u'\n\n' + addedScripts
            elif changed:
                report = changedScripts
            elif added:
                report = addedScripts
            balt.showLog(self.window,report,_(u'Import Scripts'),icons=bashBlue)

#------------------------------------------------------------------------------
class Mod_Stats_Export(Link):
    """Export armor and weapon stats from mod to text file."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Stats...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(bool(self.data))

    def Execute(self,event):
        fileName = GPath(self.data[0])
        fileInfo = bosh.modInfos[fileName]
        textName = fileName.root+u'_Stats.csv'
        textDir = bosh.dirs['patches']
        textDir.makedirs()
        #--File dialog
        textPath = balt.askSave(self.window,_(u'Export stats to:'),
            textDir, textName, u'*_Stats.csv')
        if not textPath: return
        (textDir,textName) = textPath.headTail
        #--Export
        with balt.Progress(_(u"Export Stats")) as progress:
            if CBash:
                itemStats = bosh.CBash_ItemStats()
            else:
                itemStats = bosh.ItemStats()
            readProgress = SubProgress(progress,0.1,0.8)
            readProgress.setFull(len(self.data))
            for index,fileName in enumerate(map(GPath,self.data)):
                fileInfo = bosh.modInfos[fileName]
                readProgress(index,_(u"Reading %s.") % fileName.s)
                itemStats.readFromMod(fileInfo)
            progress(0.8,_(u"Exporting to %s.") % textName.s)
            itemStats.writeToText(textPath)
            progress(1.0,_(u"Done."))

#------------------------------------------------------------------------------
class Mod_Stats_Import(Link):
    """Import stats from text file or other mod."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Stats...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(len(self.data)==1)

    def Execute(self,event):
        message = (_(u"Import item stats from a text file. This will replace existing stats and is not reversible!"))
        if not balt.askContinue(self.window,message,'bash.stats.import.continue',
            _(u'Import Stats')):
            return
        fileName = GPath(self.data[0])
        fileInfo = bosh.modInfos[fileName]
        textName = fileName.root+u'_Stats.csv'
        textDir = bosh.dirs['patches']
        #--File dialog
        textPath = balt.askOpen(self.window,_(u'Import stats from:'),
            textDir, textName, u'*_Stats.csv',mustExist=True)
        if not textPath: return
        (textDir,textName) = textPath.headTail
        #--Extension error check
        ext = textName.cext
        if ext != u'.csv':
            balt.showError(self.window,_(u'Source file must be a Stats.csv file.'))
            return
        #--Export
        changed = None
        with balt.Progress(_(u"Import Stats")) as progress:
            if CBash:
                itemStats = bosh.CBash_ItemStats()
            else:
                itemStats = bosh.ItemStats()
            progress(0.1,_(u"Reading %s.") % textName.s)
            itemStats.readFromText(textPath)
            progress(0.2,_(u"Applying to %s.") % fileName.s)
            changed = itemStats.writeToMod(fileInfo)
            progress(1.0,_(u"Done."))
        #--Log
        if not changed:
            balt.showOk(self.window,_(u"No relevant stats to import."),_(u"Import Stats"))
        else:
            if not len(changed):
                balt.showOk(self.window,_(u"No changed stats to import."),_(u"Import Stats"))
            else:
                buff = StringIO.StringIO()
                for modName in sorted(changed):
                    buff.write(u'* %03d  %s\n' % (changed[modName], modName.s))
                balt.showLog(self.window,buff.getvalue(),_(u'Import Stats'),icons=bashBlue)
                buff.close()

#------------------------------------------------------------------------------
class Mod_ItemData_Export(Link):
    """Export pretty much complete item data from mod to text file."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Item Data...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(bool(self.data))

    def Execute(self,event):
        fileName = GPath(self.data[0])
        fileInfo = bosh.modInfos[fileName]
        textName = fileName.root+u'_ItemData.csv'
        textDir = bosh.dirs['patches']
        textDir.makedirs()
        #--File dialog
        textPath = balt.askSave(self.window,_(u'Export item data to:'),
            textDir, textName, u'*_ItemData.csv')
        if not textPath: return
        (textDir,textName) = textPath.headTail
        #--Export
        with balt.Progress(_(u"Export Item Data")) as progress:
            if CBash:
                itemStats = bosh.CBash_CompleteItemData()
            else:
                itemStats = bosh.CompleteItemData()
            readProgress = SubProgress(progress,0.1,0.8)
            readProgress.setFull(len(self.data))
            for index,fileName in enumerate(map(GPath,self.data)):
                fileInfo = bosh.modInfos[fileName]
                readProgress(index,_(u"Reading %s.") % fileName.s)
                itemStats.readFromMod(fileInfo)
            progress(0.8,_(u"Exporting to %s.") % textName.s)
            itemStats.writeToText(textPath)
            progress(1.0,_(u"Done."))

#------------------------------------------------------------------------------
class Mod_ItemData_Import(Link):
    """Import stats from text file or other mod."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Item Data...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(len(self.data)==1)

    def Execute(self,event):
        message = (_(u"Import pretty much complete item data from a text file.  This will replace existing data and is not reversible!"))
        if not balt.askContinue(self.window,message,'bash.itemdata.import.continue',
            _(u'Import Item Data')):
            return
        fileName = GPath(self.data[0])
        fileInfo = bosh.modInfos[fileName]
        textName = fileName.root+u'_ItemData.csv'
        textDir = bosh.dirs['patches']
        #--File dialog
        textPath = balt.askOpen(self.window,_(u'Import item data from:'),
            textDir, textName, u'*_ItemData.csv',mustExist=True)
        if not textPath: return
        (textDir,textName) = textPath.headTail
        #--Extension error check
        ext = textName.cext
        if ext != '.csv':
            balt.showError(self.window,_(u'Source file must be a ItemData.csv file.'))
            return
        #--Export
        changed = None
        with balt.Progress(_(u'Import Item Data')) as progress:
            itemStats = bosh.CompleteItemData()
            progress(0.1,_(u'Reading')+u' '+textName.s+u'.')
            if ext == u'.csv':
                itemStats.readFromText(textPath)
            else:
                srcInfo = bosh.ModInfo(textDir,textName)
                itemStats.readFromMod(srcInfo)
            progress(0.2,_(u'Applying to')+u' '+fileName.s+u'.')
            changed = itemStats.writeToMod(fileInfo)
            progress(1.0,_(u'Done.'))
        #--Log
        if not changed:
            balt.showOk(self.window,_(u'No relevant data to import.'),
                        _(u'Import Item Data'))
        else:
            buff = StringIO.StringIO()
            for modName in sorted(changed):
                buff.write(_(u'Imported Item Data:')
                           + u'\n* %03d  %s:\n' % (changed[modName], modName.s))
            balt.showLog(self.window,buff.getvalue(),_(u'Import Item Data'),icons=bashBlue)
            buff.close()

#------------------------------------------------------------------------------
class Mod_Prices_Export(Link):
    """Export item prices from mod to text file."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Prices...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(bool(self.data))

    def Execute(self,event):
        fileName = GPath(self.data[0])
        fileInfo = bosh.modInfos[fileName]
        textName = fileName.root+u'_Prices.csv'
        textDir = bosh.dirs['patches']
        textDir.makedirs()
        #--File dialog
        textPath = balt.askSave(self.window,_(u'Export prices to:'),
            textDir, textName, u'*_Prices.csv')
        if not textPath: return
        (textDir,textName) = textPath.headTail
        #--Export
        with balt.Progress(_(u'Export Prices')) as progress:
            if CBash:
                itemPrices = bosh.CBash_ItemPrices()
            else:
                itemPrices = bosh.ItemPrices()
            readProgress = SubProgress(progress,0.1,0.8)
            readProgress.setFull(len(self.data))
            for index,fileName in enumerate(map(GPath,self.data)):
                fileInfo = bosh.modInfos[fileName]
                readProgress(index,_(u'Reading')+u' '+fileName.s+u'.')
                itemPrices.readFromMod(fileInfo)
            progress(0.8,_(u'Exporting to')+u' '+textName.s+'.')
            itemPrices.writeToText(textPath)
            progress(1.0,_(u'Done.'))

#------------------------------------------------------------------------------
class Mod_Prices_Import(Link):
    """Import prices from text file."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Prices...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(len(self.data)==1)

    def Execute(self,event):
        message = (_(u"Import item prices from a text file.  This will replace existing prices and is not reversible!"))
        if not balt.askContinue(self.window,message,
            'bash.prices.import.continue',_(u'Import prices')):
            return
        fileName = GPath(self.data[0])
        fileInfo = bosh.modInfos[fileName]
        textName = fileName.root+u'_Prices.csv'
        textDir = bosh.dirs['patches']
        #--File dialog
        textPath = balt.askOpen(self.window,_(u'Import prices from:'),
            textDir, textName, u'*_Prices.csv',mustExist=True)
        if not textPath: return
        (textDir,textName) = textPath.headTail
        #--Extension error check
        ext = textName.cext
        if ext not in [u'.csv',u'.ghost',u'.esm',u'.esp']:
            balt.showError(self.window,_(u'Source file must be a Prices.csv file or esp/m.'))
            return
        #--Export
        changed = None
        with balt.Progress(_(u'Import Prices')) as progress:
            if CBash:
                itemPrices = bosh.CBash_ItemPrices()
            else:
                itemPrices = bosh.ItemPrices()
            progress(0.1,_(u'Reading')+u' '+textName.s+u'.')
            if ext == u'.csv':
                itemPrices.readFromText(textPath)
            else:
                srcInfo = bosh.ModInfo(textDir,textName)
                itemPrices.readFromMod(srcInfo)
            progress(0.2,_(u'Applying to')+u' '+fileName.s+u'.')
            changed = itemPrices.writeToMod(fileInfo)
            progress(1.0,_(u'Done.'))
        #--Log
        if not changed:
            balt.showOk(self.window,_(u'No relevant prices to import.'),
                        _(u'Import Prices'))
        else:
            buff = StringIO.StringIO()
            for modName in sorted(changed):
                buff.write(_(u'Imported Prices:')
                           + u'\n* %s: %d\n' % (modName.s,changed[modName]))
            balt.showLog(self.window,buff.getvalue(),_(u'Import Prices'),
                         icons=bashBlue)
            buff.close()

#------------------------------------------------------------------------------
class CBash_Mod_MapMarkers_Export(Link):
    """Export map marker stats from mod to text file."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Map Markers...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(bool(self.data) and bool(CBash))

    def Execute(self,event):
        fileName = GPath(self.data[0])
        fileInfo = bosh.modInfos[fileName]
        textName = fileName.root+u'_MapMarkers.csv'
        textDir = bosh.dirs['patches']
        textDir.makedirs()
        #--File dialog
        textPath = balt.askSave(self.window,_(u'Export Map Markers to:'),
            textDir, textName, u'*_MapMarkers.csv')
        if not textPath: return
        (textDir,textName) = textPath.headTail
        #--Export
        with balt.Progress(_(u'Export Map Markers')) as progress:
            mapMarkers = bosh.CBash_MapMarkers()
            readProgress = SubProgress(progress,0.1,0.8)
            readProgress.setFull(len(self.data))
            for index,fileName in enumerate(map(GPath,self.data)):
                fileInfo = bosh.modInfos[fileName]
                readProgress(index,_(u'Reading')+u' '+fileName.s+u'.')
                mapMarkers.readFromMod(fileInfo)
            progress(0.8,_(u'Exporting to')+u' '+textName.s+u'.')
            mapMarkers.writeToText(textPath)
            progress(1.0,_(u'Done.'))

#------------------------------------------------------------------------------
class CBash_Mod_MapMarkers_Import(Link):
    """Import MapMarkers from text file."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Map Markers...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(len(self.data) == 1 and bool(CBash))

    def Execute(self,event):
        message = (_(u"Import Map Markers data from a text file.  This will replace existing the data on map markers with the same editor ids and is not reversible!"))
        if not balt.askContinue(self.window,message,
            'bash.MapMarkers.import.continue',_(u'Import Map Markers')):
            return
        fileName = GPath(self.data[0])
        fileInfo = bosh.modInfos[fileName]
        textName = fileName.root+u'_MapMarkers.csv'
        textDir = bosh.dirs['patches']
        #--File dialog
        textPath = balt.askOpen(self.window,_(u'Import Map Markers from:'),
            textDir, textName, u'*_MapMarkers.csv',mustExist=True)
        if not textPath: return
        (textDir,textName) = textPath.headTail
        #--Extension error check
        ext = textName.cext
        if ext != u'.csv':
            balt.showError(self.window,_(u'Source file must be a MapMarkers.csv file'))
            return
        #--Export
        changed = None
        with balt.Progress(_(u'Import Map Markers')) as progress:
            MapMarkers = bosh.CBash_MapMarkers()
            progress(0.1,_(u'Reading')+u' '+textName.s)
            MapMarkers.readFromText(textPath)
            progress(0.2,_(u'Applying to')+u' '+fileName.s)
            changed = MapMarkers.writeToMod(fileInfo)
            progress(1.0,_(u'Done.'))
        #--Log
        if not changed:
            balt.showOk(self.window,_(u'No relevant Map Markers to import.'),
                        _(u'Import Map Markers'))
        else:
            buff = StringIO.StringIO()
            buff.write((_(u'Imported Map Markers to mod %s:')
                        + u'\n') % (fileName.s,))
            for eid in sorted(changed):
                buff.write(u'* %s\n' % (eid))
            balt.showLog(self.window,buff.getvalue(),_(u'Import Map Markers'),
                         icons=bashBlue)
            buff.close()

#------------------------------------------------------------------------------
class CBash_Mod_CellBlockInfo(Link):
    """Export Cell Block Info to text file.
    (in the form of Cell, block, subblock"""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Cell Block Info...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(bool(self.data) and bool(CBash))

    def Execute(self,event):
        fileName = GPath(self.data[0])
        fileInfo = bosh.modInfos[fileName]
        textName = fileName.root+u'_CellBlockInfo.csv'
        textDir = bosh.dirs['patches']
        textDir.makedirs()
        #--File dialog
        textPath = balt.askSave(self.window,_(u'Export Cell Block Info to:'),
            textDir, textName, u'*_CellBlockInfo.csv')
        if not textPath: return
        (textDir,textName) = textPath.headTail
        #--Export
        with balt.Progress(_(u"Export Cell Block Info")) as progress:
            cellblocks = bosh.CBash_CellBlockInfo()
            readProgress = SubProgress(progress,0.1,0.8)
            readProgress.setFull(len(self.data))
            for index,fileName in enumerate(map(GPath,self.data)):
                fileInfo = bosh.modInfos[fileName]
                readProgress(index,_(u"Reading %s.") % fileName.s)
                cellblocks.readFromMod(fileInfo)
            progress(0.8,_(u"Exporting to %s.") % textName.s)
            cellblocks.writeToText(textPath)
            progress(1.0,_(u"Done."))

#------------------------------------------------------------------------------
class Mod_SigilStoneDetails_Export(Link):
    """Export Sigil Stone details from mod to text file."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Sigil Stones...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(bool(self.data))

    def Execute(self,event):
        fileName = GPath(self.data[0])
        fileInfo = bosh.modInfos[fileName]
        textName = fileName.root+u'_SigilStones.csv'
        textDir = bosh.dirs['patches']
        textDir.makedirs()
        #--File dialog
        textPath = balt.askSave(self.window,
            _(u'Export Sigil Stone details to:'),
            textDir,textName, u'*_SigilStones.csv')
        if not textPath: return
        (textDir,textName) = textPath.headTail
        #--Export
        with balt.Progress(_(u'Export Sigil Stone details')) as progress:
            if CBash:
                sigilStones = bosh.CBash_SigilStoneDetails()
            else:
                sigilStones = bosh.SigilStoneDetails()
            readProgress = SubProgress(progress,0.1,0.8)
            readProgress.setFull(len(self.data))
            for index,fileName in enumerate(map(GPath,self.data)):
                fileInfo = bosh.modInfos[fileName]
                readProgress(index,_(u'Reading')+u' '+fileName.s+u'.')
                sigilStones.readFromMod(fileInfo)
            progress(0.8,_(u'Exporting to')+u' '+textName.s+u'.')
            sigilStones.writeToText(textPath)
            progress(1.0,_(u'Done.'))

#------------------------------------------------------------------------------
class Mod_SigilStoneDetails_Import(Link):
    """Import Sigil Stone details from text file."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Sigil Stones...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(len(self.data) == 1)

    def Execute(self,event):
        message = (_(u"Import Sigil Stone details from a text file.  This will replace existing the data on sigil stones with the same form ids and is not reversible!"))
        if not balt.askContinue(self.window,message,
            'bash.SigilStone.import.continue',
            _(u'Import Sigil Stones details')):
            return
        fileName = GPath(self.data[0])
        fileInfo = bosh.modInfos[fileName]
        textName = fileName.root+u'_SigilStones.csv'
        textDir = bosh.dirs['patches']
        #--File dialog
        textPath = balt.askOpen(self.window,
            _(u'Import Sigil Stone details from:'),
            textDir, textName, u'*_SigilStones.csv',mustExist=True)
        if not textPath: return
        (textDir,textName) = textPath.headTail
        #--Extension error check
        ext = textName.cext
        if ext != u'.csv':
            balt.showError(self.window,_(u'Source file must be a _SigilStones.csv file'))
            return
        #--Export
        changed = None
        with balt.Progress(_(u'Import Sigil Stone details')) as progress:
            if CBash:
                sigilStones = bosh.CBash_SigilStoneDetails()
            else:
                sigilStones = bosh.SigilStoneDetails()
            progress(0.1,_(u'Reading')+u' '+textName.s+u'.')
            sigilStones.readFromText(textPath)
            progress(0.2,_(u'Applying to')+u' '+fileName.s+u'.')
            changed = sigilStones.writeToMod(fileInfo)
            progress(1.0,_(u'Done.'))
        #--Log
        if not changed:
            balt.showOk(self.window,
                _(u'No relevant Sigil Stone details to import.'),
                _(u'Import Sigil Stone details'))
        else:
            buff = StringIO.StringIO()
            buff.write((_(u'Imported Sigil Stone details to mod %s:')
                        +u'\n') % fileName.s)
            for eid in sorted(changed):
                buff.write(u'* %s\n' % (eid))
            balt.showLog(self.window,buff.getvalue(),
                         _(u'Import Sigil Stone details'),icons=bashBlue)
            buff.close()

#------------------------------------------------------------------------------
class Mod_SpellRecords_Export(Link):
    """Export Spell details from mod to text file."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Spells...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(bool(self.data))

    def Execute(self,event):
        fileName = GPath(self.data[0])
        fileInfo = bosh.modInfos[fileName]
        textName = fileName.root+u'_Spells.csv'
        textDir = bosh.dirs['patches']
        textDir.makedirs()
        #--File dialog
        textPath = balt.askSave(self.window,_(u'Export Spell details to:'),textDir,textName, u'*_Spells.csv')
        if not textPath: return
        message = (_(u'Export flags and effects?')
                   + u'\n' +
                   _(u'(If not they will just be skipped).')
                   )
        doDetailed = balt.askYes(self.window,message,_(u'Export Spells'),icon=wx.ICON_QUESTION)
        (textDir,textName) = textPath.headTail
        #--Export
        with balt.Progress(_(u'Export Spell details')) as progress:
            if CBash:
                spellRecords = bosh.CBash_SpellRecords(detailed=doDetailed)
            else:
                spellRecords = bosh.SpellRecords(detailed=doDetailed)
            readProgress = SubProgress(progress,0.1,0.8)
            readProgress.setFull(len(self.data))
            for index,fileName in enumerate(map(GPath,self.data)):
                fileInfo = bosh.modInfos[fileName]
                readProgress(index,_(u'Reading')+u' '+fileName.s+u'.')
                spellRecords.readFromMod(fileInfo)
            progress(0.8,_(u'Exporting to')+u' '+textName.s+u'.')
            spellRecords.writeToText(textPath)
            progress(1.0,_(u'Done.'))

#------------------------------------------------------------------------------
class Mod_SpellRecords_Import(Link):
    """Import Spell details from text file."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Spells...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(len(self.data) == 1)

    def Execute(self,event):
        message = (_(u"Import Spell details from a text file.  This will replace existing the data on spells with the same form ids and is not reversible!"))
        if not balt.askContinue(self.window,message,
            'bash.SpellRecords.import.continue',
            _(u'Import Spell details')):
            return
        fileName = GPath(self.data[0])
        fileInfo = bosh.modInfos[fileName]
        textName = fileName.root+u'_Spells.csv'
        textDir = bosh.dirs['patches']
        #--File dialog
        textPath = balt.askOpen(self.window,_(u'Import Spell details from:'),
            textDir, textName, u'*_Spells.csv',mustExist=True)
        if not textPath: return
        message = (_(u'Import flags and effects?')
                   + u'\n' +
                   _(u'(If not they will just be skipped).')
                   )
        doDetailed = balt.askYes(self.window,message,_(u'Import Spell details'),
                                 icon=wx.ICON_QUESTION)
        (textDir,textName) = textPath.headTail
        #--Extension error check
        ext = textName.cext
        if ext != u'.csv':
            balt.showError(self.window,_(u'Source file must be a _Spells.csv file'))
            return
        #--Export
        changed = None
        with balt.Progress(_(u'Import Spell details')) as progress:
            if CBash:
                spellRecords = bosh.CBash_SpellRecords(detailed=doDetailed)
            else:
                spellRecords = bosh.SpellRecords(detailed=doDetailed)
            progress(0.1,_(u'Reading')+u' '+textName.s+u'.')
            spellRecords.readFromText(textPath)
            progress(0.2,_(u'Applying to')+u' '+fileName.s+u'.')
            changed = spellRecords.writeToMod(fileInfo)
            progress(1.0,_(u'Done.'))
        #--Log
        if not changed:
            balt.showOk(self.window,_(u'No relevant Spell details to import.'),
                        _(u'Import Spell details'))
        else:
            buff = StringIO.StringIO()
            buff.write((_(u'Imported Spell details to mod %s:')
                        +u'\n') % fileName.s)
            for eid in sorted(changed):
                buff.write(u'* %s\n' % (eid))
            balt.showLog(self.window,buff.getvalue(),_(u'Import Spell details'),
                         icons=bashBlue)
            buff.close()

#------------------------------------------------------------------------------
class Mod_IngredientDetails_Export(Link):
    """Export Ingredient details from mod to text file."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Ingredients...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(bool(self.data))

    def Execute(self,event):
        fileName = GPath(self.data[0])
        fileInfo = bosh.modInfos[fileName]
        textName = fileName.root+u'_Ingredients.csv'
        textDir = bosh.dirs['patches']
        textDir.makedirs()
        #--File dialog
        textPath = balt.askSave(self.window,_(u'Export Ingredient details to:'),
                                textDir,textName,u'*_Ingredients.csv')
        if not textPath: return
        (textDir,textName) = textPath.headTail
        #--Export
        with balt.Progress(_(u'Export Ingredient details')) as progress:
            if CBash:
                Ingredients = bosh.CBash_IngredientDetails()
            else:
                Ingredients = bosh.IngredientDetails()
            readProgress = SubProgress(progress,0.1,0.8)
            readProgress.setFull(len(self.data))
            for index,fileName in enumerate(map(GPath,self.data)):
                fileInfo = bosh.modInfos[fileName]
                readProgress(index,_(u'Reading')+u' '+fileName.s+u'.')
                Ingredients.readFromMod(fileInfo)
            progress(0.8,_(u'Exporting to')+u' '+textName.s+u'.')
            Ingredients.writeToText(textPath)
            progress(1.0,_(u'Done.'))

class Mod_IngredientDetails_Import(Link):
    """Import Ingredient details from text file."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Ingredients...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(len(self.data) == 1)

    def Execute(self,event):
        message = (_(u"Import Ingredient details from a text file.  This will replace existing the data on Ingredients with the same form ids and is not reversible!"))
        if not balt.askContinue(self.window,message,
            'bash.Ingredient.import.continue',
            _(u'Import Ingredients details')):
            return
        fileName = GPath(self.data[0])
        fileInfo = bosh.modInfos[fileName]
        textName = fileName.root+u'_Ingredients.csv'
        textDir = bosh.dirs['patches']
        #--File dialog
        textPath = balt.askOpen(self.window,_(u'Import Ingredient details from:'),
            textDir,textName,u'*_Ingredients.csv',mustExist=True)
        if not textPath: return
        (textDir,textName) = textPath.headTail
        #--Extension error check
        ext = textName.cext
        if ext != u'.csv':
            balt.showError(self.window,_(u'Source file must be a _Ingredients.csv file'))
            return
        #--Export
        changed = None
        with balt.Progress(_(u'Import Ingredient details')) as progress:
            if CBash:
                Ingredients = bosh.CBash_IngredientDetails()
            else:
                Ingredients = bosh.IngredientDetails()
            progress(0.1,_(u'Reading %s.') % textName.s)
            Ingredients.readFromText(textPath)
            progress(0.2,_(u'Applying to %s.') % fileName.s)
            changed = Ingredients.writeToMod(fileInfo)
            progress(1.0,_(u'Done.'))
        #--Log
        if not changed:
            balt.showOk(self.window,
                _(u'No relevant Ingredient details to import.'),
                _(u'Import Ingredient details'))
        else:
            buff = StringIO.StringIO()
            buff.write((_(u'Imported Ingredient details to mod %s:')
                        + u'\n') % fileName.s)
            for eid in sorted(changed):
                buff.write(u'* %s\n' % (eid))
            balt.showLog(self.window,buff.getvalue(),
                _(u'Import Ingredient details'),icons=bashBlue)
            buff.close()

#------------------------------------------------------------------------------
class Mod_UndeleteRefs(Link):
    """Undeletes refs in cells."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Undelete Refs'))
        menu.AppendItem(menuItem)
        menuItem.Enable(len(self.data) != 1 or (not bosh.reOblivion.match(self.data[0].s)))

    def Execute(self,event):
        message = _(u"Changes deleted refs to ignored.  This is a very advanced feature and should only be used by modders who know exactly what they're doing.")
        if not balt.askContinue(self.window,message,'bash.undeleteRefs.continue',
            _(u'Undelete Refs')):
            return
        with balt.Progress(_(u'Undelete Refs')) as progress:
            progress.setFull(len(self.data))
            hasFixed = False
            log = bolt.LogFile(StringIO.StringIO())
            for index,fileName in enumerate(map(GPath,self.data)):
                if bosh.reOblivion.match(fileName.s):
                    balt.showWarning(self.window,_(u'Skipping')+u' '+fileName.s,
                                     _(u'Undelete Refs'))
                    continue
                progress(index,_(u'Scanning')+u' '+fileName.s+u'.')
                fileInfo = bosh.modInfos[fileName]
                cleaner = bosh.ModCleaner(fileInfo)
                cleaner.clean(bosh.ModCleaner.UDR,SubProgress(progress,index,index+1))
                if cleaner.udr:
                    hasFixed = True
                    log.setHeader(u'== '+fileName.s)
                    for fid in sorted(cleaner.udr):
                        log(u'. %08X' % fid)
        if hasFixed:
            message = log.out.getvalue()
        else:
            message = _(u"No changes required.")
        balt.showWryeLog(self.window,message,_(u'Undelete Refs'),icons=bashBlue)
        log.out.close()

#------------------------------------------------------------------------------
class Mod_ScanDirty(Link):
    """Give detailed printout of what Wrye Bash is detecting as UDR and ITM records"""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        if settings['bash.CBashEnabled']:
            menuItem = wx.MenuItem(menu,self.id,_(u'Scan for Dirty Edits'))
        else:
            menuItem = wx.MenuItem(menu,self.id,_(u"Scan for UDR's"))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        """Handle execution"""
        modInfos = [bosh.modInfos[x] for x in self.data]
        try:
            with balt.Progress(_(u'Dirty Edits'),u'\n'+u' '*60,abort=True) as progress:
                ret = bosh.ModCleaner.scan_Many(modInfos,progress=progress,detailed=True)
        except bolt.CancelError:
            return
        log = bolt.LogFile(StringIO.StringIO())
        log.setHeader(u'= '+_(u'Scan Mods'))
        log(_(u'This is a report of records that were detected as either Identical To Master (ITM) or a deleted reference (UDR).')
            + u'\n')
        # Change a FID to something more usefull for displaying
        if settings['bash.CBashEnabled']:
            def strFid(fid):
                return u'%s: %06X' % (fid[0],fid[1])
        else:
            def strFid(fid):
                modId = (0xFF000000 & fid) >> 24
                modName = modInfo.masterNames[modId]
                id = 0x00FFFFFF & fid
                return u'%s: %06X' % (modName,id)
        dirty = []
        clean = []
        error = []
        for i,modInfo in enumerate(modInfos):
            udrs,itms,fog = ret[i]
            if modInfo.name == GPath(u'Unofficial Oblivion Patch.esp'):
                # Record for non-SI users, shows up as ITM if SI is installed (OK)
                if settings['bash.CBashEnabled']:
                    itms.discard(FormID(GPath(u'Oblivion.esm'),0x00AA3C))
                else:
                    itms.discard((GPath(u'Oblivion.esm'),0x00AA3C))
            if modInfo.header.author in (u'BASHED PATCH',u'BASHED LISTS'): itms = set()
            if udrs or itms:
                pos = len(dirty)
                dirty.append(u'* __'+modInfo.name.s+u'__:\n')
                dirty[pos] += u'  * %s: %i\n' % (_(u'UDR'),len(udrs))
                for udr in sorted(udrs):
                    if udr.parentEid:
                        parentStr = u"%s '%s'" % (strFid(udr.parentFid),udr.parentEid)
                    else:
                        parentStr = strFid(udr.parentFid)
                    if udr.parentType == 0:
                        # Interior CELL
                        item = u'%s -  %s attached to Interior CELL (%s)' % (
                            strFid(udr.fid),udr.type,parentStr)
                    else:
                        # Exterior CELL
                        if udr.parentParentEid:
                            parentParentStr = u"%s '%s'" % (strFid(udr.parentParentFid),udr.parentParentEid)
                        else:
                            parentParentStr = strFid(udr.parentParentFid)
                        if udr.pos is None:
                            atPos = u''
                        else:
                            atPos = u' at %s' % (udr.pos,)
                        item = u'%s - %s attached to Exterior CELL (%s), attached to WRLD (%s)%s' % (
                            strFid(udr.fid),udr.type,parentStr,parentParentStr,atPos)
                    dirty[pos] += u'    * %s\n' % item
                if not settings['bash.CBashEnabled']: continue
                if itms:
                    dirty[pos] += u'  * %s: %i\n' % (_(u'ITM'),len(itms))
                for fid in sorted(itms):
                    dirty[pos] += u'    * %s\n' % strFid(fid)
            elif udrs is None or itms is None:
                error.append(u'* __'+modInfo.name.s+u'__')
            else:
                clean.append(u'* __'+modInfo.name.s+u'__')
        #-- Show log
        if dirty:
            log(_(u'Detected %d dirty mods:') % len(dirty))
            for mod in dirty: log(mod)
            log(u'\n')
        if clean:
            log(_(u'Detected %d clean mods:') % len(clean))
            for mod in clean: log(mod)
            log(u'\n')
        if error:
            log(_(u'The following %d mods had errors while scanning:') % len(error))
            for mod in error: log(mod)
        balt.showWryeLog(self.window,log.out.getvalue(),
            _(u'Dirty Edit Scan Results'),asDialog=False,icons=bashBlue)
        log.out.close()

# Saves Links -----------------------------------------------------------------
#------------------------------------------------------------------------------
class Saves_ProfilesData(balt.ListEditorData):
    """Data capsule for save profiles editing dialog."""
    def __init__(self,parent):
        """Initialize."""
        self.baseSaves = bosh.dirs['saveBase'].join(u'Saves')
        #--GUI
        balt.ListEditorData.__init__(self,parent)
        self.showAdd    = True
        self.showRename = True
        self.showRemove = True
        self.showInfo   = True
        self.infoWeight = 2
        self.infoReadOnly = False

    def getItemList(self):
        """Returns load list keys in alpha order."""
        #--Get list of directories in Hidden, but do not include default.
        items = [x.s for x in bosh.saveInfos.getLocalSaveDirs()]
        items.sort(key=lambda a: a.lower())
        return items

    #--Info box
    def getInfo(self,item):
        """Returns string info on specified item."""
        profileSaves = u'Saves\\'+item+u'\\'
        return bosh.saveInfos.profiles.getItem(profileSaves,'info',_(u'About %s:') % item)
    def setInfo(self,item,text):
        """Sets string info on specified item."""
        profileSaves = u'Saves\\'+item+u'\\'
        bosh.saveInfos.profiles.setItem(profileSaves,'info',text)

    def add(self):
        """Adds a new profile."""
        newName = balt.askText(self.parent,_(u"Enter profile name:"))
        if not newName:
            return False
        if newName in self.getItemList():
            balt.showError(self.parent,_(u'Name must be unique.'))
            return False
        if len(newName) == 0 or len(newName) > 64:
            balt.showError(self.parent,
                _(u'Name must be between 1 and 64 characters long.'))
            return False
        self.baseSaves.join(newName).makedirs()
        newSaves = u'Saves\\'+newName+u'\\'
        bosh.saveInfos.profiles.setItem(newSaves,'vOblivion',bosh.modInfos.voCurrent)
        return newName

    def rename(self,oldName,newName):
        """Renames profile oldName to newName."""
        newName = newName.strip()
        lowerNames = [name.lower() for name in self.getItemList()]
        #--Error checks
        if newName.lower() in lowerNames:
            balt.showError(self,_(u'Name must be unique.'))
            return False
        if len(newName) == 0 or len(newName) > 64:
            balt.showError(self.parent,
                _(u'Name must be between 1 and 64 characters long.'))
            return False
        #--Rename
        oldDir,newDir = (self.baseSaves.join(dir) for dir in (oldName,newName))
        oldDir.moveTo(newDir)
        oldSaves,newSaves = ((u'Saves\\'+name+u'\\') for name in (oldName,newName))
        if bosh.saveInfos.localSave == oldSaves:
            bosh.saveInfos.setLocalSave(newSaves)
            bashFrame.SetTitle()
        bosh.saveInfos.profiles.moveRow(oldSaves,newSaves)
        return newName

    def remove(self,profile):
        """Removes load list."""
        profileSaves = u'Saves\\'+profile+u'\\'
        #--Can't remove active or Default directory.
        if bosh.saveInfos.localSave == profileSaves:
            balt.showError(self.parent,_(u'Active profile cannot be removed.'))
            return False
        #--Get file count. If > zero, verify with user.
        profileDir = bosh.dirs['saveBase'].join(profileSaves)
        files = [file for file in profileDir.list() if bosh.reSaveExt.search(file.s)]
        if files:
            message = _(u'Delete profile %s and the %d save files it contains?') % (profile,len(files))
            if not balt.askYes(self.parent,message,_(u'Delete Profile')):
                return False
        #--Remove directory
        if GPath(bush.game.name).join(u'Saves').s not in profileDir.s:
            raise BoltError(u'Sanity check failed: No "%s\\Saves" in %s.' % (bush.game.name,profileDir.s))
        shutil.rmtree(profileDir.s) #--DO NOT SCREW THIS UP!!!
        bosh.saveInfos.profiles.delRow(profileSaves)
        return True

#------------------------------------------------------------------------------
class Saves_Profiles:
    """Select a save set profile -- i.e., the saves directory."""
    def __init__(self):
        """Initialize."""
        self.idList = ID_PROFILES

    def GetItems(self):
        return [x.s for x in bosh.saveInfos.getLocalSaveDirs()]

    def AppendToMenu(self,menu,window,data):
        """Append label list to menu."""
        self.window = window
        #--Edit
        menu.Append(self.idList.EDIT,_(u"Edit Profiles..."))
        menu.AppendSeparator()
        #--List
        localSave = bosh.saveInfos.localSave
        menuItem = wx.MenuItem(menu,self.idList.DEFAULT,_(u'Default'),kind=wx.ITEM_CHECK)
        menu.AppendItem(menuItem)
        menuItem.Check(localSave == u'Saves\\')
        for id,item in zip(self.idList,self.GetItems()):
            menuItem = wx.MenuItem(menu,id,item,kind=wx.ITEM_CHECK)
            menu.AppendItem(menuItem)
            menuItem.Check(localSave == (u'Saves\\'+item+u'\\'))
        #--Events
        wx.EVT_MENU(bashFrame,self.idList.EDIT,self.DoEdit)
        wx.EVT_MENU(bashFrame,self.idList.DEFAULT,self.DoDefault)
        wx.EVT_MENU_RANGE(bashFrame,self.idList.BASE,self.idList.MAX,self.DoList)

    def DoEdit(self,event):
        """Show profiles editing dialog."""
        data = Saves_ProfilesData(self.window)
        dialog = balt.ListEditor(self.window,wx.ID_ANY,_(u'Save Profiles'),data)
        dialog.ShowModal()
        dialog.Destroy()

    def DoDefault(self,event):
        """Handle selection of Default."""
        arcSaves,newSaves = bosh.saveInfos.localSave,u'Saves\\'
        bosh.saveInfos.setLocalSave(newSaves)
        self.swapPlugins(arcSaves,newSaves)
        self.swapOblivionVersion(newSaves)
        bashFrame.SetTitle()
        self.window.details.SetFile(None)
        modList.RefreshUI()
        bashFrame.RefreshData()

    def DoList(self,event):
        """Handle selection of label."""
        profile = self.GetItems()[event.GetId()-self.idList.BASE]
        arcSaves = bosh.saveInfos.localSave
        newSaves = u'Saves\\%s\\' % (profile,)
        bosh.saveInfos.setLocalSave(newSaves)
        self.swapPlugins(arcSaves,newSaves)
        self.swapOblivionVersion(newSaves)
        bashFrame.SetTitle()
        self.window.details.SetFile(None)
        bashFrame.RefreshData()
        bosh.modInfos.autoGhost()
        modList.RefreshUI()

    def swapPlugins(self,arcSaves,newSaves):
        """Saves current plugins into arcSaves directory and loads plugins
        from newSaves directory (if present)."""
        arcPath,newPath = (bosh.dirs['saveBase'].join(saves)
            for saves in (arcSaves,newSaves))
        #--Archive old Saves
        bosh.modInfos.plugins.copyTo(arcPath)
        bosh.modInfos.plugins.copyFrom(newPath)

    def swapOblivionVersion(self,newSaves):
        """Swaps Oblivion version to memorized version."""
        voNew = bosh.saveInfos.profiles.setItemDefault(newSaves,'vOblivion',bosh.modInfos.voCurrent)
        if voNew in bosh.modInfos.voAvailable:
            bosh.modInfos.setOblivionVersion(voNew)

#------------------------------------------------------------------------------
class Save_LoadMasters(Link):
    """Sets the load list to the save game's masters."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Load Masters'))
        menu.AppendItem(menuItem)
        if len(data) != 1: menuItem.Enable(False)

    def Execute(self,event):
        fileName = GPath(self.data[0])
        fileInfo = self.window.data[fileName]
        errorMessage = bosh.modInfos.selectExact(fileInfo.masterNames)
        modList.PopulateItems()
        saveList.PopulateItems()
        self.window.details.SetFile(fileName)
        if errorMessage:
            balt.showError(self.window,errorMessage,fileName.s)

#------------------------------------------------------------------------------
class Save_ImportFace(Link):
    """Imports a face from another save."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Import Face...'))
        menu.AppendItem(menuItem)
        if len(data) != 1: menuItem.Enable(False)

    def Execute(self,event):
        #--File Info
        fileName = GPath(self.data[0])
        fileInfo = self.window.data[fileName]
        #--Select source face file
        srcDir = fileInfo.dir
        wildcard = _(u'%s Files')%bush.game.name+u' (*.esp;*.esm;*.ess;*.esr)|*.esp;*.esm;*.ess;*.esr'
        #--File dialog
        srcPath = balt.askOpen(self.window,_(u'Face Source:'),srcDir, u'', wildcard,mustExist=True)
        if not srcPath: return
        if bosh.reSaveExt.search(srcPath.s):
            self.FromSave(fileInfo,srcPath)
        elif bosh.reModExt.search(srcPath.s):
            self.FromMod(fileInfo,srcPath)

    def FromSave(self,fileInfo,srcPath):
        """Import from a save."""
        #--Get face
        srcDir,srcName = GPath(srcPath).headTail
        srcInfo = bosh.SaveInfo(srcDir,srcName)
        with balt.Progress(srcName.s) as progress:
            saveFile = bosh.SaveFile(srcInfo)
            saveFile.load(progress)
            progress.Destroy()
            srcFaces = bosh.PCFaces.save_getFaces(saveFile)
            #--Dialog
            dialog = ImportFaceDialog(self.window,-1,srcName.s,fileInfo,srcFaces)
            dialog.ShowModal()
            dialog.Destroy()

    def FromMod(self,fileInfo,srcPath):
        """Import from a mod."""
        #--Get faces
        srcDir,srcName = GPath(srcPath).headTail
        srcInfo = bosh.ModInfo(srcDir,srcName)
        srcFaces = bosh.PCFaces.mod_getFaces(srcInfo)
        #--No faces to import?
        if not srcFaces:
            balt.showOk(self.window,_(u'No player (PC) faces found in %s.') % srcName.s,srcName.s)
            return
        #--Dialog
        dialog = ImportFaceDialog(self.window,-1,srcName.s,fileInfo,srcFaces)
        dialog.ShowModal()
        dialog.Destroy()

#------------------------------------------------------------------------------
class Save_RenamePlayer(Link):
    """Renames the Player character in a save game."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Rename Player...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(len(data) != 0)

    def Execute(self,event):
        saveInfo = bosh.saveInfos[self.data[0]]
        newName = balt.askText(self.window,_(u"Enter new player name. E.g. Conan the Bold"),
            _(u"Rename player"),saveInfo.header.pcName)
        if not newName: return
        for save in self.data:
            savedPlayer = bosh.Save_NPCEdits(self.window.data[GPath(save)])
            savedPlayer.renamePlayer(newName)
        bosh.saveInfos.refresh()
        self.window.RefreshUI()

class Save_ExportScreenshot(Link):
    """exports the saved screenshot from a save game."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Export Screenshot...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(len(data) == 1)

    def Execute(self,event):
        saveInfo = bosh.saveInfos[self.data[0]]
        imagePath = balt.askSave(bashFrame,_(u'Save Screenshot as:'), bosh.dirs['patches'].s,_(u'Screenshot %s.jpg') % self.data[0].s,u'*.jpg')
        if not imagePath: return
        width,height,data = saveInfo.header.image
        image = wx.EmptyImage(width,height)
        image.SetData(data)
        image.SaveFile(imagePath.s,wx.BITMAP_TYPE_JPEG)

#------------------------------------------------------------------------------
class Save_DiffMasters(Link):
    """Shows how saves masters differ from active mod list."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Diff Masters...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(len(data) in (1,2))

    def Execute(self,event):
        oldNew = map(GPath,self.data)
        oldNew.sort(key = lambda x: bosh.saveInfos.dir.join(x).mtime)
        oldName = oldNew[0]
        oldInfo = self.window.data[GPath(oldName)]
        oldMasters = set(oldInfo.masterNames)
        if len(self.data) == 1:
            newName = GPath(_(u'Active Masters'))
            newMasters = set(bosh.modInfos.ordered)
        else:
            newName = oldNew[1]
            newInfo = self.window.data[GPath(newName)]
            newMasters = set(newInfo.masterNames)
        missing = oldMasters - newMasters
        extra = newMasters - oldMasters
        if not missing and not extra:
            message = _(u'Masters are the same.')
            balt.showInfo(self.window,message,_(u'Diff Masters'))
        else:
            message = u''
            if missing:
                message += u'=== '+_(u'Removed Masters')+u' (%s):\n* ' % oldName.s
                message += u'\n* '.join(x.s for x in bosh.modInfos.getOrdered(missing))
                if extra: message += u'\n\n'
            if extra:
                message += u'=== '+_(u'Added Masters')+u' (%s):\n* ' % newName.s
                message += u'\n* '.join(x.s for x in bosh.modInfos.getOrdered(extra))
            balt.showWryeLog(self.window,message,_(u'Diff Masters'))

#--------------------------------------------------------------------------
class Save_Rename(Link):
    """Renames Save File."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Rename...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(len(data) != 0)

    def Execute(self,event):
        if len(self.data) > 0:
            index = self.window.list.FindItem(0,self.data[0].s)
            if index != -1:
                self.window.list.EditLabel(index)

#--------------------------------------------------------------------------
class Save_Renumber(Link):
    """Renamumbers a whole lot of save files."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Re-number Save(s)...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(len(data) != 0)

    def Execute(self,event):
        #--File Info
        newNumber = balt.askNumber(self.window,_(u"Enter new number to start numbering the selected saves at."),
            prompt=_(u'Save Number'),title=_(u'Re-number Saves'),value=1,min=1,max=10000)
        if not newNumber: return
        rePattern = re.compile(ur'^(save )(\d*)(.*)',re.I|re.U)
        for index, name in enumerate(self.data):
            maPattern = rePattern.match(name.s)
            if not maPattern: continue
            maPattern = maPattern.groups()
            if not maPattern[1]: continue
            newFileName = u"%s%d%s" % (maPattern[0],newNumber,maPattern[2])
            if newFileName != name.s:
                oldPath = bosh.saveInfos.dir.join(name.s)
                newPath = bosh.saveInfos.dir.join(newFileName)
                if not newPath.exists():
                    oldPath.moveTo(newPath)
                    if GPath(oldPath.s[:-3]+bush.game.se.shortName.lower()).exists():
                        GPath(oldPath.s[:-3]+bush.game.se.shortName.lower()).moveTo(GPath(newPath.s[:-3]+bush.game.se.shortName.lower()))
                    if GPath(oldPath.s[:-3]+u'pluggy').exists():
                        GPath(oldPath.s[:-3]+u'pluggy').moveTo(GPath(newPath.s[:-3]+u'pluggy'))
                newNumber += 1
        bosh.saveInfos.refresh()
        self.window.RefreshUI()

#--------------------------------------------------------------------------
class Save_EditCreatedData(balt.ListEditorData):
    """Data capsule for custom item editing dialog."""
    def __init__(self,parent,saveFile,recordTypes):
        """Initialize."""
        self.changed = False
        self.saveFile = saveFile
        data = self.data = {}
        self.enchantments = {}
        #--Parse records and get into data
        for index,record in enumerate(saveFile.created):
            if record.recType == 'ENCH':
                self.enchantments[record.fid] = record.getTypeCopy()
            elif record.recType in recordTypes:
                record = record.getTypeCopy()
                if not record.full: continue
                record.getSize() #--Since type copy makes it changed.
                saveFile.created[index] = record
                record_full = record.full
                if record_full not in data: data[record_full] = (record_full,[])
                data[record_full][1].append(record)
        #--GUI
        balt.ListEditorData.__init__(self,parent)
        self.showRename = True
        self.showInfo = True
        self.showSave = True
        self.showCancel = True

    def getItemList(self):
        """Returns load list keys in alpha order."""
        items = sorted(self.data.keys())
        items.sort(key=lambda x: self.data[x][1][0].recType)
        return items

    def getInfo(self,item):
        """Returns string info on specified item."""
        buff = StringIO.StringIO()
        name,records = self.data[item]
        record = records[0]
        #--Armor, clothing, weapons
        if record.recType == 'ARMO':
            buff.write(_(u'Armor')+u'\n'+_(u'Flags: '))
            buff.write(u', '.join(record.flags.getTrueAttrs())+u'\n')
            for attr in ('strength','value','weight'):
                buff.write(u'%s: %s\n' % (attr,getattr(record,attr)))
        elif record.recType == 'CLOT':
            buff.write(_(u'Clothing')+u'\n'+_(u'Flags: '))
            buff.write(u', '.join(record.flags.getTrueAttrs())+u'\n')
        elif record.recType == 'WEAP':
            buff.write(bush.game.weaponTypes[record.weaponType]+u'\n')
            for attr in ('damage','value','speed','reach','weight'):
                buff.write(u'%s: %s\n' % (attr,getattr(record,attr)))
        #--Enchanted? Switch record to enchantment.
        if hasattr(record,'enchantment') and record.enchantment in self.enchantments:
            buff.write(u'\n'+_(u'Enchantment:')+u'\n')
            record = self.enchantments[record.enchantment].getTypeCopy()
        #--Magic effects
        if record.recType in ('ALCH','SPEL','ENCH'):
            buff.write(record.getEffectsSummary())
        #--Done
        ret = buff.getvalue()
        buff.close()
        return ret

    def rename(self,oldName,newName):
        """Renames oldName to newName."""
        #--Right length?
        if len(newName) == 0:
            return False
        elif len(newName) > 128:
            balt.showError(self.parent,_(u'Name is too long.'))
            return False
        elif newName in self.data:
            balt.showError(self.parent,_(u'Name is already used.'))
            return False
        #--Rename
        self.data[newName] = self.data.pop(oldName)
        self.changed = True
        return newName

    def save(self):
        """Handles save button."""
        if not self.changed:
            balt.showOk(self.parent,_(u'No changes made.'))
        else:
            self.changed = False #--Allows graceful effort if close fails.
            count = 0
            for newName,(oldName,records) in self.data.items():
                if newName == oldName: continue
                for record in records:
                    record.full = newName
                    record.setChanged()
                    record.getSize()
                count += 1
            self.saveFile.safeSave()
            balt.showOk(self.parent, _(u'Names modified: %d.') % count,self.saveFile.fileInfo.name.s)

#------------------------------------------------------------------------------
class Save_EditCreated(Link):
    """Allows user to rename custom items (spells, enchantments, etc)."""
    menuNames = {'ENCH':_(u'Rename Enchanted...'),
                 'SPEL':_(u'Rename Spells...'),
                 'ALCH':_(u'Rename Potions...')
                 }
    recordTypes = {'ENCH':('ARMO','CLOT','WEAP')}

    def __init__(self,type):
        if type not in Save_EditCreated.menuNames:
            raise ArgumentError
        Link.__init__(self)
        self.type = type
        self.menuName = Save_EditCreated.menuNames[self.type]

    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id, self.menuName)
        menu.AppendItem(menuItem)
        if len(data) != 1: menuItem.Enable(False)

    def Execute(self,event):
        """Handle menu selection."""
        #--Get save info for file
        fileName = GPath(self.data[0])
        fileInfo = self.window.data[fileName]
        #--Get SaveFile
        with balt.Progress(_(u"Loading...")) as progress:
            saveFile = bosh.SaveFile(fileInfo)
            saveFile.load(progress)
        #--No custom items?
        recordTypes = Save_EditCreated.recordTypes.get(self.type,(self.type,))
        records = [record for record in saveFile.created if record.recType in recordTypes]
        if not records:
            balt.showOk(self.window,_(u'No items to edit.'))
            return
        #--Open editor dialog
        data = Save_EditCreatedData(self.window,saveFile,recordTypes)
        dialog = balt.ListEditor(self.window,-1,self.menuName,data)
        dialog.ShowModal()
        dialog.Destroy()

#--------------------------------------------------------------------------
class Save_EditPCSpellsData(balt.ListEditorData):
    """Data capsule for pc spell editing dialog."""
    def __init__(self,parent,saveInfo):
        """Initialize."""
        self.saveSpells = bosh.SaveSpells(saveInfo)
        with balt.Progress(_(u'Loading Masters')) as progress:
            self.saveSpells.load(progress)
        self.data = self.saveSpells.getPlayerSpells()
        self.removed = set()
        #--GUI
        balt.ListEditorData.__init__(self,parent)
        self.showRemove = True
        self.showInfo = True
        self.showSave = True
        self.showCancel = True

    def getItemList(self):
        """Returns load list keys in alpha order."""
        return sorted(self.data.keys(),key=lambda a: a.lower())

    def getInfo(self,item):
        """Returns string info on specified item."""
        iref,record = self.data[item]
        return record.getEffectsSummary()

    def remove(self,item):
        """Removes item. Return true on success."""
        if not item in self.data: return False
        iref,record = self.data[item]
        self.removed.add(iref)
        del self.data[item]
        return True

    def save(self):
        """Handles save button click."""
        self.saveSpells.removePlayerSpells(self.removed)

#------------------------------------------------------------------------------
class Save_EditPCSpells(Link):
    """Save spell list editing dialog."""
    def AppendToMenu(self,menu,window,data):
        """Append ref replacer items to menu."""
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Delete Spells...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(len(data) == 1)

    def Execute(self,event):
        fileName = GPath(self.data[0])
        fileInfo = self.window.data[fileName]
        data = Save_EditPCSpellsData(self.window,fileInfo)
        dialog = balt.ListEditor(self.window,wx.ID_ANY,_(u'Player Spells'),data)
        dialog.ShowModal()
        dialog.Destroy()

#------------------------------------------------------------------------------
class Save_EditCreatedEnchantmentCosts(Link):
    """Dialogue and Menu for setting number of uses for Cast When Used Enchantments."""
    def AppendToMenu(self,menu,window,data):
        """Append to menu."""
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Set Number of Uses for Weapon Enchantments...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(len(data) == 1)

    def Execute(self,event):
        fileName = GPath(self.data[0])
        fileInfo = self.window.data[fileName]
        dialog = balt.askNumber(self.window,
            (_(u'Enter the number of uses you desire per recharge for all custom made enchantments.')
             + u'\n' +
             _(u'(Enter 0 for unlimited uses)')),
            prompt=_(u'Uses'),title=_(u'Number of Uses'),value=50,min=0,max=10000)
        if not dialog: return
        Enchantments = bosh.SaveEnchantments(fileInfo)
        Enchantments.load()
        Enchantments.setCastWhenUsedEnchantmentNumberOfUses(dialog)

#------------------------------------------------------------------------------
class Save_Move:
    """Moves or copies selected files to alternate profile."""
    def __init__(self,copyMode=False):
        """Initialize."""
        if copyMode:
            self.idList = ID_PROFILES
        else:
            self.idList = ID_PROFILES2
        self.copyMode = copyMode

    def GetItems(self):
        return [x.s for x in bosh.saveInfos.getLocalSaveDirs()]

    def AppendToMenu(self,menu,window,data):
        """Append label list to menu."""
        self.window = window
        self.data = data
        #--List
        localSave = bosh.saveInfos.localSave
        menuItem = wx.MenuItem(menu,self.idList.DEFAULT,_(u'Default'),kind=wx.ITEM_CHECK)
        menu.AppendItem(menuItem)
        menuItem.Enable(localSave != u'Saves\\')
        for id,item in zip(self.idList,self.GetItems()):
            menuItem = wx.MenuItem(menu,id,item,kind=wx.ITEM_CHECK)
            menu.AppendItem(menuItem)
            menuItem.Enable(localSave != (u'Saves\\'+item+u'\\'))
        #--Events
        wx.EVT_MENU(bashFrame,self.idList.DEFAULT,self.DoDefault)
        wx.EVT_MENU_RANGE(bashFrame,self.idList.BASE,self.idList.MAX,self.DoList)

    def DoDefault(self,event):
        """Handle selection of Default."""
        self.MoveFiles(_(u'Default'))

    def DoList(self,event):
        """Handle selection of label."""
        profile = self.GetItems()[event.GetId()-self.idList.BASE]
        self.MoveFiles(profile)

    def MoveFiles(self,profile):
        fileInfos = self.window.data
        destDir = bosh.dirs['saveBase'].join(u'Saves')
        if profile != _(u'Default'):
            destDir = destDir.join(profile)
        if destDir == fileInfos.dir:
            balt.showError(self.window,_(u"You can't move saves to the current profile!"))
            return
        savesTable = bosh.saveInfos.table
        #--bashDir
        destTable = bolt.Table(bosh.PickleDict(destDir.join('Bash','Table.dat')))
        count = 0
        ask = True
        for fileName in self.data:
            if ask and not self.window.data.moveIsSafe(fileName,destDir):
                message = (_(u'A file named %s already exists in %s. Overwrite it?')
                    % (fileName.s,profile))
                result = balt.askContinueShortTerm(self.window,message,_(u'Move File'))
                #if result is true just do the job but ask next time if applicable as well
                if not result: continue
                elif result == 2: ask = False #so don't warn for rest of operation
            if self.copyMode:
                bosh.saveInfos.copy(fileName,destDir)
            else:
                bosh.saveInfos.move(fileName,destDir,False)
            if fileName in savesTable:
                destTable[fileName] = savesTable.pop(fileName)
            count += 1
        destTable.save()
        bashFrame.RefreshData()
        if self.copyMode:
            balt.showInfo(self.window,_(u'%d files copied to %s.') % (count,profile),_(u'Copy File'))

#------------------------------------------------------------------------------
class Save_RepairAbomb(Link):
    """Repairs animation slowing by resetting counter(?) at end of TesClass data."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Repair Abomb'))
        menu.AppendItem(menuItem)
        menuItem.Enable(len(data) == 1)

    def Execute(self,event):
        #--File Info
        fileName = GPath(self.data[0])
        fileInfo = self.window.data[fileName]
        #--Check current value
        saveFile = bosh.SaveFile(fileInfo)
        saveFile.load()
        (tcSize,abombCounter,abombFloat) = saveFile.getAbomb()
        #--Continue?
        progress = 100*abombFloat/struct.unpack('f',struct.pack('I',0x49000000))[0]
        newCounter = 0x41000000
        if abombCounter <= newCounter:
            balt.showOk(self.window,_(u'Abomb counter is too low to reset.'),_(u'Repair Abomb'))
            return
        message = (_(u"Reset Abomb counter? (Current progress: %.0f%%.)")
                   + u'\n\n' +
                   _(u"Note: Abomb animation slowing won't occur until progress is near 100%%.")
                   ) % progress
        if balt.askYes(self.window,message,_(u'Repair Abomb'),default=False):
            saveFile.setAbomb(newCounter)
            saveFile.safeSave()
            balt.showOk(self.window,_(u'Abomb counter reset.'),_(u'Repair Abomb'))

#------------------------------------------------------------------------------
## TODO: This is probably unneccessary now.  v105 was a long time ago
class Save_RepairFactions(Link):
    """Repair factions from v 105 Bash error, plus mod faction changes."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Repair Factions'))
        menu.AppendItem(menuItem)
        menuItem.Enable(bool(bosh.modInfos.ordered) and len(data) == 1)

    def Execute(self,event):
        debug = False
        message = (_(u'This will (mostly) repair faction membership errors due to Wrye Bash v 105 bug and/or faction changes in underlying mods.')
                   + u'\n\n' +
                   _(u'WARNING!  This repair is NOT perfect!  Do not use it unless you have to!')
                   )
        if not balt.askContinue(self.window,message,
                'bash.repairFactions.continue',_(u'Repair Factions')):
            return
        question = _(u"Restore dropped factions too?  WARNING:  This may involve clicking through a LOT of yes/no dialogs.")
        restoreDropped = balt.askYes(self.window, question, _(u'Repair Factions'),default=False)
        legitNullSpells = bush.repairFactions_legitNullSpells
        legitNullFactions = bush.repairFactions_legitNullFactions
        legitDroppedFactions = bush.repairFactions_legitDroppedFactions
        with balt.Progress(_(u'Repair Factions')) as progress:
            #--Loop over active mods
            log = bolt.LogFile(StringIO.StringIO())
            offsetFlag = 0x80
            npc_info = {}
            fact_eid = {}
            loadFactory = bosh.LoadFactory(False,bosh.MreRecord.type_class['NPC_'],
                                                 bosh.MreRecord.type_class['FACT'])
            ordered = list(bosh.modInfos.ordered)
            subProgress = SubProgress(progress,0,0.4,len(ordered))
            for index,modName in enumerate(ordered):
                subProgress(index,_(u'Scanning ') + modName.s)
                modInfo = bosh.modInfos[modName]
                modFile = bosh.ModFile(modInfo,loadFactory)
                modFile.load(True)
                #--Loop over mod NPCs
                mapToOrdered = bosh.MasterMap(modFile.tes4.masters+[modName], ordered)
                for npc in modFile.NPC_.getActiveRecords():
                    fid = mapToOrdered(npc.fid,None)
                    if not fid: continue
                    factions = []
                    for entry in npc.factions:
                        faction = mapToOrdered(entry.faction,None)
                        if not faction: continue
                        factions.append((faction,entry.rank))
                    npc_info[fid] = (npc.eid,factions)
                #--Loop over mod factions
                for fact in modFile.FACT.getActiveRecords():
                    fid = mapToOrdered(fact.fid,None)
                    if not fid: continue
                    fact_eid[fid] = fact.eid
            #--Loop over savefiles
            subProgress = SubProgress(progress,0.4,1.0,len(self.data))
            message = _(u'NPC Factions Restored/UnNulled:')
            for index,saveName in enumerate(self.data):
                log.setHeader(u'== '+saveName.s,True)
                subProgress(index,_(u'Updating ') + saveName.s)
                saveInfo = self.window.data[saveName]
                saveFile = bosh.SaveFile(saveInfo)
                saveFile.load()
                records = saveFile.records
                mapToOrdered = bosh.MasterMap(saveFile.masters, ordered)
                mapToSave = bosh.MasterMap(ordered,saveFile.masters)
                refactionedCount = unNulledCount = 0
                for recNum in xrange(len(records)):
                    unFactioned = unSpelled = unModified = refactioned = False
                    (recId,recType,recFlags,version,data) = records[recNum]
                    if recType != 35: continue
                    orderedRecId = mapToOrdered(recId,None)
                    eid = npc_info.get(orderedRecId,('',))[0]
                    npc = bosh.SreNPC(recFlags,data)
                    recFlags = bosh.SreNPC.flags(recFlags)
                    #--Fix Bash v 105 null array bugs
                    if recFlags.factions and not npc.factions and recId not in legitNullFactions:
                        log(u'. %08X %s -- ' % (recId,eid) + _(u'Factions'))
                        npc.factions = None
                        unFactioned = True
                    if recFlags.modifiers and not npc.modifiers:
                        log(u'. %08X %s -- ' % (recId,eid) + _(u'Modifiers'))
                        npc.modifiers = None
                        unModified = True
                    if recFlags.spells and not npc.spells and recId not in legitNullSpells:
                        log(u'. %08X %s -- ' % (recId,eid) + _(u'Spells'))
                        npc.spells = None
                        unSpelled = True
                    unNulled = (unFactioned or unSpelled or unModified)
                    unNulledCount += (0,1)[unNulled]
                    #--Player, player faction
                    if recId == 7:
                        playerStartSpell = saveFile.getIref(0x00000136)
                        if npc.spells != None and playerStartSpell not in npc.spells:
                            log(u'. %08X %s -- **%s**' % (recId,eid._(u'DefaultPlayerSpell')))
                            npc.spells.append(playerStartSpell)
                            refactioned = True #--I'm lying, but... close enough.
                        playerFactionIref = saveFile.getIref(0x0001dbcd)
                        if (npc.factions != None and
                            playerFactionIref not in [iref for iref,level in npc.factions]
                            ):
                                log(u'. %08X %s -- **%s**' % (recId,eid,_(u'PlayerFaction, 0')))
                                npc.factions.append((playerFactionIref,0))
                                refactioned = True
                    #--Compare to mod data
                    elif orderedRecId in npc_info and restoreDropped:
                        (npcEid,factions) = npc_info[orderedRecId]
                        #--Refaction?
                        if npc.factions and factions:
                            curFactions = set([iref for iref,level in npc.factions])
                            for orderedId,level in factions:
                                fid = mapToSave(orderedId,None)
                                if not fid: continue
                                iref = saveFile.getIref(fid)
                                if iref not in curFactions and (recId,fid) not in legitDroppedFactions:
                                    factEid = fact_eid.get(orderedId,'------')
                                    question = _(u'Restore %s to %s faction?') % (npcEid,factEid)
                                    deprint(_(u'refactioned') +u' %08X %08X %s %s' % (recId,fid,npcEid,factEid))
                                    if not balt.askYes(self.window, question, saveName.s,default=False):
                                        continue
                                    log(u'. %08X %s -- **%s, %d**' % (recId,eid,factEid,level))
                                    npc.factions.append((iref,level))
                                    refactioned = True
                    refactionedCount += (0,1)[refactioned]
                    #--Save record changes?
                    if unNulled or refactioned:
                        saveFile.records[recNum] = (recId,recType,npc.getFlags(),version,npc.getData())
                #--Save changes?
                subProgress(index+0.5,_(u'Updating ') + saveName.s)
                if unNulledCount or refactionedCount:
                    saveFile.safeSave()
                message += u'\n%d %d %s' % (refactionedCount,unNulledCount,saveName.s,)
        balt.showWryeLog(self.window,log.out.getvalue(),_(u'Repair Factions'),icons=bashBlue)
        log.out.close()

#------------------------------------------------------------------------------
class Save_RepairHair(Link):
    """Repairs hair that has been zeroed due to removal of a hair mod."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Repair Hair'))
        menu.AppendItem(menuItem)
        if len(data) != 1: menuItem.Enable(False)

    def Execute(self,event):
        #--File Info
        fileName = GPath(self.data[0])
        fileInfo = self.window.data[fileName]
        if bosh.PCFaces.save_repairHair(fileInfo):
            balt.showOk(self.window,_(u'Hair repaired.'))
        else:
            balt.showOk(self.window,_(u'No repair necessary.'),fileName.s)

#------------------------------------------------------------------------------
class Save_ReweighPotions(Link):
    """Changes weight of all player potions to specified value."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Reweigh Potions...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(len(data) == 1)

    def Execute(self,event):
        #--Query value
        result = balt.askText(self.window,
            _(u"Set weight of all player potions to..."),
            _(u"Reweigh Potions"),
            u'%0.2f' % (settings.get('bash.reweighPotions.newWeight',0.2),))
        if not result: return
        try:
            newWeight = float(result.strip())
            if newWeight < 0 or newWeight > 100:
                raise Exception('')
        except:
            balt.showOk(self.window,_(u'Invalid weight: %s') % newWeight)
            return
        settings['bash.reweighPotions.newWeight'] = newWeight
        #--Do it
        fileName = GPath(self.data[0])
        fileInfo = self.window.data[fileName]
        with balt.Progress(_(u"Reweigh Potions")) as progress:
            saveFile = bosh.SaveFile(fileInfo)
            saveFile.load(SubProgress(progress,0,0.5))
            count = 0
            progress(0.5,_(u"Processing."))
            for index,record in enumerate(saveFile.created):
                if record.recType == 'ALCH':
                    record = record.getTypeCopy()
                    record.weight = newWeight
                    record.getSize()
                    saveFile.created[index] = record
                    count += 1
            if count:
                saveFile.safeSave(SubProgress(progress,0.6,1.0))
                progress.Destroy()
                balt.showOk(self.window,_(u'Potions reweighed: %d.') % count,fileName.s)
            else:
                progress.Destroy()
                balt.showOk(self.window,_(u'No potions to reweigh!'),fileName.s)

#------------------------------------------------------------------------------
class Save_Stats(Link):
    """Show savefile statistics."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Statistics'))
        menu.AppendItem(menuItem)
        if len(data) != 1: menuItem.Enable(False)

    def Execute(self,event):
        fileName = GPath(self.data[0])
        fileInfo = self.window.data[fileName]
        saveFile = bosh.SaveFile(fileInfo)
        with balt.Progress(_(u"Statistics")) as progress:
            saveFile.load(SubProgress(progress,0,0.9))
            log = bolt.LogFile(StringIO.StringIO())
            progress(0.9,_(u"Calculating statistics."))
            saveFile.logStats(log)
            progress.Destroy()
            text = log.out.getvalue()
            balt.showLog(self.window,text,fileName.s,asDialog=False,fixedFont=False,icons=bashBlue)

#------------------------------------------------------------------------------
class Save_StatObse(Link):
    """Dump .obse records."""
    def AppendToMenu(self,menu,window,data):
        if bush.game.se.shortName == '': return
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'.%s Statistics') % bush.game.se.shortName.lower())
        menu.AppendItem(menuItem)
        if len(data) != 1:
            menuItem.Enable(False)
        else:
            fileName = GPath(self.data[0])
            fileInfo = self.window.data[fileName]
            fileName = fileInfo.getPath().root+u'.'+bush.game.se.shortName
            menuItem.Enable(fileName.exists())

    def Execute(self,event):
        fileName = GPath(self.data[0])
        fileInfo = self.window.data[fileName]
        saveFile = bosh.SaveFile(fileInfo)
        with balt.Progress(u'.'+bush.game.se.shortName) as progress:
            saveFile.load(SubProgress(progress,0,0.9))
            log = bolt.LogFile(StringIO.StringIO())
            progress(0.9,_(u"Calculating statistics."))
            saveFile.logStatObse(log)
        text = log.out.getvalue()
        log.out.close()
        balt.showLog(self.window,text,fileName.s,asDialog=False,fixedFont=False,icons=bashBlue)

#------------------------------------------------------------------------------
class Save_Unbloat(Link):
    """Unbloats savegame."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Remove Bloat...'))
        menu.AppendItem(menuItem)
        if len(data) != 1: menuItem.Enable(False)

    def Execute(self,event):
        #--File Info
        saveName = GPath(self.data[0])
        saveInfo = self.window.data[saveName]
        delObjRefs = 0
        with balt.Progress(_(u'Scanning for Bloat')) as progress:
            #--Scan and report
            saveFile = bosh.SaveFile(saveInfo)
            saveFile.load(SubProgress(progress,0,0.8))
            createdCounts,nullRefCount = saveFile.findBloating(SubProgress(progress,0.8,1.0))
        #--Dialog
        if not createdCounts and not nullRefCount:
            balt.showOk(self.window,_(u'No bloating found.'),saveName.s)
            return
        message = u''
        if createdCounts:
            for type,name in sorted(createdCounts):
                message += u'  %s %s: %s\n' % (type,name,formatInteger(createdCounts[(type,name)]))
        if nullRefCount:
            message += u'  '+_(u'Null Ref Objects:')+ u' %s\n' % formatInteger(nullRefCount)
        message = (_(u'Remove savegame bloating?')
                   + u'\n'+message+u'\n' +
                   _(u'WARNING: This is a risky procedure that may corrupt your savegame!  Use only if necessary!')
                   )
        if not balt.askYes(self.window,message,_(u'Remove bloating?')):
            return
        #--Remove bloating
        with balt.Progress(_(u'Removing Bloat')) as progress:
            nums = saveFile.removeBloating(createdCounts.keys(),True,SubProgress(progress,0,0.9))
            progress(0.9,_(u'Saving...'))
            saveFile.safeSave()
        balt.showOk(self.window,
            (_(u'Uncreated Objects: %d')
             + u'\n' +
             _(u'Uncreated Refs: %d')
             + u'\n' +
             _(u'UnNulled Refs: %d')
             ) % nums,
            saveName.s)
        self.window.RefreshUI(saveName)

#------------------------------------------------------------------------------
class Save_UpdateNPCLevels(Link):
    """Update NPC levels from active mods."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Update NPC Levels...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(bool(data and bosh.modInfos.ordered))

    def Execute(self,event):
        debug = True
        message = _(u'This will relevel the NPCs in the selected save game(s) according to the npc levels in the currently active mods.  This supersedes the older "Import NPC Levels" command.')
        if not balt.askContinue(self.window,message,'bash.updateNpcLevels.continue',_(u'Update NPC Levels')):
            return
        with balt.Progress(_(u'Update NPC Levels')) as progress:
            #--Loop over active mods
            offsetFlag = 0x80
            npc_info = {}
            loadFactory = bosh.LoadFactory(False,bosh.MreRecord.type_class['NPC_'])
            ordered = list(bosh.modInfos.ordered)
            subProgress = SubProgress(progress,0,0.4,len(ordered))
            modErrors = []
            for index,modName in enumerate(ordered):
                subProgress(index,_(u'Scanning ') + modName.s)
                modInfo = bosh.modInfos[modName]
                modFile = bosh.ModFile(modInfo,loadFactory)
                try:
                    modFile.load(True)
                except bosh.ModError, x:
                    modErrors.append(u'%s'%x)
                    continue
                if 'NPC_' not in modFile.tops: continue
                #--Loop over mod NPCs
                mapToOrdered = bosh.MasterMap(modFile.tes4.masters+[modName], ordered)
                for npc in modFile.NPC_.getActiveRecords():
                    fid = mapToOrdered(npc.fid,None)
                    if not fid: continue
                    npc_info[fid] = (npc.eid, npc.level, npc.calcMin, npc.calcMax, npc.flags.pcLevelOffset)
            #--Loop over savefiles
            subProgress = SubProgress(progress,0.4,1.0,len(self.data))
            message = _(u'NPCs Releveled:')
            for index,saveName in enumerate(self.data):
                subProgress(index,_(u'Updating ') + saveName.s)
                saveInfo = self.window.data[saveName]
                saveFile = bosh.SaveFile(saveInfo)
                saveFile.load()
                records = saveFile.records
                mapToOrdered = bosh.MasterMap(saveFile.masters, ordered)
                releveledCount = 0
                #--Loop over change records
                for recNum in xrange(len(records)):
                    releveled = False
                    (recId,recType,recFlags,version,data) = records[recNum]
                    orderedRecId = mapToOrdered(recId,None)
                    if recType != 35 or recId == 7 or orderedRecId not in npc_info: continue
                    (eid,level,calcMin,calcMax,pcLevelOffset) = npc_info[orderedRecId]
                    npc = bosh.SreNPC(recFlags,data)
                    acbs = npc.acbs
                    if acbs and (
                        (acbs.level != level) or
                        (acbs.calcMin != calcMin) or
                        (acbs.calcMax != calcMax) or
                        (acbs.flags.pcLevelOffset != pcLevelOffset)
                        ):
                        acbs.flags.pcLevelOffset = pcLevelOffset
                        acbs.level = level
                        acbs.calcMin = calcMin
                        acbs.calcMax = calcMax
                        (recId,recType,recFlags,version,data) = saveFile.records[recNum]
                        records[recNum] = (recId,recType,npc.getFlags(),version,npc.getData())
                        releveledCount += 1
                        saveFile.records[recNum] = npc.getTuple(recId,version)
                #--Save changes?
                subProgress(index+0.5,_(u'Updating ') + saveName.s)
                if releveledCount:
                    saveFile.safeSave()
                message += u'\n%d %s' % (releveledCount,saveName.s)
        if modErrors:
            message += u'\n\n'+_(u'Some mods had load errors and were skipped:')+u'\n* '
            message += u'\n* '.join(modErrors)
        balt.showOk(self.window,message,_(u'Update NPC Levels'))

# Screen Links ------------------------------------------------------------------
#------------------------------------------------------------------------------
class Screens_NextScreenShot(Link):
    """Sets screenshot base name and number."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Next Shot...'))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        oblivionIni = bosh.oblivionIni
        base = oblivionIni.getSetting(u'Display',u'sScreenShotBaseName',u'ScreenShot')
        next = oblivionIni.getSetting(u'Display',u'iScreenShotIndex',u'0')
        rePattern = re.compile(ur'^(.+?)(\d*)$',re.I|re.U)
        pattern = balt.askText(self.window,(_(u"Screenshot base name, optionally with next screenshot number.")
                                            + u'\n' +
                                            _(u"E.g. ScreenShot or ScreenShot_101 or Subdir\\ScreenShot_201.")
                                            ),_(u"Next Shot..."),base+next)
        if not pattern: return
        maPattern = rePattern.match(pattern)
        newBase,newNext = maPattern.groups()
        settings = {LString(u'Display'):{
            LString(u'SScreenShotBaseName'): newBase,
            LString(u'iScreenShotIndex'): (newNext or next),
            LString(u'bAllowScreenShot'): u'1',
            }}
        screensDir = GPath(newBase).head
        if screensDir:
            if not screensDir.isabs(): screensDir = bosh.dirs['app'].join(screensDir)
            screensDir.makedirs()
        oblivionIni.saveSettings(settings)
        bosh.screensData.refresh()
        self.window.RefreshUI()

#------------------------------------------------------------------------------
class Screen_ConvertTo(Link):
    """Converts selected images to another type."""
    def __init__(self,ext,imageType):
        Link.__init__(self)
        self.ext = ext.lower()
        self.imageType = imageType

    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Convert to %s') % self.ext)
        menu.AppendItem(menuItem)
        convertable = [name for name in self.data if GPath(name).cext != u'.'+self.ext]
        menuItem.Enable(len(convertable) > 0)

    def Execute(self,event):
        srcDir = bosh.screensData.dir
        try:
            with balt.Progress(_(u"Converting to %s") % self.ext) as progress:
                progress.setFull(len(self.data))
                for index,fileName in enumerate(self.data):
                    progress(index,fileName.s)
                    srcPath = srcDir.join(fileName)
                    destPath = srcPath.root+u'.'+self.ext
                    if srcPath == destPath or destPath.exists(): continue
                    bitmap = wx.Image(srcPath.s)
                    # This only has an effect on jpegs, so it's ok to do it on every kind
                    bitmap.SetOptionInt(wx.IMAGE_OPTION_QUALITY,settings['bash.screens.jpgQuality'])
                    result = bitmap.SaveFile(destPath.s,self.imageType)
                    if not result: continue
                    srcPath.remove()
        finally:
            self.window.data.refresh()
            self.window.RefreshUI()

#------------------------------------------------------------------------------
class Screen_JpgQuality(Link):
    """Sets JPEG quality for saving."""
    def __init__(self,quality):
        Link.__init__(self)
        self.quality = quality
        self.label = u'%i' % self.quality

    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,self.label,kind=wx.ITEM_RADIO)
        menu.AppendItem(menuItem)
        if self.quality == settings['bash.screens.jpgQuality']:
            menuItem.Check(True)

    def Execute(self,event):
        settings['bash.screens.jpgQuality'] = self.quality

#------------------------------------------------------------------------------
class Screen_JpgQualityCustom(Screen_JpgQuality):
    """Sets a custom JPG quality."""
    def __init__(self):
        Screen_JpgQuality.__init__(self,settings['bash.screens.jpgCustomQuality'])
        self.label = _(u'Custom [%i]') % self.quality

    def Execute(self,event):
        quality = balt.askNumber(self.window,_(u'JPEG Quality'),value=self.quality,min=0,max=100)
        if quality is None: return
        self.quality = quality
        settings['bash.screens.jpgCustomQuality'] = self.quality
        self.label = _(u'Custom [%i]') % quality
        Screen_JpgQuality.Execute(self,event)

#------------------------------------------------------------------------------
class Screen_Rename(Link):
    """Renames files by pattern."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Rename...'))
        menu.AppendItem(menuItem)
        menuItem.Enable(len(data) > 0)

    def Execute(self,event):
        if len(self.data) > 0:
            index = self.window.list.FindItem(0,self.data[0].s)
            if index != -1:
                self.window.list.EditLabel(index)

# Messages Links ------------------------------------------------------------------
#------------------------------------------------------------------------------
class Messages_Archive_Import(Link):
    """Import messages from html message archive."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Import Archives...'))
        menu.AppendItem(menuItem)

    def Execute(self,event):
        textDir = settings.get('bash.workDir',bosh.dirs['app'])
        #--File dialog
        paths = balt.askOpenMulti(self.window,_(u'Import message archive(s):'),textDir,
            u'', u'*.html')
        if not paths: return
        settings['bash.workDir'] = paths[0].head
        for path in paths:
            bosh.messages.importArchive(path)
        self.window.RefreshUI()

#------------------------------------------------------------------------------
class Message_Delete(Link):
    """Delete the file and all backups."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menu.AppendItem(wx.MenuItem(menu,self.id,_(u'Delete')))

    def Execute(self,event):
        message = _(u'Delete these %d message(s)? This operation cannot be undone.') % len(self.data)
        if not balt.askYes(self.window,message,_(u'Delete Messages')):
            return
        #--Do it
        for message in self.data:
            self.window.data.delete(message)
        #--Refresh stuff
        self.window.RefreshUI()

# People Links ------------------------------------------------------------------
#------------------------------------------------------------------------------
class People_AddNew(Link):
    """Add a new record."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Add...'))
        menu.AppendItem(menuItem)
        self.title = _(u'Add New Person')

    def Execute(self,event):
        name = balt.askText(self.gTank,_(u"Add new person:"),self.title)
        if not name: return
        if name in self.data:
            return balt.showInfo(self.gTank,name+_(u" already exists."),self.title)
        self.data[name] = (time.time(),0,u'')
        self.gTank.RefreshUI(details=name)
        self.gTank.gList.EnsureVisible(self.gTank.GetIndex(name))
        self.data.setChanged()

#------------------------------------------------------------------------------
class People_Export(Link):
    """Export people to text archive."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Export...'))
        menu.AppendItem(menuItem)
        self.title = _(u"Export People")

    def Execute(self,event):
        textDir = settings.get('bash.workDir',bosh.dirs['app'])
        #--File dialog
        path = balt.askSave(self.gTank,_(u'Export people to text file:'),textDir,
            u'People.txt', u'*.txt')
        if not path: return
        settings['bash.workDir'] = path.head
        self.data.dumpText(path,self.selected)
        balt.showInfo(self.gTank,_(u'Records exported: %d.') % len(self.selected),self.title)

#------------------------------------------------------------------------------
class People_Import(Link):
    """Import people from text archive."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u'Import...'))
        menu.AppendItem(menuItem)
        self.title = _(u"Import People")

    def Execute(self,event):
        textDir = settings.get('bash.workDir',bosh.dirs['app'])
        #--File dialog
        path = balt.askOpen(self.gTank,_(u'Import people from text file:'),textDir,
            u'', u'*.txt',mustExist=True)
        if not path: return
        settings['bash.workDir'] = path.head
        newNames = self.data.loadText(path)
        balt.showInfo(self.gTank,_(u"People imported: %d") % len(newNames),self.title)
        self.gTank.RefreshUI()

#------------------------------------------------------------------------------
class People_Karma(Link):
    """Add Karma setting links."""

    def AppendToMenu(self,menu,window,data):
        """Append Karma item submenu."""
        Link.AppendToMenu(self,menu,window,data)
        idList = ID_GROUPS
        labels = [u'%+d'%x for x in xrange(5,-6,-1)]
        subMenu = wx.Menu()
        for id,item in zip(idList,labels):
            subMenu.Append(id,item)
        wx.EVT_MENU_RANGE(bashFrame,idList.BASE,idList.MAX,self.DoList)
        menu.AppendMenu(-1,_(u'Karma'),subMenu)

    def DoList(self,event):
        """Handle selection of label."""
        idList = ID_GROUPS
        karma = range(5,-6,-1)[event.GetId()-idList.BASE]
        for item in self.selected:
            text = self.data[item][2]
            self.data[item] = (time.time(),karma,text)
        self.gTank.RefreshUI()
        self.data.setChanged()

# Masters Links ---------------------------------------------------------------
#------------------------------------------------------------------------------
class Master_ChangeTo(Link):
    """Rename/replace master through file dialog."""
    def AppendToMenu(self,menu,window,data):
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u"Change to..."))
        menu.AppendItem(menuItem)
        menuItem.Enable(self.window.edited)

    def Execute(self,event):
        itemId = self.data[0]
        masterInfo = self.window.data[itemId]
        masterName = masterInfo.name
        #--File Dialog
        wildcard = _(u'%s Mod Files')%bush.game.name+u' (*.esp;*.esm)|*.esp;*.esm'
        newPath = balt.askOpen(self.window,_(u'Change master name to:'),
            bosh.modInfos.dir, masterName, wildcard,mustExist=True)
        if not newPath: return
        (newDir,newName) = newPath.headTail
        #--Valid directory?
        if newDir != bosh.modInfos.dir:
            balt.showError(self.window,
                _(u"File must be selected from Oblivion Data Files directory."))
            return
        elif newName == masterName:
            return
        #--Save Name
        masterInfo.setName(newName)
        self.window.ReList()
        self.window.PopulateItems()
        settings.getChanged('bash.mods.renames')[masterName] = newName

#------------------------------------------------------------------------------
class Master_Disable(Link):
    """Rename/replace master through file dialog."""
    def AppendToMenu(self,menu,window,data):
        if window.fileInfo.isMod(): return #--Saves only
        Link.AppendToMenu(self,menu,window,data)
        menuItem = wx.MenuItem(menu,self.id,_(u"Disable"))
        menu.AppendItem(menuItem)
        menuItem.Enable(self.window.edited)

    def Execute(self,event):
        itemId = self.data[0]
        masterInfo = self.window.data[itemId]
        masterName = masterInfo.name
        newName = GPath(re.sub(u'[mM]$','p',u'XX'+masterName.s))
        #--Save Name
        masterInfo.setName(newName)
        self.window.ReList()
        self.window.PopulateItems()

# App Links -------------------------------------------------------------------
#------------------------------------------------------------------------------
class StatusBar_Button(Link):
    """Launch an application."""
    def __init__(self,uid=None,canHide=True,tip=u''):
        """ui: Unique identifier, used for saving the order of status bar icons
               and whether they are hidden/shown.
           canHide: True if this button is allowed to be hidden."""
        Link.__init__(self)
        self.mainMenu = Links()
        self.canHide = canHide
        self.gButton = None
        self._tip = tip
        if uid is None: uid = (self.__class__.__name__,tip)
        self.uid = uid

    def createButton(self, *args, **kwdargs):
        if len(args) < 11 and 'onRClick' not in kwdargs:
            kwdargs['onRClick'] = self.DoPopupMenu
        if len(args) < 9 and 'onClick' not in kwdargs:
            kwdargs['onClick'] = self.Execute
        if self.gButton is not None:
            self.gButton.Destroy()
        self.gButton = bitmapButton(*args, **kwdargs)
        return self.gButton

    def DoPopupMenu(self,event):
        if self.canHide:
            if len(self.mainMenu) == 0 or not isinstance(self.mainMenu[-1],StatusBar_Hide):
                if len(self.mainMenu) > 0:
                    self.mainMenu.append(SeparatorLink())
                self.mainMenu.append(StatusBar_Hide())
        if len(self.mainMenu) > 0:
            self.mainMenu.PopupMenu(self.gButton,bashFrame,0)
        else:
            event.Skip()

    # Helper function to get OBSE version
    @property
    def obseVersion(self):
        if bosh.inisettings['SteamInstall']:
            file = bush.game.se.steamExe
        else:
            file = bush.game.se.exe
        version = bosh.dirs['app'].join(file).strippedVersion
        return u'.'.join([u'%s'%x for x in version])

#------------------------------------------------------------------------------
class App_Button(StatusBar_Button):
    """Launch an application."""
    obseButtons = []

    @property
    def version(self):
        if not self.isJava and self.IsPresent():
            version = self.exePath.strippedVersion
            if version != (0,):
                version = u'.'.join([u'%s'%x for x in version])
                return version
        return ''

    @property
    def tip(self):
        if not settings['bash.statusbar.showversion']: return self._tip
        else:
            return self._tip + u' ' + self.version

    @property
    def obseTip(self):
        if self._obseTip is not None:
            if not settings['bash.statusbar.showversion']: return self._obseTip % (dict(version=u''))
            else: return self._obseTip % (dict(version=self.version))
        else: return None

    def __init__(self,exePathArgs,images,tip,obseTip=None,obseArg=None,workingDir=None,uid=None,canHide=True):
        """Initialize
        exePathArgs (string): exePath
        exePathArgs (tuple): (exePath,*exeArgs)
        exePathArgs (list):  [exePathArgs,altExePathArgs,...]
        images: [16x16,24x24,32x32] images
        """
        StatusBar_Button.__init__(self,uid,canHide,tip)
        if isinstance(exePathArgs, list):
            use = exePathArgs[0]
            for item in exePathArgs:
                if isinstance(item, tuple):
                    exePath = item[0]
                else:
                    exePath = item
                if exePath.exists():
                    # Use this one
                    use = item
                    break
            exePathArgs = use
        if isinstance(exePathArgs,tuple):
            self.exePath = exePathArgs[0]
            self.exeArgs = exePathArgs[1:]
        else:
            self.exePath = exePathArgs
            self.exeArgs = tuple()
        self.images = images
        if workingDir:
            self.workingDir = GPath(workingDir)
        else:
            self.workingDir = None
        #--Exe stuff
        if self.exePath and self.exePath.cext == u'.exe': #Sometimes exePath is "None"
            self.isExe = True
        else:
            self.isExe = False
        #--Java stuff
        if self.exePath and self.exePath.cext == u'.jar': #Sometimes exePath is "None"
            self.isJava = True
            self.java = GPath(os.environ['SYSTEMROOT']).join(u'system32',u'javaw.exe')
            self.jar = self.exePath
            self.appArgs = u''.join(self.exeArgs)
        else:
            self.isJava = False
        #--shortcut
        if self.exePath and self.exePath.cext == u'.lnk': #Sometimes exePath is "None"
            self.isShortcut = True
        else:
            self.isShortcut = False
        #--Folder
        if self.exePath and self.exePath.isdir():
            self.isFolder = True
        else:
            self.isFolder = False
        #--**SE stuff
        self._obseTip = obseTip
        self.obseArg = obseArg
        exeObse = bosh.dirs['app'].join(bush.game.se.exe)

    def IsPresent(self):
        if self.isJava:
            return self.java.exists() and self.jar.exists()
        else:
            if self.exePath in bosh.undefinedPaths:
                return False
            return self.exePath.exists()

    def GetBitmapButton(self,window,style=0):
        if self.IsPresent():
            size = settings['bash.statusbar.iconSize']
            idex = (size/8)-2
            self.createButton(window,self.images[idex].GetBitmap(),
                              style=style,tip=self.tip)
            if self.obseTip != None:
                App_Button.obseButtons.append(self)
                exeObse = bosh.dirs['app'].join(bush.game.se.exe)
                if settings.get('bash.obse.on',False) and exeObse.exists():
                    self.gButton.SetToolTip(tooltip(self.obseTip))
            return self.gButton
        else:
            return None

    def Execute(self,event,extraArgs=None):
        if self.IsPresent():
            if self.isShortcut or self.isFolder:
                os.startfile(self.exePath.s)
            elif self.isJava:
                cwd = bolt.Path.getcwd()
                if self.workingDir:
                    self.workingDir.setcwd()
                else:
                    self.jar.head.setcwd()
                try:
                    subprocess.Popen((self.java.stail,u'-jar',self.jar.stail,self.appArgs), executable=self.java.s, close_fds=bolt.close_fds) #close_fds is needed for the one instance checker
                except UnicodeError:
                    balt.showError(bashFrame,
                                   _(u'Execution failed, because one or more of the command line arguments failed to encode.'),
                                   _(u"Could not launch '%s'") % self.exePath.stail)
                except Exception, error:
                    balt.showError(
                        bashFrame,
                        (u'%s'%error + u'\n\n' +
                         _(u'Used Path: ') + self.exePath.s + u'\n' +
                         _(u'Used Arguments: ') + u'%s' % self.exeArgs),
                        _(u"Could not launch '%s'") % self.exePath.stail)
                finally:
                    cwd.setcwd()
            elif self.isExe:
                exeObse = bosh.dirs['app'].join(bush.game.se.exe)
                exeLaa = bosh.dirs['app'].join(bush.game.laa.exe)
                if exeLaa.exists() and settings.get('bash.laa.on',True) and self.exePath.tail == bush.game.exe:
                    # Should use the LAA Launcher
                    exePath = exeLaa
                    args = [exePath.s]
                elif self.obseArg != None and settings.get('bash.obse.on',False) and exeObse.exists():
                    if bosh.inisettings['SteamInstall'] and self.exePath.tail == u'Oblivion.exe':
                        exePath = self.exePath
                    else:
                        exePath = exeObse
                    args = [exePath.s]
                    if self.obseArg != u'':
                        args.append(u'%s' % self.obseArg)
                else:
                    exePath = self.exePath
                    args = [exePath.s]
                args.extend(self.exeArgs)
                if extraArgs: args.extend(extraArgs)
                statusBar.SetStatusText(u' '.join(args[1:]),1)
                cwd = bolt.Path.getcwd()
                if self.workingDir:
                    self.workingDir.setcwd()
                else:
                    exePath.head.setcwd()
                try:
                    subprocess.Popen(args, close_fds=bolt.close_fds) #close_fds is needed for the one instance checker
                except UnicodeError:
                    balt.showError(bashFrame,
                                   _(u'Execution failed, because one or more of the command line arguments failed to encode.'),
                                   _(u"Could not launch '%s'") % self.exePath.stail)
                except WindowsError, werr:
                    if werr.winerror != 740:
                        balt.showError(
                            bashFrame,
                            (u'%s'%werr + u'\n\n' +
                             _(u'Used Path: ') + self.exePath.s + u'\n' +
                             _(u'Used Arguments: ') + u'%s' % self.exeArgs),
                            _(u"Could not launch '%s'") % self.exePath.stail)
                    try:
                        import win32api
                        win32api.ShellExecute(0,u"open",exePath.s,u'%s'%self.exeArgs,bosh.dirs['app'].s,1)
                    except:
                        balt.showError(
                            bashFrame,
                            (u'%s'%werr + u'\n\n' +
                             _(u'Used Path: ') + self.exePath.s + u'\n' +
                             _(u'Used Arguments: ') + u'%s' % self.exeArgs),
                            _(u"Could not launch '%s'") % self.exePath.stail)
                except Exception, error:
                    balt.showError(
                        bashFrame,
                        (u'%s'%error + u'\n\n' +
                         _(u'Used Path: ') + self.exePath.s + u'\n' +
                         _(u'Used Arguments: ') + u'%s' % self.exeArgs),
                        _(u"Could not launch '%s'") % self.exePath.stail)
                finally:
                    cwd.setcwd()
            else:
                try:
                    if self.workingDir:
                        dir = self.workingDir.s
                    else:
                        dir = bolt.Path.getcwd().s

                    import win32api
                    r, executable = win32api.FindExecutable(self.exePath.s)
                    executable = win32api.GetLongPathName(executable)
                    args = u'"%s"' % self.exePath.s
                    for arg in self.exeArgs:
                        args += u' %s' % arg
                    win32api.ShellExecute(0,u"open",executable,args,dir,1)
                except Exception, error:
                    # Most likely we're here because FindExecutable failed (no file association)
                    # Or because win32api import failed.  Try doing it using os.startfile
                    cwd = bolt.Path.getcwd()
                    if self.workingDir:
                        self.workingDir.setcwd()
                    else:
                        self.exePath.head.setcwd()
                    try:
                        os.startfile(self.exePath.s)
                    except UnicodeError:
                        balt.showError(bashFrame,
                                       _(u'Execution failed, because one or more of the command line arguments failed to encode.'),
                                       _(u"Could not launch '%s'") % self.exePath.stail)
                    except Exception, error:
                        balt.showError(
                            bashFrame,
                            (u'%s'%error + u'\n\n' +
                             _(u'Used Path: ') + self.exePath.s + u'\n' +
                             _(u'Used Arguments: ') + u'%s' % self.exeArgs),
                            _(u"Could not launch '%s'") % self.exePath.stail)
                    finally:
                        cwd.setcwd()
        else:
            balt.showError(bashFrame,
                           _(u'Application missing: %s') % self.exePath.s,
                           _(u"Could not launch '%s'" % self.exePath.stail)
                           )

#------------------------------------------------------------------------------
class Tooldir_Button(App_Button):
    """Just an App_Button that's path is in bosh.tooldirs
       Use this to automatically set the uid for the App_Button."""
    def __init__(self,toolKey,images,tip,obseTip=None,obseArg=None,workingDir=None,canHide=True):
        App_Button.__init__(self,bosh.tooldirs[toolKey],images,tip,obseTip,obseArg,workingDir,toolKey,canHide)

#------------------------------------------------------------------------------
class App_Tes4Gecko(App_Button):
    """Left in for unpickling compatibility reasons."""
    def __setstate__(self, state):
        self.__dict__.update(state)
        self.__class__ = App_Button

#------------------------------------------------------------------------------
class App_OblivionBookCreator(App_Button):
    """Left in for unpickling compatibility reasons."""
    def __setstate__(self, state):
        self.__dict__.update(state)
        self.__class__ = App_Button
#------------------------------------------------------------------------------
class App_Tes4View(App_Button):
    """Allow some extra args for Tes4View."""

# arguments
# -fixup (wbAllowInternalEdit true default)
# -nofixup (wbAllowInternalEdit false)
# -showfixup (wbShowInternalEdit true default)
# -hidefixup (wbShowInternalEdit false)
# -skipbsa (wbLoadBSAs false)
# -forcebsa (wbLoadBSAs true default)
# -fixuppgrd
# -IKnowWhatImDoing
# -FNV
#  or name begins with FNV
# -FO3
#  or name begins with FO3
# -TES4
#  or name begins with TES4
# -lodgen
#  or name ends with LODGen.exe
#  (requires TES4 mode)
# -masterupdate
#  or name ends with MasterUpdate.exe
#  (requires FO3 or FNV)
#  -filteronam
#  -FixPersistence
#  -NoFixPersistence
# -masterrestore
#  or name ends with MasterRestore.exe
#  (requires FO3 or FNV)
# -edit
#  or name ends with Edit.exe
# -translate
#  or name ends with Trans.exe
    def __init__(self,*args,**kwdargs):
        App_Button.__init__(self,*args,**kwdargs)
        self.mainMenu.append(Mods_Tes4ViewExpert())

    def IsPresent(self):
        if self.exePath in bosh.undefinedPaths or not self.exePath.exists():
            testPath = bosh.tooldirs['Tes4ViewPath']
            if testPath not in bosh.undefinedPaths and testPath.exists():
                self.exePath = testPath
                return True
            return False
        return True

    def Execute(self,event):
        extraArgs = []
        if wx.GetKeyState(wx.WXK_CONTROL):
            extraArgs.append(u'-FixupPGRD')
        if wx.GetKeyState(wx.WXK_SHIFT):
            extraArgs.append(u'-skipbsa')
        if settings['tes4View.iKnowWhatImDoing']:
            extraArgs.append(u'-IKnowWhatImDoing')
        App_Button.Execute(self,event,tuple(extraArgs))

#------------------------------------------------------------------------------
class App_BOSS(App_Button):
    """loads BOSS"""
    def __init__(self, *args, **kwdargs):
        App_Button.__init__(self, *args, **kwdargs)
        self.mainMenu.append(Mods_BOSSLaunchGUI())
        self.mainMenu.append(Mods_BOSSDisableLockTimes())

    def Execute(self,event,extraArgs=None):
        if self.IsPresent():
            exeObse = bosh.dirs['app'].join(bush.game.se.exe)
            exeArgs = self.exeArgs
            if self.obseArg != None and settings.get('bash.obse.on',False) and exeObse.exists():
                exePath = exeObse
                if self.obseArg != u'': exeArgs += (self.obseArg,)
            else:
                exePath = self.exePath
            exeArgs = (exePath.stail,)+exeArgs
            if extraArgs: exeArgs += extraArgs
            statusBar.SetStatusText(u' '.join(exeArgs),1)
            cwd = bolt.Path.getcwd()
            exePath.head.setcwd()
            with balt.Progress(_(u"Executing BOSS")) as progress:
                if wx.GetKeyState(82) and wx.GetKeyState(wx.WXK_SHIFT):
                    exeArgs += (u'-r 2',) # Revert level 2 - BOSS version 1.6+
                elif wx.GetKeyState(82):
                    exeArgs += (u'-r 1',) # Revert level 1 - BOSS version 1.6+
                if wx.GetKeyState(83):
                    exeArgs += (u'-s',) # Silent Mode - BOSS version 1.6+
                if wx.GetKeyState(67): #c - print crc calculations in BOSS log.
                    exeArgs += (u'-c',)
                if bosh.dirs['boss'].join('BOSS.exe').version >= (2,0,0,0):
                    # After version 2.0, need to pass in the -g argument
                    exeArgs += (u'-g%s' % bush.game.name,)
                progress(0.05,_(u"Processing... launching BOSS."))
                try:
                    subprocess.call((exePath.s,) + exeArgs[1:], startupinfo=bosh.startupinfo, close_fds=bolt.close_fds)
                    if settings['BOSS.ClearLockTimes']:
                        # Clear the saved times from before
                        bosh.modInfos.mtimes.clear()
                        # And refresh to get the new times so WB will keep the order that BOSS specifies
                        bosh.modInfos.refresh(doInfos=False)
                        # Refresh UI, so WB is made aware of the changes to loadorder.txt
                        modList.RefreshUI('ALL')
                except Exception, error:
                    balt.showError(bashFrame,
                                   (_(u"Used Path: %s") % exePath.s + u'\n' +
                                    _(u"Used Arguments: %s") % exeArgs),
                                    _(u'Could not launch BOSS'))
                finally:
                    cwd.setcwd()
        else:
            bolt.showError(bashFrame,
                           _(u'Application missing: %s') % self.exePath.s,
                           _(u'Could not launch BOSS'))

#------------------------------------------------------------------------------
class Oblivion_Button(App_Button):
    """Will close app on execute if autoquit is on."""
    @property
    def tip(self):
        if not settings['bash.statusbar.showversion']:
            tip = self._tip
        else:
            tip = self._tip + u' ' + self.version
        if bosh.dirs['app'].join(bush.game.laa.exe).exists() and settings.get('bash.laa.on',True):
            tip += u' + ' + bush.game.laa.name
        return tip

    @property
    def obseTip(self):
        # Oblivion (version)
        if settings['bash.statusbar.showversion']:
            tip = self._obseTip % (dict(version=self.version))
        else:
            tip = self._obseTip % (dict(version=''))
        # + OBSE
        tip += u' + %s %s' % (bush.game.se.shortName, self.obseVersion)
        # + LAA
        if bosh.dirs['app'].join(bush.game.laa.exe).exists() and settings.get('bash.laa.on',True):
            tip += u' + ' + bush.game.laa.name
        return tip

    def Execute(self,event):
        App_Button.Execute(self,event)
        if settings.get('bash.autoQuit.on',False):
            bashFrame.Close(True)

#------------------------------------------------------------------------------
class TESCS_Button(App_Button):
    """CS button.  Needs a special Tooltip when OBSE is enabled."""
    @property
    def obseTip(self):
        # TESCS (version)
        if settings['bash.statusbar.showversion']:
            tip = self._obseTip % (dict(version=self.version))
        else:
            tip = self._obseTip % (dict(version=''))
        if not self.obseArg: return tip
        # + OBSE
        tip += u' + %s %s' % (bush.game.se.shortName, self.obseVersion)
        # + CSE
        path = bosh.dirs['mods'].join(u'obse',u'plugins',u'Construction Set Extender.dll')
        if path.exists():
            version = path.strippedVersion
            if version != (0,):
                version = u'.'.join([u'%i'%x for x in version])
            else:
                version = u''
            tip += u' + CSE %s' % version
        return tip

#------------------------------------------------------------------------------
class Obse_Button(StatusBar_Button):
    """Obse on/off state button."""
    def SetState(self,state=None):
        """Sets state related info. If newState != none, sets to new state first.
        For convenience, returns state when done."""
        if state == None: #--Default
            state = settings.get('bash.obse.on',True)
        elif state == -1: #--Invert
            state = not settings.get('bash.obse.on',False)
        settings['bash.obse.on'] = state
        if bush.game.laa.launchesSE and not state and laaButton.gButton is not None:
            # 4GB Launcher automatically launches the SE, so turning of the SE
            # required turning off the 4GB Laucner as well
            laaButton.SetState(state)
        # BitmapButton
        image = images[(u'checkbox.green.off.%s'%settings['bash.statusbar.iconSize'],
                        u'checkbox.green.on.%s'%settings['bash.statusbar.iconSize'])[state]]
        tip = ((_(u"%s %s Disabled"),_(u"%s %s Enabled"))[state]) % (bush.game.se.shortName, self.obseVersion)
        self.gButton.SetBitmapLabel(image.GetBitmap())
        self.gButton.SetToolTip(tooltip(tip))
        self.UpdateToolTips(state)

    def UpdateToolTips(self,state=None):
        if state is None:
            state = settings.get('bash.obse.on',True)
        tipAttr = ('tip','obseTip')[state]
        for button in App_Button.obseButtons:
            button.gButton.SetToolTip(tooltip(getattr(button,tipAttr,u'')))
        return state

    def GetBitmapButton(self,window,style=0):
        exeObse = bosh.dirs['app'].join(bush.game.se.exe)
        if exeObse.exists():
            bitmap = images[u'checkbox.green.off.%s'%settings['bash.statusbar.iconSize']].GetBitmap()
            self.createButton(window,bitmap,style=style)
            self.SetState()
            return self.gButton
        else:
            return None

    def Execute(self,event):
        """Invert state."""
        self.SetState(-1)

class LAA_Button(Obse_Button):
    """4GB Launcher on/off state button."""
    def SetState(self,state=None):
        """Sets state related info.  If newState != none, sets to new state first.
        For convenience, returns state when done."""
        if state == None: #--Default
            state = settings.get('bash.laa.on',True)
        elif state == -1: #--Invert
            state = not settings.get('bash.laa.on',False)
        settings['bash.laa.on'] = state
        if bush.game.laa.launchesSE and obseButton.gButton is not None:
            if state:
                # If the 4gb launcher launces the SE, enable the SE when enabling this
                obseButton.SetState(state)
            else:
                # We need the obse button to update the tooltips anyway
                obseButton.UpdateToolTips()
        # BitmapButton
        image = images[(u'checkbox.blue.off.%s'%settings['bash.statusbar.iconSize'],
                        u'checkbox.blue.on.%s'%settings['bash.statusbar.iconSize'])[state]]
        tip = bush.game.laa.name + (_(u' Disabled'),_(u' Enabled'))[state]
        if self.gButton:
            self.gButton.SetBitmapLabel(image.GetBitmap())
            self.gButton.SetToolTip(tooltip(tip))
        return state

    def GetBitmapButton(self,window,style=0):
        exeLAA = bosh.dirs['app'].join(bush.game.laa.exe)
        if exeLAA.exists():
            bitmap = images[u'checkbox.blue.off.%s'%settings['bash.statusbar.iconSize']].GetBitmap()
            self.createButton(window,bitmap,style=style)
            self.SetState()
            return self.gButton
        else:
            return None

#------------------------------------------------------------------------------
class AutoQuit_Button(StatusBar_Button):
    """Button toggling application closure when launching Oblivion."""
    def SetState(self,state=None):
        """Sets state related info. If newState != none, sets to new state first.
        For convenience, returns state when done."""
        if state == None: #--Default
            state = settings.get('bash.autoQuit.on',False)
        elif state == -1: #--Invert
            state = not settings.get('bash.autoQuit.on',False)
        settings['bash.autoQuit.on'] = state
        image = images[(u'checkbox.red.off.%s'%settings['bash.statusbar.iconSize'],
                        u'checkbox.red.x.%s'%settings['bash.statusbar.iconSize'])[state]]
        tip = (_(u"Auto-Quit Disabled"),_(u"Auto-Quit Enabled"))[state]
        self.gButton.SetBitmapLabel(image.GetBitmap())
        self.gButton.SetToolTip(tooltip(tip))

    def GetBitmapButton(self,window,style=0):
        bitmap = images[u'checkbox.red.off.%s'%settings['bash.statusbar.iconSize']].GetBitmap()
        self.createButton(window,bitmap,style=style)
        self.SetState()
        return self.gButton

    def Execute(self,event):
        """Invert state."""
        self.SetState(-1)

#------------------------------------------------------------------------------
class App_Help(StatusBar_Button):
    """Show help browser."""
    def GetBitmapButton(self,window,style=0):
        if not self.id: self.id = wx.NewId()
        self.createButton(
            window,
            images[u'help.%s'%settings['bash.statusbar.iconSize']].GetBitmap(),
            style=style,
            tip=_(u"Help File"))
        return self.gButton

    def Execute(self,event):
        """Handle menu selection."""
        html = bosh.dirs['mopy'].join(u'Wrye Bash General Readme.html')
        if not html.exists():
            bolt.WryeText.genHtml(bosh.dirs['mopy'].join(u'Wrye Bash.txt').s, None, bosh.dirs['mopy'])
        html.start()

#------------------------------------------------------------------------------
class App_DocBrowser(StatusBar_Button):
    """Show doc browser."""
    def GetBitmapButton(self,window,style=0):
        if not self.id: self.id = wx.NewId()
        self.createButton(
            window,
            images[u'doc.%s'%settings['bash.statusbar.iconSize']].GetBitmap(),
            style=style,
            tip=_(u"Doc Browser"))
        return self.gButton

    def Execute(self,event):
        """Handle menu selection."""
        if not docBrowser:
            DocBrowser().Show()
            settings['bash.modDocs.show'] = True
        #balt.ensureDisplayed(docBrowser)
        docBrowser.Raise()

#------------------------------------------------------------------------------
class App_Settings(StatusBar_Button):
    """Show color configuration dialog."""
    def GetBitmapButton(self,window,style=0):
        if not self.id: self.id = wx.NewId()
        self.createButton(
            window,
            Image(GPath(bosh.dirs['images'].join(u'tes4gecko%s.png'%settings['bash.statusbar.iconSize']))).GetBitmap(),
            style=style,
            tip=_(u'Settings'),
            onRClick=self.Execute)
        return self.gButton

    def Execute(self,event):
        SettingsMenu.PopupMenu(bashFrame.GetStatusBar(),bashFrame,None)

#------------------------------------------------------------------------------
class App_Restart(StatusBar_Button):
    """Restart Wrye Bash"""
    def GetBitmapButton(self,window,style=0):
        if not self.id: self.id = wx.NewId()
        if self.gButton is not None: self.gButton.Destroy()
        self.gButton = bitmapButton(window,
            wx.ArtProvider.GetBitmap(wx.ART_UNDO,wx.ART_TOOLBAR,
                (settings['bash.statusbar.iconSize'],
                 settings['bash.statusbar.iconSize'])),
            style=style,
            tip=u'Restart',
            onClick = self.Execute,
            onRClick = self.DoPopupMenu)
        return self.gButton

    def Execute(self,event):
        bashFrame.Restart()

#------------------------------------------------------------------------------
class App_ModChecker(StatusBar_Button):
    """Show mod checker."""
    def GetBitmapButton(self,window,style=0):
        if not self.id: self.id = wx.NewId()
        return self.createButton(
            window,
            Image(GPath(bosh.dirs['images'].join(u'ModChecker%s.png'%settings['bash.statusbar.iconSize']))).GetBitmap(),
            style=style,
            tip=_(u"Mod Checker"))

    def Execute(self,event):
        """Handle menu selection."""
        if not modChecker:
            ModChecker().Show()
        #balt.ensureDisplayed(docBrowser)
        modChecker.Raise()

#------------------------------------------------------------------------------
class CreateNewProject(wx.Dialog):
    def __init__(self, parent, id, title):
        wx.Dialog.__init__(self, parent, id, title=u'Create New Project', size=wx.DefaultSize, style=wx.DEFAULT_DIALOG_STYLE)

        self.mopyDir = os.getcwd()
        self.bashinstallersDir = gInstallers.data.dir

        self.existingprojects = [] #start with a empty list.
        for dirname in os.listdir(u'%s' %self.bashinstallersDir):
            # print dirname
            if os.path.isdir(u'%s' %self.bashinstallersDir + os.sep + u'%s' %dirname):
                self.existingprojects.append(dirname)#Fill the list with the existing projects so the text control can identify duplicates and change background color

        # print self.existingprojects

        # Attributes
        self.panel = wx.Panel(self)
        self.statictext1 = wx.StaticText(self.panel, -1, u'What do you what to name the New Project?', (-1, -1), style=wx.TE_RICH2)
        self.textctrl = wx.TextCtrl(self.panel, -1, u'New Project Name-#####',(-1,-1))
        self.statictext2 = wx.StaticText(self.panel, -1, u'What do you what to add to the New Project?', (-1, -1))
        self.checkboxblankesp = wx.CheckBox(self.panel, -1, u'Blank.esp', (-1, -1))
        self.checkboxblankesp.SetValue(True)
        self.checkboxblankwizard = wx.CheckBox(self.panel, -1, u'Blank wizard.txt', (-1, -1))
        self.checkboxwizardimagesdirectory = wx.CheckBox(self.panel, -1, u'Wizard Images Directory', (-1, -1))
        if not bEnableWizard:
            self.checkboxblankwizard.Disable() #pyWin32 not installed
            self.checkboxwizardimagesdirectory.Disable() #pyWin32 not installed
        self.checkboxdocsdirectory = wx.CheckBox(self.panel, -1, u'Docs Directory', (-1, -1))
        self.checkboxscreenshotnoext = wx.CheckBox(self.panel, -1, u'Preview Screenshot(No.ext)(re-enable for BAIT)', (-1, -1))
        self.checkboxscreenshotnoext.Disable() #Remove this when BAIT gets preview stuff done
        self.staticline = wx.StaticLine(self.panel, -1, size=(-1, 2))
        self.okbutton = wx.Button(self.panel, -1, label=u'Ok', size=(100, 30))
        self.cancelbutton = wx.Button(self.panel, -1, label=u'Cancel', size=(100, 30))
        # Panel Layout
        hsizer = wx.BoxSizer(wx.HORIZONTAL)
        hsizer.Add(self.okbutton, 0, wx.ALL|wx.ALIGN_CENTER, 10)
        hsizer.Add(self.cancelbutton, 0, wx.ALL|wx.ALIGN_CENTER, 10)
        vsizer = wx.BoxSizer(wx.VERTICAL)
        vsizer.Add(self.statictext1, 0, wx.ALL|wx.ALIGN_CENTER, 10)
        vsizer.Add(self.textctrl, 0, wx.ALL|wx.ALIGN_CENTER|wx.EXPAND, 2)
        vsizer.Add(self.statictext2, 0, wx.ALL|wx.ALIGN_CENTER, 10)
        vsizer.Add(self.checkboxblankesp, 0, wx.ALL|wx.ALIGN_TOP, 5)
        vsizer.Add(self.checkboxblankwizard, 0, wx.ALL|wx.ALIGN_TOP, 5)
        vsizer.Add(self.checkboxwizardimagesdirectory, 0, wx.ALL|wx.ALIGN_TOP, 5)
        vsizer.Add(self.checkboxdocsdirectory, 0, wx.ALL|wx.ALIGN_TOP, 5)
        vsizer.Add(self.checkboxscreenshotnoext, 0, wx.ALL|wx.ALIGN_TOP, 5)
        vsizer.Add(self.staticline, 0, wx.ALL|wx.EXPAND, 5)
        vsizer.AddStretchSpacer()
        vsizer.Add(hsizer, 0, wx.ALIGN_CENTER)
        vsizer.AddStretchSpacer()
        self.panel.SetSizer(vsizer)
        # Frame Layout
        fsizer = wx.BoxSizer(wx.VERTICAL)
        fsizer.Add(self.panel, 1, wx.EXPAND)
        self.SetSizer(fsizer)
        self.SetInitialSize()
        # Event Handlers
        self.okbutton.Bind(wx.EVT_BUTTON, self.OnOK, id=-1)
        self.cancelbutton.Bind(wx.EVT_BUTTON, self.OnDestroyCustomDialog, id=-1)
        self.Bind(wx.EVT_CLOSE, self.OnDestroyCustomDialog, id=-1)
        self.textctrl.Bind(wx.EVT_TEXT, self.OnCheckProjectsColorTextCtrl, id=-1)
        self.checkboxblankesp.Bind(wx.EVT_CHECKBOX, self.OnCheckBoxChange, id=-1)
        self.checkboxblankwizard.Bind(wx.EVT_CHECKBOX, self.OnCheckBoxChange, id=-1)
        # Dialog Icon Handlers
        self.SetIcon(wx.Icon(self.mopyDir + os.sep + u'bash' + os.sep + u'images' + os.sep + u'diamond_white_off.png', wx.BITMAP_TYPE_PNG))
        self.OnCheckBoxChange(self)

    def OnCheckProjectsColorTextCtrl(self, event):
        projectname = self.textctrl.GetValue()
        if projectname in self.existingprojects: #Fill this in. Compare this with the self.existingprojects list
            self.textctrl.SetBackgroundColour('#FF0000')
        else:
            self.textctrl.SetBackgroundColour('#FFFFFF')
        self.textctrl.Refresh()
        # print ('Text has been changed')

    def OnCheckBoxChange(self, event):
        ''' Change the Dialog Icon to represent what the project status will be when created. '''
        if self.checkboxblankesp.IsChecked():
            if self.checkboxblankwizard.IsChecked():
                super(CreateNewProject,self).SetIcon(wx.Icon(self.mopyDir + os.sep + u'bash' + os.sep + u'images' + os.sep + u'diamond_white_off_wiz.png', wx.BITMAP_TYPE_PNG))
            else:
                super(CreateNewProject,self).SetIcon(wx.Icon(self.mopyDir + os.sep + u'bash' + os.sep + u'images' + os.sep + u'diamond_white_off.png', wx.BITMAP_TYPE_PNG))
        else:
            super(CreateNewProject,self).SetIcon(wx.Icon(self.mopyDir + os.sep + u'bash' + os.sep + u'images' + os.sep + u'diamond_grey_off.png', wx.BITMAP_TYPE_PNG))
        # print ('Changed Dialog Icon')

    def OnOK(self, event):
        ''' Create the New Project and add user specified extras. '''
        projectname = self.textctrl.GetValue()#The name of the directory to be created

        if not os.path.exists(u'%s' %self.bashinstallersDir + os.sep + u'%s' %projectname): #This checks to see if the Generated New Project directory exists first,
            os.mkdir(u'%s' %self.bashinstallersDir + os.sep + u'%s' %projectname) #then creates it if it doesn't exist
            #Then check what checkboxes are checked and add extras.
            ExtrasDir = self.mopyDir + os.sep + u'templates'
            NewProjectDir = u'%s' %self.bashinstallersDir + os.sep + u'%s' %projectname
            if self.checkboxblankesp.IsChecked(): #Copy the Blank.esp into the New Project
                sourcefile = (ExtrasDir + os.sep + u'Blank.esp') #This is the file to be copied into the created New Project Directory.
                destinationfile = (NewProjectDir + os.sep + u'Blank.esp')   #This is the destination of the sourcefile.
                shutil.copy(sourcefile, destinationfile) #This copies the Blank.esp into the New Project folder that was generated in the code above.
            if self.checkboxblankwizard.IsChecked(): #Create the wizard.txt here
                text_file = open(NewProjectDir + os.sep + u'wizard.txt', 'w')
                text_file.write(u';# ' + projectname + u' BAIN Wizard Installation Script')
                text_file.close()
            if self.checkboxwizardimagesdirectory.IsChecked(): #Create the 'Wizard Images' Directory
                os.mkdir(NewProjectDir + os.sep + u'Wizard Images')
            if self.checkboxdocsdirectory.IsChecked(): #Create the 'Docs' Directory
                os.mkdir(NewProjectDir + os.sep + u'Docs')
            if self.checkboxscreenshotnoext.IsChecked(): #Copy the dummy default 'Screenshot' into the New Project
                sourcefile = (ExtrasDir + os.sep + u'Screenshot') #This is the file to be copied into the created New Project Directory.
                destinationfile = (NewProjectDir + os.sep + u'Screenshot') #This is the destination of the sourcefile.
                shutil.copy(sourcefile, destinationfile) #This copies the Screenshot into the New Project folder that was generated in the code above.
            refresh = True #Refresh Data so project shows up
        else:
            dialog = wx.MessageDialog(self, u'There is already a project with that name!\nPick a different name for the project and try again.', u'ERROR', wx.OK | wx.ICON_ERROR)
            dialog.ShowModal()
            dialog.Destroy()

        if refresh:
            self.Destroy()
            self.fullRefresh = False
            gInstallers.refreshed = False
            gInstallers.fullRefresh = self.fullRefresh
            gInstallers.OnShow()
            # print projectname

    def OnDestroyCustomDialog(self, event):
        self.Destroy()

class Installer_CreateNewProject(InstallerLink):
    """Open the Create New Project Dialog"""
    def AppendToMenu(self, menu, window, data):
        Link.AppendToMenu(self, menu, window, data)
        title = _(u'Create New Project...')
        menuItem = wx.MenuItem(menu, self.id, title, help=_(u'Create a new project...'))
        menu.AppendItem(menuItem)

    def Execute(self, event):
        dialog = CreateNewProject(None,-1,u'Create New Project')
        dialog.ShowModal()
        dialog.Destroy()

# Initialization --------------------------------------------------------------
def InitSettings():
    """Initializes settings dictionary for bosh and basher."""
    bosh.initSettings()
    global settings
    balt._settings = bosh.settings
    balt.sizes = bosh.settings.getChanged('bash.window.sizes',{})
    settings = bosh.settings
    settings.loadDefaults(settingDefaults)
    #--Wrye Balt
    settings['balt.WryeLog.temp'] = bosh.dirs['saveBase'].join(u'WryeLogTemp.html')
    settings['balt.WryeLog.cssDir'] = bosh.dirs['mods'].join(u'Docs')
    #--StandAlone version?
    settings['bash.standalone'] = hasattr(sys,'frozen')
    initPatchers()

def InitImages():
    """Initialize color and image collections."""
    #--Colors
    for key,value in settings['bash.colors'].iteritems():
        colors[key] = value

    #--Standard
    images['save.on'] = Image(GPath(bosh.dirs['images'].join(u'save_on.png')),wx.BITMAP_TYPE_PNG)
    images['save.off'] = Image(GPath(bosh.dirs['images'].join(u'save_off.png')),wx.BITMAP_TYPE_PNG)
    #--Misc
    #images['oblivion'] = Image(GPath(bosh.dirs['images'].join(u'oblivion.png')),wx.BITMAP_TYPE_PNG)
    images['help.16'] = Image(GPath(bosh.dirs['images'].join(u'help16.png')))
    images['help.24'] = Image(GPath(bosh.dirs['images'].join(u'help24.png')))
    images['help.32'] = Image(GPath(bosh.dirs['images'].join(u'help32.png')))
    #--ColorChecks
    images['checkbox.red.x'] = Image(GPath(bosh.dirs['images'].join(u'checkbox_red_x.png')),wx.BITMAP_TYPE_PNG)
    images['checkbox.red.x.16'] = Image(GPath(bosh.dirs['images'].join(u'checkbox_red_x.png')),wx.BITMAP_TYPE_PNG)
    images['checkbox.red.x.24'] = Image(GPath(bosh.dirs['images'].join(u'checkbox_red_x_24.png')),wx.BITMAP_TYPE_PNG)
    images['checkbox.red.x.32'] = Image(GPath(bosh.dirs['images'].join(u'checkbox_red_x_32.png')),wx.BITMAP_TYPE_PNG)
    images['checkbox.red.off.16'] = (Image(GPath(bosh.dirs['images'].join(u'checkbox_red_off.png')),wx.BITMAP_TYPE_PNG))
    images['checkbox.red.off.24'] = (Image(GPath(bosh.dirs['images'].join(u'checkbox_red_off_24.png')),wx.BITMAP_TYPE_PNG))
    images['checkbox.red.off.32'] = (Image(GPath(bosh.dirs['images'].join(u'checkbox_red_off_32.png')),wx.BITMAP_TYPE_PNG))

    images['checkbox.green.on.16'] = (Image(GPath(bosh.dirs['images'].join(u'checkbox_green_on.png')),wx.BITMAP_TYPE_PNG))
    images['checkbox.green.off.16'] = (Image(GPath(bosh.dirs['images'].join(u'checkbox_green_off.png')),wx.BITMAP_TYPE_PNG))
    images['checkbox.green.on.24'] = (Image(GPath(bosh.dirs['images'].join(u'checkbox_green_on_24.png')),wx.BITMAP_TYPE_PNG))
    images['checkbox.green.off.24'] = (Image(GPath(bosh.dirs['images'].join(u'checkbox_green_off_24.png')),wx.BITMAP_TYPE_PNG))
    images['checkbox.green.on.32'] = (Image(GPath(bosh.dirs['images'].join(u'checkbox_green_on_32.png')),wx.BITMAP_TYPE_PNG))
    images['checkbox.green.off.32'] = (Image(GPath(bosh.dirs['images'].join(u'checkbox_green_off_32.png')),wx.BITMAP_TYPE_PNG))

    images['checkbox.blue.on.16'] = (Image(GPath(bosh.dirs['images'].join(u'checkbox_blue_on.png')),wx.BITMAP_TYPE_PNG))
    images['checkbox.blue.on.24'] = (Image(GPath(bosh.dirs['images'].join(u'checkbox_blue_on_24.png')),wx.BITMAP_TYPE_PNG))
    images['checkbox.blue.on.32'] = (Image(GPath(bosh.dirs['images'].join(u'checkbox_blue_on_32.png')),wx.BITMAP_TYPE_PNG))
    images['checkbox.blue.off.16'] = (Image(GPath(bosh.dirs['images'].join(u'checkbox_blue_off.png')),wx.BITMAP_TYPE_PNG))
    images['checkbox.blue.off.24'] = (Image(GPath(bosh.dirs['images'].join(u'checkbox_blue_off_24.png')),wx.BITMAP_TYPE_PNG))
    images['checkbox.blue.off.32'] = (Image(GPath(bosh.dirs['images'].join(u'checkbox_blue_off_32.png')),wx.BITMAP_TYPE_PNG))
    #--Bash
    images['bash.16'] = Image(GPath(bosh.dirs['images'].join(u'bash_16.png')),wx.BITMAP_TYPE_PNG)
    images['bash.24'] = Image(GPath(bosh.dirs['images'].join(u'bash_24.png')),wx.BITMAP_TYPE_PNG)
    images['bash.32'] = Image(GPath(bosh.dirs['images'].join(u'bash_32.png')),wx.BITMAP_TYPE_PNG)
    images['bash.16.blue'] = Image(GPath(bosh.dirs['images'].join(u'bash_16_blue.png')),wx.BITMAP_TYPE_PNG)
    images['bash.24.blue'] = Image(GPath(bosh.dirs['images'].join(u'bash_24_blue.png')),wx.BITMAP_TYPE_PNG)
    images['bash.32.blue'] = Image(GPath(bosh.dirs['images'].join(u'bash_32_blue.png')),wx.BITMAP_TYPE_PNG)
    #--Bash Patch Dialogue
    images['monkey.16'] = Image(GPath(bosh.dirs['images'].join(u'wryemonkey16.jpg')),wx.BITMAP_TYPE_JPEG)
    #images['monkey.32'] = Image(GPath(bosh.dirs['images'].join(u'wryemonkey32.jpg')),wx.BITMAP_TYPE_JPEG)
    #--DocBrowser
    images['doc.16'] = Image(GPath(bosh.dirs['images'].join(u'DocBrowser16.png')),wx.BITMAP_TYPE_PNG)
    images['doc.24'] = Image(GPath(bosh.dirs['images'].join(u'DocBrowser24.png')),wx.BITMAP_TYPE_PNG)
    images['doc.32'] = Image(GPath(bosh.dirs['images'].join(u'DocBrowser32.png')),wx.BITMAP_TYPE_PNG)
    #--Applications Icons
    global bashRed
    bashRed = balt.ImageBundle()
    bashRed.Add(images['bash.16'])
    bashRed.Add(images['bash.24'])
    bashRed.Add(images['bash.32'])
    #--Application Subwindow Icons
    global bashBlue
    bashBlue = balt.ImageBundle()
    bashBlue.Add(images['bash.16.blue'])
    bashBlue.Add(images['bash.24.blue'])
    bashBlue.Add(images['bash.32.blue'])
    global bashDocBrowser
    bashDocBrowser = balt.ImageBundle()
    bashDocBrowser.Add(images['doc.16'])
    bashDocBrowser.Add(images['doc.24'])
    bashDocBrowser.Add(images['doc.32'])
    global bashMonkey
    bashMonkey = balt.ImageBundle()
    bashMonkey.Add(images['monkey.16'])

def InitStatusBar():
    """Initialize status bar links."""
    dirImages = bosh.dirs['images']
    def imageList(template):
        return [Image(dirImages.join(template % x)) for x in (16,24,32)]
    #--Bash Status/LinkBar
    global obseButton
    obseButton = Obse_Button(uid=u'OBSE')
    BashStatusBar.buttons.append(obseButton)
    global laaButton
    laaButton = LAA_Button(uid=u'LAA')
    BashStatusBar.buttons.append(laaButton)
    BashStatusBar.buttons.append(AutoQuit_Button(uid=u'AutoQuit'))
    BashStatusBar.buttons.append( # Game
        Oblivion_Button(
            bosh.dirs['app'].join(bush.game.exe),
            imageList(u'%s%%s.png' % bush.game.name.lower()),
            u' '.join((_(u"Launch"),bush.game.name)),
            u' '.join((_(u"Launch"),bush.game.name,u'%(version)s')),
            u'',
            uid=u'Oblivion'))
    BashStatusBar.buttons.append( #TESCS/CreationKit
        TESCS_Button(
            bosh.dirs['app'].join(bush.game.cs.exe),
            imageList(bush.game.cs.imageName),
            u' '.join((_(u"Launch"),bush.game.cs.shortName)),
            u' '.join((_(u"Launch"),bush.game.cs.shortName,u'%(version)s')),
            bush.game.cs.seArgs,
            uid=u'TESCS'))
    BashStatusBar.buttons.append( #OBMM
        App_Button(
            bosh.dirs['app'].join(u'OblivionModManager.exe'),
            imageList(u'obmm%s.png'),
            _(u"Launch OBMM"),
            uid=u'OBMM'))
    BashStatusBar.buttons.append( #ISOBL
        Tooldir_Button(
            u'ISOBL',
            imageList(u'isobl%s.png'),
            _(u"Launch InsanitySorrow's Oblivion Launcher")))
    BashStatusBar.buttons.append( #ISRMG
        Tooldir_Button(
            u'ISRMG',
            imageList(u"insanity'sreadmegenerator%s.png"),
            _(u"Launch InsanitySorrow's Readme Generator")))
    BashStatusBar.buttons.append( #ISRNG
        Tooldir_Button(
            u'ISRNG',
            imageList(u"insanity'srng%s.png"),
            _(u"Launch InsanitySorrow's Random Name Generator")))
    BashStatusBar.buttons.append( #ISRNPCG
        Tooldir_Button(
            u'ISRNPCG',
            imageList(u'randomnpc%s.png'),
            _(u"Launch InsanitySorrow's Random NPC Generator")))
    BashStatusBar.buttons.append( #OBFEL
        Tooldir_Button(
            u'OBFEL',
            imageList(u'oblivionfaceexchangerlite%s.png'),
            _(u"Oblivion Face Exchange Lite")))
    BashStatusBar.buttons.append( #OBMLG
        Tooldir_Button(
            u'OBMLG',
            imageList(u'modlistgenerator%s.png'),
            _(u"Oblivion Mod List Generator")))
    BashStatusBar.buttons.append( #OblivionBookCreator
        App_Button(
            (bosh.tooldirs['OblivionBookCreatorPath'],bosh.inisettings['OblivionBookCreatorJavaArg']),
            imageList(u'oblivionbookcreator%s.png'),
            _(u"Launch Oblivion Book Creator"),
            uid=u'OblivionBookCreator'))
    BashStatusBar.buttons.append( #BSACommander
        Tooldir_Button(
            u'BSACMD',
            imageList(u'bsacommander%s.png'),
            _(u"Launch BSA Commander")))
    BashStatusBar.buttons.append( #Tabula
        Tooldir_Button(
            u'Tabula',
            imageList(u'tabula%s.png'),
            _(u"Launch Tabula")))
    BashStatusBar.buttons.append( #Tes4Files
        Tooldir_Button(
            u'Tes4FilesPath',
            imageList(u'tes4files%s.png'),
            _(u"Launch TES4Files")))
    BashStatusBar.buttons.append( #Tes4Gecko
        App_Button(
            (bosh.tooldirs['Tes4GeckoPath'],bosh.inisettings['Tes4GeckoJavaArg']),
            imageList(u'tes4gecko%s.png'),
            _(u"Launch Tes4Gecko"),
            uid=u'Tes4Gecko'))
    BashStatusBar.buttons.append( #Tes4View
        App_Tes4View(
            (bosh.tooldirs['Tes4ViewPath'],u'-TES4'), #no cmd argument to force view mode
            imageList(u'tes4view%s.png'),
            _(u"Launch TES4View"),
            uid=u'TES4View'))
    BashStatusBar.buttons.append( #Tes4Edit
        App_Tes4View(
            (bosh.tooldirs['Tes4EditPath'],u'-TES4 -edit'),
            imageList(u'tes4edit%s.png'),
            _(u"Launch TES4Edit"),
            uid=u'TES4Edit'))
    BashStatusBar.buttons.append( #Tes4Trans
        App_Tes4View(
            (bosh.tooldirs['Tes4TransPath'],u'-TES4 -translate'),
            imageList(u'tes4trans%s.png'),
            _(u"Launch TES4Trans"),
            uid=u'TES4Trans'))
    BashStatusBar.buttons.append( #Tes4LODGen
        App_Tes4View(
            (bosh.tooldirs['Tes4LodGenPath'],u'-TES4 -lodgen'),
            imageList(u'tes4lodgen%s.png'),
            _(u"Launch Tes4LODGen"),
            uid=u'TES4LODGen'))
    BashStatusBar.buttons.append( #BOSS
        App_BOSS(
            (bosh.dirs['boss'].join(u'BOSS.exe')),
            imageList(u'boss%s.png'),
            _(u"Launch BOSS"),
            uid=u'BOSS'))
    if bosh.inisettings['ShowModelingToolLaunchers']:
        BashStatusBar.buttons.append( #AutoCad
            Tooldir_Button(
                'AutoCad',
                imageList(u'autocad%s.png'),
                _(u"Launch AutoCad")))
        BashStatusBar.buttons.append( #Blender
            Tooldir_Button(
                'BlenderPath',
                imageList(u'blender%s.png'),
                _(u"Launch Blender")))
        BashStatusBar.buttons.append( #Dogwaffle
            Tooldir_Button(
                'Dogwaffle',
                imageList(u'dogwaffle%s.png'),
                _(u"Launch Dogwaffle")))
        BashStatusBar.buttons.append( #GMax
            Tooldir_Button(
                'GmaxPath',
                imageList(u'gmax%s.png'),
                _(u"Launch Gmax")))
        BashStatusBar.buttons.append( #Maya
            Tooldir_Button(
                'MayaPath',
                imageList(u'maya%s.png'),
                _(u"Launch Maya")))
        BashStatusBar.buttons.append( #Max
            Tooldir_Button(
                'MaxPath',
                imageList(u'3dsmax%s.png'),
                _(u"Launch 3dsMax")))
        BashStatusBar.buttons.append( #Milkshape3D
            Tooldir_Button(
                'Milkshape3D',
                imageList(u'milkshape3d%s.png'),
                _(u"Launch Milkshape 3D")))
        BashStatusBar.buttons.append( #Mudbox
            Tooldir_Button(
                'Mudbox',
                imageList(u'mudbox%s.png'),
                _(u"Launch Mudbox")))
        BashStatusBar.buttons.append( #Sculptris
            Tooldir_Button(
                'Sculptris',
                imageList(u'sculptris%s.png'),
                _(u"Launch Sculptris")))
        BashStatusBar.buttons.append( #Softimage Mod Tool
            App_Button(
                (bosh.tooldirs['SoftimageModTool'],u'-mod'),
                imageList(u'softimagemodtool%s.png'),
                _(u"Launch Softimage Mod Tool"),
                uid=u'SoftimageModTool'))
        BashStatusBar.buttons.append( #SpeedTree
            Tooldir_Button(
                'SpeedTree',
                imageList(u'speedtree%s.png'),
                _(u"Launch SpeedTree")))
        BashStatusBar.buttons.append( #Tree[d]
            Tooldir_Button(
                'Treed',
                imageList(u'treed%s.png'),
                _(u"Launch Tree\[d\]")))
        BashStatusBar.buttons.append( #Wings3D
            Tooldir_Button(
                'Wings3D',
                imageList(u'wings3d%s.png'),
                _(u"Launch Wings 3D")))
    if bosh.inisettings['ShowModelingToolLaunchers'] or bosh.inisettings['ShowTextureToolLaunchers']:
        BashStatusBar.buttons.append( #Nifskope
            Tooldir_Button(
                'NifskopePath',
                imageList(u'nifskope%s.png'),
                _(u"Launch Nifskope")))
    if bosh.inisettings['ShowTextureToolLaunchers']:
        BashStatusBar.buttons.append( #AniFX
            Tooldir_Button(
                'AniFX',
                imageList(u'anifx%s.png'),
                _(u"Launch AniFX")))
        BashStatusBar.buttons.append( #Art Of Illusion
            Tooldir_Button(
                'ArtOfIllusion',
                imageList(u'artofillusion%s.png'),
                _(u"Launch Art Of Illusion")))
        BashStatusBar.buttons.append( #Artweaver
            Tooldir_Button(
                'Artweaver',
                imageList(u'artweaver%s.png'),
                _(u"Launch Artweaver")))
        BashStatusBar.buttons.append( #CrazyBump
            Tooldir_Button(
                'CrazyBump',
                imageList(u'crazybump%s.png'),
                _(u"Launch CrazyBump")))
        BashStatusBar.buttons.append( #DDSConverter
            Tooldir_Button(
                'DDSConverter',
                imageList(u'ddsconverter%s.png'),
                _(u"Launch DDSConverter")))
        BashStatusBar.buttons.append( #DeepPaint
            Tooldir_Button(
                'DeepPaint',
                imageList(u'deeppaint%s.png'),
                _(u"Launch DeepPaint")))
        BashStatusBar.buttons.append( #FastStone Image Viewer
            Tooldir_Button(
                'FastStone',
                imageList(u'faststoneimageviewer%s.png'),
                _(u"Launch FastStone Image Viewer")))
        BashStatusBar.buttons.append( #Genetica
            Tooldir_Button(
                'Genetica',
                imageList(u'genetica%s.png'),
                _(u"Launch Genetica")))
        BashStatusBar.buttons.append( #Genetica Viewer
            Tooldir_Button(
                'GeneticaViewer',
                imageList(u'geneticaviewer%s.png'),
                _(u"Launch Genetica Viewer")))
        BashStatusBar.buttons.append( #GIMP
            Tooldir_Button(
                'GIMP',
                imageList(u'gimp%s.png'),
                _(u"Launch GIMP")))
        BashStatusBar.buttons.append( #GIMP Shop
            Tooldir_Button(
                'GimpShop',
                imageList(u'gimpshop%s.png'),
                _(u"Launch GIMP Shop")))
        BashStatusBar.buttons.append( #IcoFX
            Tooldir_Button(
                'IcoFX',
                imageList(u'icofx%s.png'),
                _(u"Launch IcoFX")))
        BashStatusBar.buttons.append( #Inkscape
            Tooldir_Button(
                'Inkscape',
                imageList(u'inkscape%s.png'),
                _(u"Launch Inkscape")))
        BashStatusBar.buttons.append( #IrfanView
            Tooldir_Button(
                'IrfanView',
                imageList(u'irfanview%s.png'),
                _(u"Launch IrfanView")))
        BashStatusBar.buttons.append( #MaPZone
            Tooldir_Button(
                'MaPZone',
                imageList(u'mapzone%s.png'),
                _(u"Launch MaPZone")))
        BashStatusBar.buttons.append( #MyPaint
            Tooldir_Button(
                'MyPaint',
                imageList(u'mypaint%s.png'),
                _(u"Launch MyPaint")))
        BashStatusBar.buttons.append( #NVIDIAMelody
            Tooldir_Button(
                'NVIDIAMelody',
                imageList(u'nvidiamelody%s.png'),
                _(u"Launch Nvidia Melody")))
        BashStatusBar.buttons.append( #Paint.net
            Tooldir_Button(
                'PaintNET',
                imageList(u'paint.net%s.png'),
                _(u"Launch Paint.NET")))
        BashStatusBar.buttons.append( #PaintShop Photo Pro
            Tooldir_Button(
                'PaintShopPhotoPro',
                imageList(u'paintshopprox3%s.png'),
                _(u"Launch PaintShop Photo Pro")))
        BashStatusBar.buttons.append( #Photoshop
            Tooldir_Button(
                'PhotoshopPath',
                imageList(u'photoshop%s.png'),
                _(u"Launch Photoshop")))
        BashStatusBar.buttons.append( #PhotoScape
            Tooldir_Button(
                'PhotoScape',
                imageList(u'photoscape%s.png'),
                _(u"Launch PhotoScape")))
        BashStatusBar.buttons.append( #PhotoSEAM
            Tooldir_Button(
                'PhotoSEAM',
                imageList(u'photoseam%s.png'),
                _(u"Launch PhotoSEAM")))
        BashStatusBar.buttons.append( #Photobie Design Studio
            Tooldir_Button(
                'Photobie',
                imageList(u'photobie%s.png'),
                _(u"Launch Photobie")))
        BashStatusBar.buttons.append( #PhotoFiltre
            Tooldir_Button(
                'PhotoFiltre',
                imageList(u'photofiltre%s.png'),
                _(u"Launch PhotoFiltre")))
        BashStatusBar.buttons.append( #Pixel Studio Pro
            Tooldir_Button(
                'PixelStudio',
                imageList(u'pixelstudiopro%s.png'),
                _(u"Launch Pixel Studio Pro")))
        BashStatusBar.buttons.append( #Pixia
            Tooldir_Button(
                'Pixia',
                imageList(u'pixia%s.png'),
                _(u"Launch Pixia")))
        BashStatusBar.buttons.append( #TextureMaker
            Tooldir_Button(
                'TextureMaker',
                imageList(u'texturemaker%s.png'),
                _(u"Launch TextureMaker")))
        BashStatusBar.buttons.append( #Twisted Brush
            Tooldir_Button(
                'TwistedBrush',
                imageList(u'twistedbrush%s.png'),
                _(u"Launch TwistedBrush")))
        BashStatusBar.buttons.append( #Windows Texture Viewer
            Tooldir_Button(
                'WTV',
                imageList(u'wtv%s.png'),
                _(u"Launch Windows Texture Viewer")))
        BashStatusBar.buttons.append( #xNormal
            Tooldir_Button(
                'xNormal',
                imageList(u'xnormal%s.png'),
                _(u"Launch xNormal")))
        BashStatusBar.buttons.append( #XnView
            Tooldir_Button(
                'XnView',
                imageList(u'xnview%s.png'),
                _(u"Launch XnView")))
    if bosh.inisettings['ShowAudioToolLaunchers']:
        BashStatusBar.buttons.append( #Audacity
            Tooldir_Button(
                'Audacity',
                imageList(u'audacity%s.png'),
                _(u"Launch Audacity")))
        BashStatusBar.buttons.append( #ABCAmberAudioConverter
            Tooldir_Button(
                'ABCAmberAudioConverter',
                imageList(u'abcamberaudioconverter%s.png'),
                _(u"Launch ABC Amber Audio Converter")))
        BashStatusBar.buttons.append( #Switch
            Tooldir_Button(
                'Switch',
                imageList(u'switch%s.png'),
                _(u"Launch Switch")))
    BashStatusBar.buttons.append( #Fraps
        Tooldir_Button(
            'Fraps',
            imageList(u'fraps%s.png'),
            _(u"Launch Fraps")))
    BashStatusBar.buttons.append( #MAP
        Tooldir_Button(
            'MAP',
            imageList(u'interactivemapofcyrodiil%s.png'),
            _(u"Interactive Map of Cyrodiil and Shivering Isles")))
    BashStatusBar.buttons.append( #LogitechKeyboard
        Tooldir_Button(
            'LogitechKeyboard',
            imageList(u'logitechkeyboard%s.png'),
            _(u"Launch LogitechKeyboard")))
    BashStatusBar.buttons.append( #MediaMonkey
        Tooldir_Button(
            'MediaMonkey',
            imageList(u'mediamonkey%s.png'),
            _(u"Launch MediaMonkey")))
    BashStatusBar.buttons.append( #NPP
        Tooldir_Button(
            'NPP',
            imageList(u'notepad++%s.png'),
            _(u"Launch Notepad++")))
    BashStatusBar.buttons.append( #Steam
        Tooldir_Button(
            'Steam',
            imageList(u'steam%s.png'),
            _(u"Launch Steam")))
    BashStatusBar.buttons.append( #EVGA Precision
        Tooldir_Button(
            'EVGAPrecision',
            imageList(u'evgaprecision%s.png'),
            _(u"Launch EVGA Precision")))
    BashStatusBar.buttons.append( #WinMerge
        Tooldir_Button(
            'WinMerge',
            imageList(u'winmerge%s.png'),
            _(u"Launch WinMerge")))
    BashStatusBar.buttons.append( #Freemind
        Tooldir_Button(
            'FreeMind',
            imageList(u'freemind%s.png'),
            _(u"Launch FreeMind")))
    BashStatusBar.buttons.append( #Freeplane
        Tooldir_Button(
            'Freeplane',
            imageList(u'freeplane%s.png'),
            _(u"Launch Freeplane")))
    BashStatusBar.buttons.append( #FileZilla
        Tooldir_Button(
            'FileZilla',
            imageList(u'filezilla%s.png'),
            _(u"Launch FileZilla")))
    BashStatusBar.buttons.append( #EggTranslator
        Tooldir_Button(
            'EggTranslator',
            imageList(u'eggtranslator%s.png'),
            _(u"Launch Egg Translator")))
    BashStatusBar.buttons.append( #RADVideoTools
        Tooldir_Button(
            'RADVideo',
            imageList(u'radvideotools%s.png'),
            _(u"Launch RAD Video Tools")))
    BashStatusBar.buttons.append( #WinSnap
        Tooldir_Button(
            'WinSnap',
            imageList(u'winsnap%s.png'),
            _(u"Launch WinSnap")))
    #--Custom Apps
    dirApps = bosh.dirs['mopy'].join(u'Apps')
    bosh.initLinks(dirApps)
    folderIcon = None
    badIcons = [Image(bosh.dirs['images'].join(u'x.png'))] * 3
    for link in bosh.links:
        (target,workingdir,args,icon,description) = bosh.links[link]
        path = dirApps.join(link)
        if target.lower().find(ur'installer\{') != -1:
            target = path
        else:
            target = GPath(target)
        if target.exists():
            icon,idex = icon.split(u',')
            if icon == u'':
                if target.cext == u'.exe':
                    # Use the icon embedded in the exe
                    icon = target
                else:
                    # Use the default icon for that file type
                    try:
                        import _winreg
                        if target.isdir():
                            if folderIcon is None:
                                # Special handling of the Folder icon
                                folderkey = _winreg.OpenKey(
                                    _winreg.HKEY_CLASSES_ROOT,
                                    u'Folder')
                                iconkey = _winreg.OpenKey(
                                    folderkey,
                                    u'DefaultIcon')
                                filedata = _winreg.EnumValue(
                                    iconkey,0)
                                filedata = filedata[1]
                                filedata = re.sub(u'%SystemRoot%',os.environ['SYSTEMROOT'],filedata,flags=re.I|re.U)
                                folderIcon = filedata
                            else:
                                filedata = folderIcon
                        else:
                            icon_path = _winreg.QueryValue(
                                _winreg.HKEY_CLASSES_ROOT,
                                target.cext)
                            filedata = _winreg.QueryValue(
                                _winreg.HKEY_CLASSES_ROOT,
                                u'%s\\DefaultIcon' % icon_path)
                        icon,idex = filedata.split(u',')
                        if not os.path.isabs(icon):
                            # Get the correct path to the dll
                            for dir in os.environ['PATH'].split(u';'):
                                test = GPath(dir).join(icon)
                                if test.exists():
                                    icon = test
                                    break
                    except:
                        deprint(_(u'Error finding icon for %s:') % target.s,traceback=True)
                        icon = u'not\\a\\path'
            icon = GPath(icon)
            # First try a custom icon
            fileName = u'%s%%i.png' % path.sbody
            customIcons = [dirApps.join(fileName % x) for x in (16,24,32)]
            if customIcons[0].exists():
                icon = customIcons
            # Next try the shortcut specified icon
            else:
                if icon.exists():
                    fileName = u';'.join((icon.s,idex))
                    icon = [Image(fileName,wx.BITMAP_TYPE_ICO,x) for x in (16,24,32)]
            # Last, use the 'x' icon
                else:
                    icon = badIcons
            BashStatusBar.buttons.append(
                App_Button(
                    (path,()),
                    icon,
                    (description),
                    canHide=False
                    ))
    #--Final couple
    BashStatusBar.buttons.append(
        App_Button(
            (bosh.dirs['mopy'].join(u'Wrye Bash Launcher.pyw'), u'-d', u'--bashmon'),
            imageList(u'bashmon%s.png'),
            _(u"Launch BashMon"),
            uid=u'Bashmon'))
    BashStatusBar.buttons.append(App_DocBrowser(uid=u'DocBrowser'))
    BashStatusBar.buttons.append(App_ModChecker(uid=u'ModChecker'))
    BashStatusBar.buttons.append(App_Settings(uid=u'Settings',canHide=False))
    BashStatusBar.buttons.append(App_Help(uid=u'Help',canHide=False))
    if bosh.inisettings['ShowDevTools']:
        BashStatusBar.buttons.append(App_Restart(uid=u'Restart'))

def InitMasterLinks():
    """Initialize master list menus."""
    #--MasterList: Column Links
    if True: #--Sort by
        sortMenu = MenuLink(_(u"Sort by"))
        sortMenu.links.append(Mods_EsmsFirst())
        sortMenu.links.append(SeparatorLink())
        sortMenu.links.append(Files_SortBy('File'))
        sortMenu.links.append(Files_SortBy('Author'))
        sortMenu.links.append(Files_SortBy('Group'))
        sortMenu.links.append(Files_SortBy('Installer'))
        sortMenu.links.append(Files_SortBy('Load Order'))
        sortMenu.links.append(Files_SortBy('Modified'))
        sortMenu.links.append(Files_SortBy('Save Order'))
        sortMenu.links.append(Files_SortBy('Status'))
        MasterList.mainMenu.append(sortMenu)

    #--MasterList: Item Links
    MasterList.itemMenu.append(Master_ChangeTo())
    MasterList.itemMenu.append(Master_Disable())

def InitInstallerLinks():
    """Initialize people tab menus."""
    #--Column links
    #--Sorting
    if True:
        sortMenu = MenuLink(_(u"Sort by"))
        sortMenu.links.append(Installers_SortActive())
        sortMenu.links.append(Installers_SortProjects())
        #InstallersPanel.mainMenu.append(Installers_SortStructure())
        sortMenu.links.append(SeparatorLink())
        sortMenu.links.append(Files_SortBy('Package'))
        sortMenu.links.append(Files_SortBy('Order'))
        sortMenu.links.append(Files_SortBy('Modified'))
        sortMenu.links.append(Files_SortBy('Size'))
        sortMenu.links.append(Files_SortBy('Files'))
        InstallersPanel.mainMenu.append(sortMenu)
    #--Columns
    InstallersPanel.mainMenu.append(SeparatorLink())
    InstallersPanel.mainMenu.append(List_Columns('bash.installers.cols',['Package']))
    #--Actions
    InstallersPanel.mainMenu.append(SeparatorLink())
    InstallersPanel.mainMenu.append(balt.Tanks_Open())
    InstallersPanel.mainMenu.append(Installers_Refresh(fullRefresh=False))
    InstallersPanel.mainMenu.append(Installers_Refresh(fullRefresh=True))
    InstallersPanel.mainMenu.append(Installers_AddMarker())
    InstallersPanel.mainMenu.append(Installer_CreateNewProject())
    InstallersPanel.mainMenu.append(SeparatorLink())
    InstallersPanel.mainMenu.append(Installer_ListPackages())
    InstallersPanel.mainMenu.append(SeparatorLink())
    InstallersPanel.mainMenu.append(Installers_AnnealAll())
    InstallersPanel.mainMenu.append(Files_Unhide('installer'))
    InstallersPanel.mainMenu.append(SeparatorLink())
    InstallersPanel.mainMenu.append(Installers_UninstallAllPackages())
    InstallersPanel.mainMenu.append(Installers_UninstallAllUnknownFiles())
    #--Behavior
    InstallersPanel.mainMenu.append(SeparatorLink())
    InstallersPanel.mainMenu.append(Installers_AvoidOnStart())
    InstallersPanel.mainMenu.append(Installers_Enabled())
    InstallersPanel.mainMenu.append(SeparatorLink())
    InstallersPanel.mainMenu.append(Installers_AutoAnneal())
    if bEnableWizard:
        InstallersPanel.mainMenu.append(Installers_AutoWizard())
    InstallersPanel.mainMenu.append(Installers_AutoRefreshProjects())
    InstallersPanel.mainMenu.append(Installers_AutoRefreshBethsoft())
    InstallersPanel.mainMenu.append(Installers_AutoApplyEmbeddedBCFs())
    InstallersPanel.mainMenu.append(Installers_BsaRedirection())
    InstallersPanel.mainMenu.append(Installers_RemoveEmptyDirs())
    InstallersPanel.mainMenu.append(Installers_ConflictsReportShowsInactive())
    InstallersPanel.mainMenu.append(Installers_ConflictsReportShowsLower())
    InstallersPanel.mainMenu.append(Installers_WizardOverlay())
    InstallersPanel.mainMenu.append(SeparatorLink())
    InstallersPanel.mainMenu.append(Installers_SkipOBSEPlugins())
    InstallersPanel.mainMenu.append(Installers_SkipScreenshots())
    InstallersPanel.mainMenu.append(Installers_SkipImages())
    InstallersPanel.mainMenu.append(Installers_SkipDocs())
    InstallersPanel.mainMenu.append(Installers_SkipDistantLOD())
    InstallersPanel.mainMenu.append(Installers_skipLandscapeLODMeshes())
    InstallersPanel.mainMenu.append(Installers_skipLandscapeLODTextures())
    InstallersPanel.mainMenu.append(Installers_skipLandscapeLODNormals())
    InstallersPanel.mainMenu.append(Installers_RenameStrings())

    #--Item links
    #--File
    InstallersPanel.itemMenu.append(Installer_Open())
    InstallersPanel.itemMenu.append(Installer_Duplicate())
    InstallersPanel.itemMenu.append(balt.Tank_Delete())
    if True: #--Open At...
        openAtMenu = InstallerOpenAt_MainMenu(_(u"Open at"))
        openAtMenu.links.append(Installer_OpenSearch())
        openAtMenu.links.append(Installer_OpenTesNexus())
        openAtMenu.links.append(Installer_OpenSkyrimNexus())
        openAtMenu.links.append(Installer_OpenTESA())
        openAtMenu.links.append(Installer_OpenPES())
        InstallersPanel.itemMenu.append(openAtMenu)
    InstallersPanel.itemMenu.append(Installer_Hide())
    InstallersPanel.itemMenu.append(Installer_Rename())
    #--Install, uninstall, etc.
    InstallersPanel.itemMenu.append(SeparatorLink())
    InstallersPanel.itemMenu.append(Installer_Refresh())
    InstallersPanel.itemMenu.append(Installer_Move())
    InstallersPanel.itemMenu.append(SeparatorLink())
    InstallersPanel.itemMenu.append(Installer_HasExtraData())
    InstallersPanel.itemMenu.append(Installer_OverrideSkips())
    InstallersPanel.itemMenu.append(Installer_SkipVoices())
    InstallersPanel.itemMenu.append(Installer_SkipRefresh())
    InstallersPanel.itemMenu.append(SeparatorLink())
    if bEnableWizard:
        InstallersPanel.itemMenu.append(Installer_Wizard(False))
        InstallersPanel.itemMenu.append(Installer_Wizard(True))
        InstallersPanel.itemMenu.append(Installer_EditWizard())
        InstallersPanel.itemMenu.append(Installer_OpenWizardInCommentsWizBAINEditor())
        InstallersPanel.itemMenu.append(SeparatorLink())
    InstallersPanel.itemMenu.append(Installer_OpenReadme())
    InstallersPanel.itemMenu.append(Installer_Anneal())
    InstallersPanel.itemMenu.append(Installer_Install())
    InstallersPanel.itemMenu.append(Installer_Install('LAST'))
    InstallersPanel.itemMenu.append(Installer_Install('MISSING'))
    InstallersPanel.itemMenu.append(Installer_Uninstall())
    InstallersPanel.itemMenu.append(SeparatorLink())
    #--Build
    if True: #--BAIN Conversion
        conversionsMenu = InstallerConverter_MainMenu(_(u"Conversions"))
        conversionsMenu.links.append(InstallerConverter_Create())
        conversionsMenu.links.append(InstallerConverter_ConvertMenu(_(u"Apply")))
        InstallersPanel.itemMenu.append(conversionsMenu)
    InstallersPanel.itemMenu.append(InstallerProject_Pack())
    InstallersPanel.itemMenu.append(InstallerArchive_Unpack())
    InstallersPanel.itemMenu.append(InstallerProject_ReleasePack())
    InstallersPanel.itemMenu.append(InstallerProject_Sync())
    InstallersPanel.itemMenu.append(Installer_CopyConflicts())
    InstallersPanel.itemMenu.append(InstallerProject_OmodConfig())
    InstallersPanel.itemMenu.append(Installer_ListStructure())

    #--espms Main Menu
    InstallersPanel.espmMenu.append(Installer_Espm_SelectAll())
    InstallersPanel.espmMenu.append(Installer_Espm_DeselectAll())
    InstallersPanel.espmMenu.append(Installer_Espm_List())
    InstallersPanel.espmMenu.append(SeparatorLink())
    #--espms Item Menu
    InstallersPanel.espmMenu.append(Installer_Espm_Rename())
    InstallersPanel.espmMenu.append(Installer_Espm_Reset())
    InstallersPanel.espmMenu.append(SeparatorLink())
    InstallersPanel.espmMenu.append(Installer_Espm_ResetAll())

    #--Sub-Package Main Menu
    InstallersPanel.subsMenu.append(Installer_Subs_SelectAll())
    InstallersPanel.subsMenu.append(Installer_Subs_DeselectAll())
    InstallersPanel.subsMenu.append(Installer_Subs_ToggleSelection())
    InstallersPanel.subsMenu.append(SeparatorLink())
    InstallersPanel.subsMenu.append(Installer_Subs_ListSubPackages())

def InitINILinks():
    """Initialize INI Edits tab menus."""
    #--Column Links
    if True: #--Sort by
        sortMenu = MenuLink(_(u"Sort by"))
        sortMenu.links.append(INI_SortValid())
        sortMenu.links.append(SeparatorLink())
        sortMenu.links.append(Files_SortBy('File'))
        sortMenu.links.append(Files_SortBy('Installer'))
    INIList.mainMenu.append(sortMenu)
    INIList.mainMenu.append(SeparatorLink())
    INIList.mainMenu.append(List_Columns('bash.ini.cols',['File']))
    INIList.mainMenu.append(SeparatorLink())
    INIList.mainMenu.append(INI_AllowNewLines())
    INIList.mainMenu.append(Files_Open())
    INIList.mainMenu.append(INI_ListINIs())

    #--Item menu
    INIList.itemMenu.append(INI_Apply())
    INIList.itemMenu.append(INI_CreateNew())
    INIList.itemMenu.append(INI_ListErrors())
    INIList.itemMenu.append(SeparatorLink())
    INIList.itemMenu.append(INI_FileOpenOrCopy())
    INIList.itemMenu.append(INI_Delete())

def InitModLinks():
    """Initialize Mods tab menus."""
    #--ModList: Column Links
    if True: #--Load
        loadMenu = MenuLink(_(u"Load"))
        loadMenu.links.append(Mods_LoadList())
        ModList.mainMenu.append(loadMenu)
    if True: #--Sort by
        sortMenu = MenuLink(_(u"Sort by"))
        sortMenu.links.append(Mods_EsmsFirst())
        sortMenu.links.append(Mods_SelectedFirst())
        sortMenu.links.append(SeparatorLink())
        sortMenu.links.append(Files_SortBy('File'))
        sortMenu.links.append(Files_SortBy('Author'))
        sortMenu.links.append(Files_SortBy('Group'))
        sortMenu.links.append(Files_SortBy('Installer'))
        sortMenu.links.append(Files_SortBy('Load Order'))
        sortMenu.links.append(Files_SortBy('Modified'))
        sortMenu.links.append(Files_SortBy('Rating'))
        sortMenu.links.append(Files_SortBy('Size'))
        sortMenu.links.append(Files_SortBy('Status'))
        sortMenu.links.append(Files_SortBy('CRC'))
        sortMenu.links.append(Files_SortBy('Mod Status'))
        ModList.mainMenu.append(sortMenu)
    if bush.game.name == u'Oblivion': #--Versions
        versionsMenu = MenuLink(u"Oblivion.esm")
        versionsMenu.links.append(Mods_OblivionVersion(u'1.1'))
        versionsMenu.links.append(Mods_OblivionVersion(u'1.1b'))
        versionsMenu.links.append(Mods_OblivionVersion(u'GOTY non-SI'))
        versionsMenu.links.append(Mods_OblivionVersion(u'SI'))
        ModList.mainMenu.append(versionsMenu)
    #--Columns ----------------------------------
    ModList.mainMenu.append(SeparatorLink())
    ModList.mainMenu.append(List_Columns('bash.mods.cols',['File']))
    #--------------------------------------------
    ModList.mainMenu.append(SeparatorLink())
    #--File Menu---------------------------------
    if True:
        fileMenu = MenuLink(_(u'File'))
        if bush.game.esp.canBash:
            fileMenu.links.append(Mod_CreateBlankBashedPatch())
            fileMenu.links.append(Mod_CreateBlank())
            fileMenu.links.append(SeparatorLink())
        fileMenu.links.append(Files_Open())
        fileMenu.links.append(Files_Unhide('mod'))
        ModList.mainMenu.append(fileMenu)
    ModList.mainMenu.append(SeparatorLink())
    ModList.mainMenu.append(Mods_ListMods())
    ModList.mainMenu.append(Mods_ListBashTags())
    ModList.mainMenu.append(Mods_CleanDummyMasters())
    ModList.mainMenu.append(SeparatorLink())
    ModList.mainMenu.append(Mods_AutoGhost())
    if bosh.inisettings['EnableBalo']:
        ModList.mainMenu.append(Mods_AutoGroup())
        ModList.mainMenu.append(Mods_FullBalo())
    ModList.mainMenu.append(Mods_LockTimes())
    ModList.mainMenu.append(Mods_ScanDirty())

    #--ModList: Item Links
    if bosh.inisettings['ShowDevTools']:
        ModList.itemMenu.append(Mod_FullLoad())
    if True: #--File
        fileMenu = MenuLink(_(u"File"))
        if bush.game.esp.canBash:
            fileMenu.links.append(Mod_CreateDummyMasters())
            fileMenu.links.append(SeparatorLink())
        fileMenu.links.append(File_Backup())
        fileMenu.links.append(File_Duplicate())
        fileMenu.links.append(File_Snapshot())
        fileMenu.links.append(SeparatorLink())
        fileMenu.links.append(File_Delete())
        fileMenu.links.append(File_Hide())
        fileMenu.links.append(File_Redate())
        fileMenu.links.append(File_Sort())
        fileMenu.links.append(SeparatorLink())
        fileMenu.links.append(File_RevertToBackup())
        fileMenu.links.append(File_RevertToSnapshot())
        ModList.itemMenu.append(fileMenu)
    if True: #--Groups
        groupMenu = MenuLink(_(u"Group"))
        groupMenu.links.append(Mod_Groups())
        if bosh.inisettings['EnableBalo']:
            groupMenu.links.append(Mod_BaloGroups())
        ModList.itemMenu.append(groupMenu)
    if True: #--Ratings
        ratingMenu = MenuLink(_(u"Rating"))
        ratingMenu.links.append(Mod_Ratings())
        ModList.itemMenu.append(ratingMenu)
    #--------------------------------------------
    ModList.itemMenu.append(SeparatorLink())
    if bush.game.esp.canBash:
        ModList.itemMenu.append(Mod_Details())
    ModList.itemMenu.append(File_ListMasters())
    ModList.itemMenu.append(Mod_ShowReadme())
    ModList.itemMenu.append(Mod_ListBashTags())
    ModList.itemMenu.append(Mod_CreateBOSSReport())
    ModList.itemMenu.append(Mod_CopyModInfo())
    #--------------------------------------------
    ModList.itemMenu.append(SeparatorLink())
    ModList.itemMenu.append(Mod_AllowGhosting())
    ModList.itemMenu.append(Mod_Ghost())
    if bush.game.esp.canBash:
        ModList.itemMenu.append(SeparatorLink())
        ModList.itemMenu.append(Mod_MarkMergeable(False))
        if CBash:
            ModList.itemMenu.append(Mod_MarkMergeable(True))
        ModList.itemMenu.append(Mod_Patch_Update(False))
        if CBash:
            ModList.itemMenu.append(Mod_Patch_Update(True))
        ModList.itemMenu.append(Mod_ListPatchConfig())
        ModList.itemMenu.append(Mod_ExportPatchConfig())
        #--Advanced
        ModList.itemMenu.append(SeparatorLink())
        if True: #--Export
            exportMenu = MenuLink(_(u"Export"))
            exportMenu.links.append(CBash_Mod_CellBlockInfo())
            exportMenu.links.append(Mod_EditorIds_Export())
            exportMenu.links.append(Mod_Groups_Export())
    ##        exportMenu.links.append(Mod_ItemData_Export())
            exportMenu.links.append(Mod_Factions_Export())
            exportMenu.links.append(Mod_FullNames_Export())
            exportMenu.links.append(Mod_ActorLevels_Export())
            exportMenu.links.append(CBash_Mod_MapMarkers_Export())
            exportMenu.links.append(Mod_Prices_Export())
            exportMenu.links.append(Mod_FactionRelations_Export())
            exportMenu.links.append(Mod_IngredientDetails_Export())
            exportMenu.links.append(Mod_Scripts_Export())
            exportMenu.links.append(Mod_SigilStoneDetails_Export())
            exportMenu.links.append(Mod_SpellRecords_Export())
            exportMenu.links.append(Mod_Stats_Export())
            ModList.itemMenu.append(exportMenu)
        if True: #--Import
            importMenu = MenuLink(_(u"Import"))
            importMenu.links.append(Mod_EditorIds_Import())
            importMenu.links.append(Mod_Groups_Import())
    ##        importMenu.links.append(Mod_ItemData_Import())
            importMenu.links.append(Mod_Factions_Import())
            importMenu.links.append(Mod_FullNames_Import())
            importMenu.links.append(Mod_ActorLevels_Import())
            importMenu.links.append(CBash_Mod_MapMarkers_Import())
            importMenu.links.append(Mod_Prices_Import())
            importMenu.links.append(Mod_FactionRelations_Import())
            importMenu.links.append(Mod_IngredientDetails_Import())
            importMenu.links.append(Mod_Scripts_Import())
            importMenu.links.append(Mod_SigilStoneDetails_Import())
            importMenu.links.append(Mod_SpellRecords_Import())
            importMenu.links.append(Mod_Stats_Import())
            importMenu.links.append(SeparatorLink())
            importMenu.links.append(Mod_Face_Import())
            importMenu.links.append(Mod_Fids_Replace())
            ModList.itemMenu.append(importMenu)
        if True: #--Cleaning
            cleanMenu = MenuLink(_(u"Mod Cleaning"))
            cleanMenu.links.append(Mod_SkipDirtyCheck())
            cleanMenu.links.append(SeparatorLink())
            cleanMenu.links.append(Mod_ScanDirty())
            cleanMenu.links.append(Mod_RemoveWorldOrphans())
            cleanMenu.links.append(Mod_CleanMod())
            cleanMenu.links.append(Mod_UndeleteRefs())
            ModList.itemMenu.append(cleanMenu)
        ModList.itemMenu.append(Mod_AddMaster())
        ModList.itemMenu.append(Mod_CopyToEsmp())
        if bush.game.name != u'Skyrim':
            ModList.itemMenu.append(Mod_DecompileAll())
        ModList.itemMenu.append(Mod_FlipSelf())
        ModList.itemMenu.append(Mod_FlipMasters())
        if bush.game.name == u'Oblivion':
            ModList.itemMenu.append(Mod_SetVersion())
#    if bosh.inisettings['showadvanced'] == 1:
#        advmenu = MenuLink(_(u"Advanced Scripts"))
#        advmenu.links.append(Mod_DiffScripts())
        #advmenu.links.append(())

def InitSaveLinks():
    """Initialize save tab menus."""
    #--SaveList: Column Links
    if True: #--Sort
        sortMenu = MenuLink(_(u"Sort by"))
        sortMenu.links.append(Files_SortBy('File'))
        sortMenu.links.append(Files_SortBy('Cell'))
        sortMenu.links.append(Files_SortBy('PlayTime'))
        sortMenu.links.append(Files_SortBy('Modified'))
        sortMenu.links.append(Files_SortBy('Player'))
        sortMenu.links.append(Files_SortBy('Status'))
        SaveList.mainMenu.append(sortMenu)
    if bush.game.name == u'Oblivion': #--Versions
        versionsMenu = MenuLink(u"Oblivion.esm")
        versionsMenu.links.append(Mods_OblivionVersion(u'1.1',True))
        versionsMenu.links.append(Mods_OblivionVersion(u'1.1b',True))
        versionsMenu.links.append(Mods_OblivionVersion(u'GOTY non-SI',True))
        versionsMenu.links.append(Mods_OblivionVersion(u'SI',True))
        SaveList.mainMenu.append(versionsMenu)
    if True: #--Save Profiles
        subDirMenu = MenuLink(_(u"Profile"))
        subDirMenu.links.append(Saves_Profiles())
        SaveList.mainMenu.append(subDirMenu)
    #--Columns --------------------------------
    SaveList.mainMenu.append(SeparatorLink())
    SaveList.mainMenu.append(List_Columns('bash.saves.cols',['File']))
    #------------------------------------------
    SaveList.mainMenu.append(SeparatorLink())
    SaveList.mainMenu.append(Files_Open())
    SaveList.mainMenu.append(Files_Unhide('save'))

    #--SaveList: Item Links
    if True: #--File
        fileMenu = MenuLink(_(u"File")) #>>
        fileMenu.links.append(File_Backup())
        fileMenu.links.append(File_Duplicate())
        #fileMenu.links.append(File_Snapshot())
        fileMenu.links.append(SeparatorLink())
        fileMenu.links.append(File_Delete())
        fileMenu.links.append(File_Hide())
        fileMenu.links.append(SeparatorLink())
        fileMenu.links.append(File_RevertToBackup())
        fileMenu.links.append(Save_Rename())
        fileMenu.links.append(Save_Renumber())
        #fileMenu.links.append(File_RevertToSnapshot())
        SaveList.itemMenu.append(fileMenu)
    if True: #--Move to Profile
        moveMenu = MenuLink(_(u"Move To"))
        moveMenu.links.append(Save_Move())
        SaveList.itemMenu.append(moveMenu)
    if True: #--Copy to Profile
        copyMenu = MenuLink(_(u"Copy To"))
        copyMenu.links.append(Save_Move(True))
        SaveList.itemMenu.append(copyMenu)
    #--------------------------------------------
    SaveList.itemMenu.append(SeparatorLink())
    SaveList.itemMenu.append(Save_LoadMasters())
    SaveList.itemMenu.append(File_ListMasters())
    SaveList.itemMenu.append(Save_DiffMasters())
    if bush.game.ess.canEditMore:
        SaveList.itemMenu.append(Save_Stats())
        SaveList.itemMenu.append(Save_StatObse())
        #--------------------------------------------
        SaveList.itemMenu.append(SeparatorLink())
        SaveList.itemMenu.append(Save_EditPCSpells())
        SaveList.itemMenu.append(Save_RenamePlayer())
        SaveList.itemMenu.append(Save_EditCreatedEnchantmentCosts())
        SaveList.itemMenu.append(Save_ImportFace())
        SaveList.itemMenu.append(Save_EditCreated('ENCH'))
        SaveList.itemMenu.append(Save_EditCreated('ALCH'))
        SaveList.itemMenu.append(Save_EditCreated('SPEL'))
        SaveList.itemMenu.append(Save_ReweighPotions())
        SaveList.itemMenu.append(Save_UpdateNPCLevels())
    #--------------------------------------------
    SaveList.itemMenu.append(SeparatorLink())
    SaveList.itemMenu.append(Save_ExportScreenshot())
    #--------------------------------------------
    if bush.game.ess.canEditMore:
        SaveList.itemMenu.append(SeparatorLink())
        SaveList.itemMenu.append(Save_Unbloat())
        SaveList.itemMenu.append(Save_RepairAbomb())
        SaveList.itemMenu.append(Save_RepairFactions())
        SaveList.itemMenu.append(Save_RepairHair())

def InitBSALinks():
    """Initialize save tab menus."""
    #--BSAList: Column Links
    if True: #--Sort
        sortMenu = MenuLink(_(u"Sort by"))
        sortMenu.links.append(Files_SortBy('File'))
        sortMenu.links.append(Files_SortBy('Modified'))
        sortMenu.links.append(Files_SortBy('Size'))
        BSAList.mainMenu.append(sortMenu)
    BSAList.mainMenu.append(SeparatorLink())
    BSAList.mainMenu.append(Files_Open())
    BSAList.mainMenu.append(Files_Unhide('save'))

    #--BSAList: Item Links
    if True: #--File
        fileMenu = MenuLink(_(u"File")) #>>
        fileMenu.links.append(File_Backup())
        fileMenu.links.append(File_Duplicate())
        #fileMenu.links.append(File_Snapshot())
        fileMenu.links.append(SeparatorLink())
        fileMenu.links.append(File_Delete())
        fileMenu.links.append(File_Hide())
        fileMenu.links.append(SeparatorLink())
        fileMenu.links.append(File_RevertToBackup())
        #fileMenu.links.append(File_RevertToSnapshot())
        BSAList.itemMenu.append(fileMenu)
    #--------------------------------------------
    BSAList.itemMenu.append(SeparatorLink())
    BSAList.itemMenu.append(Save_LoadMasters())
    BSAList.itemMenu.append(File_ListMasters())
    BSAList.itemMenu.append(Save_DiffMasters())
    BSAList.itemMenu.append(Save_Stats())
    #--------------------------------------------
    BSAList.itemMenu.append(SeparatorLink())
    BSAList.itemMenu.append(Save_EditPCSpells())
    BSAList.itemMenu.append(Save_ImportFace())
    BSAList.itemMenu.append(Save_EditCreated('ENCH'))
    BSAList.itemMenu.append(Save_EditCreated('ALCH'))
    BSAList.itemMenu.append(Save_EditCreated('SPEL'))
    BSAList.itemMenu.append(Save_ReweighPotions())
    BSAList.itemMenu.append(Save_UpdateNPCLevels())
    #--------------------------------------------
    BSAList.itemMenu.append(SeparatorLink())
    BSAList.itemMenu.append(Save_Unbloat())
    BSAList.itemMenu.append(Save_RepairAbomb())
    BSAList.itemMenu.append(Save_RepairFactions())
    BSAList.itemMenu.append(Save_RepairHair())

def InitScreenLinks():
    """Initialize screens tab menus."""
    #--SaveList: Column Links
    ScreensList.mainMenu.append(Files_Open())
    ScreensList.mainMenu.append(SeparatorLink())
    ScreensList.mainMenu.append(List_Columns('bash.screens.cols',['File']))
    ScreensList.mainMenu.append(SeparatorLink())
    ScreensList.mainMenu.append(Screens_NextScreenShot())
    #--JPEG Quality
    if True:
        qualityMenu = MenuLink(_(u'JPEG Quality'))
        for i in range(100,80,-5):
            qualityMenu.links.append(Screen_JpgQuality(i))
        qualityMenu.links.append(Screen_JpgQualityCustom())
        ScreensList.mainMenu.append(SeparatorLink())
        ScreensList.mainMenu.append(qualityMenu)

    #--ScreensList: Item Links
    ScreensList.itemMenu.append(File_Open())
    ScreensList.itemMenu.append(Screen_Rename())
    ScreensList.itemMenu.append(File_Delete())
    ScreensList.itemMenu.append(SeparatorLink())
    if True: #--Convert
        convertMenu = MenuLink(_(u'Convert'))
        convertMenu.links.append(Screen_ConvertTo(u'jpg',wx.BITMAP_TYPE_JPEG))
        convertMenu.links.append(Screen_ConvertTo(u'png',wx.BITMAP_TYPE_PNG))
        convertMenu.links.append(Screen_ConvertTo(u'bmp',wx.BITMAP_TYPE_BMP))
        convertMenu.links.append(Screen_ConvertTo(u'tif',wx.BITMAP_TYPE_TIF))
        ScreensList.itemMenu.append(convertMenu)

def InitMessageLinks():
    """Initialize messages tab menus."""
    #--SaveList: Column Links
    MessageList.mainMenu.append(Messages_Archive_Import())
    MessageList.mainMenu.append(SeparatorLink())
    MessageList.mainMenu.append(List_Columns('bash.messages.cols',['Subject']))

    #--ScreensList: Item Links
    MessageList.itemMenu.append(Message_Delete())

def InitPeopleLinks():
    """Initialize people tab menus."""
    #--Header links
    PeoplePanel.mainMenu.append(People_AddNew())
    PeoplePanel.mainMenu.append(People_Import())
    PeoplePanel.mainMenu.append(SeparatorLink())
    PeoplePanel.mainMenu.append(List_Columns('bash.people.cols',['Name']))
    #--Item links
    PeoplePanel.itemMenu.append(People_Karma())
    PeoplePanel.itemMenu.append(SeparatorLink())
    PeoplePanel.itemMenu.append(People_AddNew())
    PeoplePanel.itemMenu.append(balt.Tank_Delete())
    PeoplePanel.itemMenu.append(People_Export())

def InitSettingsLinks():
    """Initialize settings menu."""
    global SettingsMenu
    SettingsMenu = Links()
    #--User settings
    SettingsMenu.append(Settings_BackupSettings())
    SettingsMenu.append(Settings_RestoreSettings())
    SettingsMenu.append(Settings_SaveSettings())
    #--OBSE Dll info
    SettingsMenu.append(SeparatorLink())
    SettingsMenu.append(Settings_ExportDllInfo())
    SettingsMenu.append(Settings_ImportDllInfo())
    #--Color config
    SettingsMenu.append(SeparatorLink())
    SettingsMenu.append(Settings_Colors())
    if True:
        tabsMenu = MenuLink(_(u'Tabs'))
        for key in settings['bash.tabs.order']:
            canDisable = bool(key != 'Mods')
            tabsMenu.links.append(Settings_Tab(key,canDisable))
        SettingsMenu.append(tabsMenu)
    #--StatusBar
    if True:
        sbMenu = MenuLink(_(u'Status bar'))
        #--Icon size
        if True:
            sizeMenu = MenuLink(_(u'Icon size'))
            for size in (16,24,32):
                sizeMenu.links.append(Settings_IconSize(size))
            sbMenu.links.append(sizeMenu)
        sbMenu.links.append(Settings_UnHideButtons())
        sbMenu.links.append(Settings_StatusBar_ShowVersions())
        SettingsMenu.append(sbMenu)
    SettingsMenu.append(Settings_Languages())
    SettingsMenu.append(Settings_PluginEncodings())
    SettingsMenu.append(Settings_Games())
    SettingsMenu.append(SeparatorLink())
    SettingsMenu.append(Settings_UseAltName())
    SettingsMenu.append(Mods_Deprint())
    SettingsMenu.append(Mods_DumpTranslator())
    #--Check for updates
    if True:
        updateMenu = MenuLink(_(u'Check for Updates'))
        updateMenu.links.append(Settings_CheckForUpdates())
        updateMenu.links.append(SeparatorLink())
        for freq,text in (('01-00-0000 00:00',_(u'Every Month')),
                          ('00-07-0000 00:00',_(u'Every Week')),
                          ('00-01-0000 00:00',_(u'Every Day')),
                          (True,_(u'Everytime Wrye Bash Starts.')),
                          (False,_(u'Never'))):
            updateMenu.links.append(Settings_CheckForUpdatesFrequency(freq,text))
        updateMenu.links.append(SeparatorLink())
        updateMenu.links.append(Settings_CheckForUpdates_DontAsk())
        updateMenu.links.append(Settings_CheckForUpdates_BackupSFX())
        updateMenu.links.append(Settings_ResetUpdateData())
        SettingsMenu.append(updateMenu)

def InitLinks():
    """Call other link initializers."""
    InitStatusBar()
    InitSettingsLinks()
    InitMasterLinks()
    InitInstallerLinks()
    InitINILinks()
    InitModLinks()
    InitSaveLinks()
    InitScreenLinks()
    InitMessageLinks()
    InitPeopleLinks()
    #InitBSALinks()

# Main ------------------------------------------------------------------------
if __name__ == '__main__':
    print _(u'Compiled')